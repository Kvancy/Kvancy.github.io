{"posts":[{"title":"PE文件笔记","text":"跟着b站学习完了PE结构，自己再整理和梳理一遍，巩固一下记忆！ 文件结构图： 1. PE文件简介PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件，PE文件是微软Windows操作系统上的程序文件（可能是间接被执行，如DLL） PE文件有自己的一种文件格式，叫做PE文件格式，它包含了可执行文件的描述信息，以及程序运行时需要的数据。PE文件格式由以下几个部分组成： MS-DOS头部：这是为了兼容MS-DOS系统而保留的一个头部结构，它包含了一些基本信息，如EXE标志、重定位表偏移量、PE头偏移量等 DOS Stub：这是一个可选的字节块，它通常是一个显示“此程序不能在DOS模式下运行”的消息的程序 PE头标识：这是一个四字节的标识，其内容固定为“PE00”，用来表示这是一个PE文件 标准PE头：这是一个20字节的结构，它记录了PE文件的全局属性，如运行平台、节的数量、创建时间等 扩展PE头：这是一个224字节的结构，它记录了PE文件执行时的一些重要信息，如入口地址、装载基址、节对齐粒度、校验和等 数据目录：这是一个128字节的结构，它记录了PE文件中一些特殊数据的位置和大小，如导入表、导出表、资源表等 节表：这是一个由若干个40字节的结构组成的表格，它记录了PE文件中每个节的名称、位置、大小、属性等信息 节数据：这是PE文件中实际存放代码和数据的部分，它由若干个节组成，每个节对应于节表中的一项 2. Dos头解析DOS头是PE文件开头的一个固定长度的结构体，是为了兼容MS-DOS系统而保留的一个头部结构，大小0x40字节。包含如下信息 e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位 MZ，可执行文件必须都是 MZ 开头 e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的PE头相对文件起始地址的偏移 e_cblp：最后一页中字节数 e_cp：文件中页数 e_crlc：重定位项数 e_cparhdr：头部占用的内存段数 e_minalloc：最小需要的附加内存段数 e_maxalloc：最大需要的附加内存段数 e_ss：初始SS值（相对于段起始地址） e_sp：初始SP值 e_csum：校验和 e_ip：初始IP值（相对于段起始地址） e_cs：初始CS值（相对于段起始地址） e_lfarlc：重定位表相对于文件起始地址的偏移 e_ovno：覆盖号 e_res：保留字 e_oemid：OEM标识符 e_oeminfo：OEM信息 e_res2：保留字 在DOS头中比较重要的两个参数是e_magic和e_lfanew，前者是PE文件标识头，后者是PE文件头的相对文件起始地址的偏移。 e_magic是前两个字节，对应的是字符串是MZ，e_ifanew是后四个字节，因为是小端序，所以对应的值是0x100，也就是说PE文件头对应偏移是0x100 在DOS头之后，还有一段DOS块，这段空间是由编译器生成，用来存储一些程序运行的信息，可以随意更改，对程序没有影响 3. PE头解析PE头又叫NT头，是整个PE文件真正的头部，共有三个字段 DWORD Signature PE文件头标识，两个字节，一般是504500 struct IMAGE_FILE_HEADER FileHeader 结构体，文件头 struct IMAGE_OPTIONAL_HEADER32 OptionalHeader结构体， 可选文件头 文件头结构体包含6个字段 enum IMAGE_MACHINE Machine WORD类型，程序允许的的CPU型号，为0则支持所有CPU WORD NumberOfSections 文件中区段的数量 time_t TimeDateStamp 时间戳 DWORD PointerToSymbolTable DWORD NumberOfSymbols WORD SizeOfOptionalHeader 可选PE头的大小，32位默认0xE0，64位默认0xF0 struct FILE_CHARACTERISTICS Characteristics WORD，文件属性，通过16位二进制控制是否可执行，是否是dll之类的文件属性 Typora卸载程序在DIE分析结果如下 64位下可选PE头包含以下字段 enum OPTIONAL_MAGIC Magic 标识64位32位，前者20B，后者10B BYTE MajorLinkerVersion BYTE MinorLinkerVersion DWORD SizeOfCode 所有代码段的总大小，按照文件对齐后的大小 DWORD SizeOfInitializedData 已初始化的数据大小，按照文件对齐 DWORD SizeOfUninitializedData 未初始化的数据大小，按照文件对齐 DWORD AddressOfEntryPoint 程序入口的OEP 存储的是一个偏移值，程序入口的内存偏移 DWORD BaseOfCode 代码开始地址 DWORD BaseOfData 数据开始地址 DWORD ImageBase 内存镜像地址，有可能是动态的，在DLL_CHARACTERISTICS DllCharacteristics中定义是否动态 DWORD SectionAlignment 内存对齐大小 DWORD FileAlignment 文件对齐大小 WORD MajorOperatingSystemVersion WORD MinorOperatingSystemVersion WORD MajorImageVersion WORD MinorImageVersion WORD MajorSubsystemVersion WORD MinorSubsystemVersion DWORD Win32VersionValue DWORD SizeOfImage 文件在内存中的大小，按照内存对齐后的大小 DWORD SizeOfHeaders DOS头+NT头+标准PE头+可选PE头+区段头，按照文件对齐后的大小 DWORD CheckSum enum IMAGE_SUBSYSTEM Subsystem struct DLL_CHARACTERISTICS DllCharacteristics DWORD SizeOfStackReserve DWORD SizeOfStackCommit DWORD SizeOfHeapReserve DWORD SizeOfHeapCommit DWORD LoaderFlags DWORD NumberOfRvaAndSizes 数据目录表的个数 struct IMAGE_DATA_DIRECTORY_ARRAY DataDirArray 数据目录表数组在导出表导入表里分析 在VS中控制该属性的地方： 数据目录表数组以及数据目录表结构体： 1234567891011121314151617181920212223242526//数据目录表数组struct IMAGE_DATA_DIRECTORY Export//导出表struct IMAGE_DATA_DIRECTORY Import//导入表struct IMAGE_DATA_DIRECTORY Resource//资源struct IMAGE_DATA_DIRECTORY Exception//异常struct IMAGE_DATA_DIRECTORY Security//安全struct IMAGE_DATA_DIRECTORY BaseRelocationTable//重定位表struct IMAGE_DATA_DIRECTORY DebugDirectory//调试信息struct IMAGE_DATA_DIRECTORY CopyrightOrArchitectureSpecificData//版权信息struct IMAGE_DATA_DIRECTORY GlobalPtr//RVA OF GPstruct IMAGE_DATA_DIRECTORY TLSDirectory//TLS directorystruct IMAGE_DATA_DIRECTORY LoadConfigurationDirectorystruct IMAGE_DATA_DIRECTORY BoundImportDirectorystruct IMAGE_DATA_DIRECTORY ImportAddressTable//导入函数地址表struct IMAGE_DATA_DIRECTORY DelayLoadImportDescriptorsstruct IMAGE_DATA_DIRECTORY COMRuntimedescriptorstruct IMAGE_DATA_DIRECTORY Reserved//表的结构体： typedef struct{ DWORD VirtualAddress;//真正表结构体的内存偏移 DWORD Size;//大小，可被修改，没什么用} IMAGE_DATA_DIRECTORY; 4. 区段头分析010中exe模版下的区段头结构体，数量取决于PE文件头的NumberOfSections 12345678910111213141516171819typedef struct{ BYTE Name[8] &lt;comment=&quot;can end without zero&quot;&gt;; //区段名称，字符串不用以0结尾 union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc;//该区段在内存中的真实大小 DWORD VirtualAddress; //区段在内存中的偏移地址 DWORD SizeOfRawData; //区段在对齐后的大小 DWORD PointerToRawData; //区段在文件中的偏移位置 DWORD PointerToRelocations;// DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; SECTION_CHARACTERISTICS Characteristics;//区段属性} IMAGE_SECTION_HEADER 在010中区段头数量和名称分析如下 5. 导出表分析导出表结构体： 123456789101112131415typedef struct{ DWORD Characteristics; time_t TimeDateStamp;//时间戳 WORD MajorVersion; WORD MinorVersion; DWORD Name;//导出表名称 DWORD Base;//导出表起始序号 DWORD NumberOfFunctions;//导出函数数量 = 终止序号-起始序号+1 DWORD NumberOfNames;//以名称导出函数的个数 DWORD AddressOfFunctions;//EAT 导出函数地址表 DWORD AddressOfNames;//ENT 导出函数名称表 DWORD AddressOfNameOrdinals; //EOT 导出函数序号表 } IMAGE_EXPORT_DIRECTORY ; 结构体中地址表。名称表，序号表都指的是内存偏移，也就是RVA，推到公式是RVA = FOA +filebuff 6. 导入表分析跟导出表不同，导入表一个程序可以有多个 导入表结构体： 123456789101112typedef struct{ union { ULONG Characteristics; ULONG OriginalFirstThunk ;//RVA，指向INT } DUMMYUNIONNAME; ULONG TimeDateStamp;//时间戳，如果不与dll绑定时，为0 ULONG ForwarderChain;// ULONG Name;//RVA dll的名称 ULONG FirstThunk;//RVA to IAT} IMAGE_IMPORT_DESCRIPTOR ​ 7. 重定位表123456typedef struct{ DWORD VirtualAddress &lt;format=hex,comment=CommentRVA2FOA&gt;; DWORD SizeOfBlock;// WORD TypeOffset[1];} IMAGE_BASE_RELOCATION &lt;comment=CommentImageBaseRelocation&gt;; 8. 利用TEB和PEB找到核心模块的信息PEB：Process Environment Block 进程环境块，存放进程相关信息 TEB：Thread Environment Block 线程环境块 PEB和TEB分别是进程环境块和线程环境块，它们是存放进程和线程信息的结构体。PEB和TEB的结构体成员有很多，其中一些是用于反调试技术的。PEB和TEB的访问方法有以下几种： 通过FS段寄存器获取TEB的地址，然后通过TEB的ProcessEnvironmentBlock成员（偏移量为0x30）获取PEB的地址 通过Ntdll.NtCurrentTeb()函数获取当前线程的TEB地址，然后通过TEB的ProcessEnvironmentBlock成员（偏移量为0x30）获取PEB的地址 通过GetModuleHandle()函数获取进程的ImageBase地址，然后通过ImageBase地址加上偏移量获取PEB的地址 PEB结构体定义 12345678910111213141516171819202122typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; //偏移0xc PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID Reserved4[3]; PVOID AtlThunkSListPtr; PVOID Reserved5; ULONG Reserved6; PVOID Reserved7; ULONG Reserved8; ULONG AtlThunkSListPtr32; PVOID Reserved9[45]; BYTE Reserved10[96]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved11[128]; PVOID Reserved12[1]; ULONG SessionId;} PEB, *PPEB; PPEB_LDR_DATA结构体定义 1234567typedef struct _PEB_LDR_DATA { BYTE Reserved1 [8]; PVOID Reserved2 [3]; LIST_ENTRY InMemoryOrderModuleList;//载入顺序排序的dll LIST_ENTRY InLoadOrderModuleList;//内存排序的dll LIST_ENTRY InInitializationOrderModuleList;//初始化排序的dll，偏移0x1c} PEB_LDR_DATA, *PPEB_LDR_DATA; LIST_ENTRY结构体定义 1234typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink;//下一个节点的指针 struct _LIST_ENTRY *Blink;//上一个节点的指针} LIST_ENTRY, *PLIST_ENTRY, *PRLIST_ENTRY; 获取kernel32.dll或者kernerbase.dll的模块信息 kernel32.dll和kernerbase.dll都是Windows操作系统的重要文件，它们是NT内核系统的底层API接口的DLL文件，与其他应用程序和运行库进行交互。1 kernel32.dll和kernerbase.dll有相同的功能，但是它们的区别在于，kernel32.dll是一个向后兼容的文件，它包含了一些旧版本的Windows API函数，而kernerbase.dll是一个新的文件，它包含了一些新版本的Windows API函数。 kernel32.dll和kernerbase.dll包含GetProcAddress，LoadLibraryA，LoadModule等等 更多API-&gt;Geoff Chappell, Software Analyst user32.dll-&gt;User32大全详解-CSDN博客 mov esi,dword ptr fs:[0x30] 获取PEB地址 mov esi,[esi+0xc] 获取Ldr地址 mov esi,[esi+0x1c] 获取InInitializationOrderModuleList mov esi,[esi] 获取InInitializationOrderModuleList的第二项，esi既是LIST_ENTRY结构体地址，也是下一个节点指针的地址 mov esi,[esi+0x8] 模块信息，kernel32或者kernerbase模块基址 拿到了dll模块基址，通过基址和固定偏移来访问导出表，再通过导出表和定义好的字符串（函数名称）比较来获取模块指定函数——GetProcAddress，LoadLibraryA等等，到这就可以利用函数地址调用指定函数了 mov edx,esi 保存模块基址mov esi,[esi+0x3c] 获取NT头偏移lea esi,[edx+esi] 得到NT头地址mov esi,[esi+0x78] 得到导出表RVAlea esi,[edx+esi] 得到导出表VAmov edi,[esi+0x1c] 得到EAT的RVA（地址表）lea edi,[edi+edx] 得到EAT的RAmov [ebp-0x4],edi 保存在栈中mov edi,[esi+0x20] 得到ENT的RVA（名称表）lea edi,[edx+edi] 得到ENT的VAmov [ebp-0x8],edi 保存在栈中mov edi,[esi+0x24] 得到EOT的RVA（序号表）lea edi,[edx+edi] 得到EOT的VAmov [ebp-0xc],edi 保存在栈中 LDR_DATA_TABLE_ENTRY结构体是一个用来存放模块信息的结构体，它的定义如下： 1234567891011121314151617typedef struct _LDR_DATA_TABLE_ENTRY { PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks;//双向链表连接所有模块信息 PVOID Reserved2[2]; PVOID DllBase;//模块基址 PVOID EntryPoint;//模块入口点 PVOID Reserved3; UNICODE_STRING FullDllName;//模块完整名称 BYTE Reserved4[8]; PVOID Reserved5[3]; union { ULONG CheckSum; PVOID Reserved6; }; ULONG TimeDateStamp;} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 其中，Reserved1，Reserved2，Reserved3，Reserved4，Reserved5和Reserved6都是保留供操作系统内部使用的字段，不对外公开。DllBase是模块的基址，EntryPoint是模块的入口点，FullDllName是模块的完整名称，CheckSum是模块的校验和，TimeDateStamp是模块的时间戳。InMemoryOrderLinks是一个双向链表节点，它用来将所有的模块信息连接起来。 通过导出表kernel32.dll获得其中的“LoadLibraryA” 和 “GetProAddress” 9. 增加区段头向PE文件中植入代码ShellCode：–执行打印helloworld的代码$$“\\x60\\x8B\\xEC\\x6A\\x00\\x68\\x72\\x6C\\x64\\x21\\x68\\x6F\\x20\\x77\\x6F\\x68\\x68\\x65\\x6C\\x6C\\x68\\x73\\x73\\x00\\x00\\x68\\x64\\x64\\x72\\x65\\x68\\x72\\x6F\\x63\\x41\\x68\\x47\\x65\\x74\\x50\\x6A\\x00\\x68\\x61\\x72\\x79\\x41\\x68\\x4C\\x69\\x62\\x72\\x68\\x4C\\x6F\\x61\\x64\\x8B\\xCC\\x51\\xE8\\x8F\\x00\\x00\\x00\\x8B\\xE5\\x61\\xE9\\xF7\\x70\\xFB\\xFF\\xC3\\x55\\x8B\\xEC\\x83\\xEC\\x20\\x56\\x64\\x8B\\x35\\x30\\x00\\x00\\x00\\x8B\\x76\\x0C\\x8B\\x76\\x1C\\x8B\\x36\\x8B\\x76\\x08\\x8B\\xC6\\x5E\\x8B\\xE5\\x5D\\xC3\\x55\\x8B\\xEC\\x83\\xEC\\x20\\x8B\\x55\\x08\\x8B\\x72\\x3C\\x8D\\x34\\x16\\x8B\\x76\\x78\\x8D\\x34\\x32\\x8B\\x7E\\x1C\\x8D\\x3C\\x17\\x89\\x7D\\xFC\\x8B\\x7E\\x20\\x8D\\x3C\\x17\\x89\\x7D\\xF8\\x8B\\x7E\\x24\\x8D\\x3C\\x17\\x89\\x7D\\xF4\\x33\\xC0\\xEB\\x01\\x40\\x8B\\x75\\xF8\\x8B\\x34\\x86\\x8D\\x34\\x16\\x8B\\x7D\\x0C\\x8B\\x4D\\x10\\xF3\\xA6\\x8B\\x75\\xF4\\x75\\xE9\\x8B\\x75\\xF4\\x33\\xFF\\x66\\x8B\\x3C\\x46\\x8B\\x55\\xFC\\x8B\\x34\\xBA\\x8B\\x55\\x08\\x8D\\x04\\x16\\x8B\\xE5\\x5D\\xC2\\x0C\\x00\\x55\\x8B\\xEC\\x83\\xEC\\x10\\xE8\\x6F\\xFF\\xFF\\xFF\\x89\\x45\\xFC\\x8D\\x4D\\x0C\\x6A\\x0C\\x51\\x50\\xE8\\x80\\xFF\\xFF\\xFF\\x89\\x45\\xF8\\x6A\\x0E\\x8D\\x4D\\x1C\\x51\\xFF\\x75\\xFC\\xE8\\x6F\\xFF\\xFF\\xFF\\x89\\x45\\xF4\\x68\\x6C\\x6C\\x00\\x00\\x68\\x72\\x74\\x2E\\x64\\x68\\x6D\\x73\\x76\\x63\\x36\\x8D\\x4D\\xE4\\x51\\xFF\\x55\\xF8\\x68\\x74\\x66\\x00\\x00\\x68\\x70\\x72\\x69\\x6E\\x8D\\x4D\\xDC\\x51\\x50\\xFF\\x55\\xF4\\x8D\\x4D\\x2C\\x51\\xFF\\xD0\\x8B\\xE5\\x5D\\xC3”$$ 在文件末尾增加N字节给自己的代码提供空间 向最后一个区段后添加一个和text属性相同的区段 在union misc属性下填入N 在VirtualAddress属性下填入M M = VirtualAddress(上一个区段)+内存对齐值*（max(SizeOfRawData,VirtualSize)/内存对齐值) 在SizeOfRawData属性下填入N 在PointerToRawData属性下填入X X = SizeOfRawData(上一个区段)+PointerToRawData(上一个区段) 在文件头的区段数量属性上加一 在可选文件头的SizeOfImage属性上加N、 文件末尾填入ShellCode 修改OEP 附录，收集常见段的含义rdata段 rdata段是PE文件中的一个区段，它存储了程序用到的资源数据，如图标、字符串、位图等1。rdata段也可以存储一些只读的常量数据，如函数名、类名、导入表等2。 rdata段是可选的，不是所有的PE文件都有它。如果有rdata段，它通常位于text段和data段之间3。rdata段的属性是只读的，不能被修改4。 bss段 bss段是PE文件中的一个区段，它存储了程序中未初始化或初始化为零的全局变量和静态局部变量1。bss段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段后面2。当这个内存区进入程序的地址空间后全部清零，包含data和bss段的整个区段此时通常称为数据区2。 bss段是可选的，不是所有的PE文件都有它。如果有bss段，它通常位于text段和data段之间3。bss段的属性是只读的，不能被修改4。","link":"/2023/05/23/PE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"},{"title":"2022腾讯游戏安全PC初赛","text":"初赛题这里有一个画了flag的小程序，可好像出了点问题，flag丢失了，需要把它找回来。 题目： 找回flag样例： 要求 1、不得直接patch系统组件实现绘制（如：直接编写D3D代码绘制flag），只能对题目自身代码进行修改或调用。 2、找回的flag需要和预期图案（包括颜色）一致，如果绘制结果存在偏差会扣除一定分数。 3、赛后需要提交找回flag的截图和解题代码或文档进行评分。 DIE查壳,PE64位无壳,先IDA静态分析看一下 定位到这个函数 该函数先是加载了ntdll系统模块,再进行拼接字符串获取该模块ZwAllocateVirtualMemory函数地址 12345678NTSTATUS ZwAllocateVirtualMemory( HANDLE ProcessHandle, // 要分配内存的进程的句柄 PVOID *BaseAddress, // 指向一个变量的指针，该变量接收分配的内存的基地址 ULONG ZeroBits, // 指定返回的基地址中的高位必须为零的位数，用于对齐内存 PULONG AllocationSize, // 指向一个变量，指定要分配的内存大小 ULONG AllocationType, // 指定内存分配的类型，例如 MEM_COMMIT（提交内存）或 MEM_RESERVE（保留内存） ULONG Protect // 指定内存的保护属性，例如 PAGE_READWRITE（可读写）); 接着往下看 先是利用ZwAllocateVirtualMemory开辟了一块0x2BF9可读可写的地址空间,随后在该地址空间填入数据,最后再对地址空间部分数据进行了修改,qword_140008318可能是一个函数地址,在最后调用了这个函数,然后等待一段时间就释放了这个地址空间,所以绘画逻辑应该是在这个函数里,绘画完之后展现一段时间后消失和运行效果相同 所以主要逻辑应该是在qword_140008318函数里,x64dbg调试看一下,定位到qword_140008318赋值语句,00000001400011FE地址处下断点 100000001400011FE | 48:8905 13710000 | mov qword ptr ds:[140008318],rax | 进入rax发现确实是一个函数地址 再看一下修改部分的数据代表到底什么意思 1234500000001400011FE | 48:8905 13710000 | mov qword ptr ds:[140008318],rax |0000000140001205 | C783 6C060000 81250000 | mov dword ptr ds:[rbx+66C],2581 | rbx+66C:L&quot;▁&quot;000000014000120F | C783 49040000 B40E0000 | mov dword ptr ds:[rbx+449],EB4 |0000000140001219 | C783 00060000 01130000 | mov dword ptr ds:[rbx+600],1301 |0000000140001223 | C605 EA700000 01 | mov byte ptr ds:[140008314],1 | 分别定位到rbx对应的偏移处找不同 第一处 mov dword ptr ds:[rbx+66C],2581 1234567000000000D1A0666 | 48:8BD9 | mov rbx,rcx |000000000D1A0669 | 48:8B05 90190000 | mov rax,qword ptr ds:[D1A2000] |000000000D1A0670 | 48:8945 C8 | mov qword ptr ss:[rbp-38],rax |;修改后000000000D1A0666 | 48:8BD9 | mov rbx,rcx |000000000D1A0669 | 48:8B05 81250000 | mov rax,qword ptr ds:[&lt;&amp;D3DCompile&gt;] |000000000D1A0670 | 48:8945 C8 | mov qword ptr ss:[rbp-38],rax | 第二处 mov dword ptr ds:[rbx+449],EB4 1234567000000000D1A0442 | 4C:8B65 70 | mov r12,qword ptr ss:[rbp+70] |000000000D1A0446 | 48:8D05 F32B0000 | lea rax,qword ptr ds:[D1A3040] |000000000D1A044D | 4C:8B6D 68 | mov r13,qword ptr ss:[rbp+68] |;修改后000000000D190442 | 4C:8B65 70 | mov r12,qword ptr ss:[rbp+70] |000000000D190446 | 48:8D05 B40E0000 | lea rax,qword ptr ds:[D191301] |000000000D19044D | 4C:8B6D 68 | mov r13,qword ptr ss:[rbp+68] | 第三处 mov dword ptr ds:[rbx+600],1301 1234567000000000D1A05FD | 48:81FE 8F050000 | cmp rsi,58F |000000000D1A0604 | 0F82 A6FEFFFF | jb D1A04B0 |000000000D1A060A | 48:8B9C24 D0000000 | mov rbx,qword ptr ss:[rsp+D0] |;修改后000000000D1A05FD | 48:81FE 01130000 | cmp rsi,1301 |000000000D1A0604 | 0F82 A6FEFFFF | jb D1A04B0 |000000000D1A060A | 48:8B9C24 D0000000 | mov rbx,qword ptr ss:[rsp+D0] | 第一处和第二处nop掉直接程序出现异常 第三处nop掉发现会对绘画效果产生影响,这里少了五个方块, 所以[rbx+600]处附近会可能有绘画逻辑,运行到附近看看 分析这个函数,这里的rsi应该是一个数组的索引值,通过数组的值是否等于7进行判断,应该是将有效值和无效值进行区分,然后遍历了整个数组,进行了多次循环操作 那有效值在哪呢,我们主要找的绘画的浮点数位置保存在哪?D3D开发的经验不多,我就从一个个可能的函数的参数入手 看看是否能直接通过传参获取位置数组,这个函数里只有一个函数D190000 运行到该函数,观察函数传参窗口 显然没有这么容易,那还有可能在这个函数的母函数或者子函数的函数里 通过堆栈回溯找到母函数 这个rax是之前分析过了的函数地址,所以这个函数就是位置数组的出处了 进入分析 调用了一堆系统函数,并没有明显传参,也没有浮点数处理的汇编指令,这些略过分析,继续看 这里传入了两个浮点数,一个1920,一个1080,分辨率大小? 应该是绘画的初始化操作,继续分析找浮点数数组 这里有个缓冲区,存储了HLSL语言编写的一段顶点着色器和像素着色器的代码,进行图形渲染步骤,然后再调用了一些D3D函数 12345678910111213141516171819202122232425262728293031323334353637// 定义常量缓冲区cbuffer ConstantBuffer : register(b0){ matrix World; // 世界矩阵 matrix View; // 视图矩阵 matrix Projection; // 投影矩阵};// 定义顶点着色器的输出结构体struct VS_OUTPUT{ float4 Pos : SV_POSITION; // 顶点位置 float4 Color : COLOR0; // 顶点颜色};// 顶点着色器VS_OUTPUT VS(float4 Pos : POSITION, float4 Color : COLOR){ VS_OUTPUT output = (VS_OUTPUT)0; // 应用变换矩阵 output.Pos = mul(Pos, World); output.Pos = mul(output.Pos, View); output.Pos = mul(output.Pos, Projection); // 传递颜色 output.Color = Color; return output;}// 像素着色器float4 PS(VS_OUTPUT input) : SV_Target{ // 直接返回输入颜色 return input.Color;} 下面还有一个 123456789101112131415161718192021222324252627// 定义顶点着色器的输出结构体struct VSOut{ float4 Col : COLOR; // 顶点颜色 float4 Pos : SV_POSITION; // 顶点位置};// 顶点着色器VSOut VS(float4 Col : COLOR, float4 Pos : POSITION){ VSOut Output; // 将输入位置赋值给输出位置 Output.Pos = Pos; // 将输入颜色赋值给输出颜色 Output.Col = Col; return Output;}// 像素着色器float4 PS(float4 Col : COLOR) : SV_TARGET{ // 直接返回输入的颜色作为像素颜色 return Col;} 两个不同的着色器设计,是否对应了一个flag图形和原始图形两种图形不同的着色器呢? 但是最关键的位置数组我们还没找到,接着往下分析吧 这个函数内部还有一个用户层函数,进入分析 发现这个函数内部就是刚刚回溯开始的函数,那就直接进入该函数的子函数分析 一堆浮点数处理的汇编指令,好像还进行了加密解密操作,所以这里应该就是浮点数数组的出处了吧 跳过这些计算浮点数的指令,直接找到赋值语句并定位位置数组的首地址 这里分析发现,rcx即为数组首地址,继续分析,后面就是继续调用D3D函数,但是我并没有发现数组怎么传进去的,只是找到可能的位置数组,这个函数运行到返回只提供了0x70大小的浮点数数组,但是我们在之前分析过了,这个函数会循环运行,循环运行完后导出这些浮点数.得到1340个浮点数,到这里我有点怀疑这个数组的真实性了,不应该有这么长的数据的,总共方块数是31+11=42个,点数就是42*4=168个点,就算是三维坐标也不超过这么多数据,但是我还是在python进行了一个绘制,这里是python绘制代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350import structimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfloat_values = [ 71.2234, 73.5287, 0, 1, 1, 0, 1, 71.062, 73.5287, 0, 1, 1, 0, 1, 71.2234, 73.8157, 0, 1, 1, 0, 1, 71.062, 73.8157, 0, 1, 1, 0, 1, 0, 0, 0, 0,0.0526041, 2.7213, 0, 1, 1, 0, 1, 0.103646, 2.7213, 0, 1, 1, 0, 1, 0.0526041, 2.63056, 0, 1, 1, 0, 1, 0.103646, 2.63056, 0, 1, 1, 0, 1, 0, 0, 0, 0, -95.9422, -93.3991, 0, 1, 1, 0, 1, -95.938, -93.3991, 0, 1, 1, 0, 1, -95.9422, -93.4065, 0, 1, 1, 0, 1, -95.938, -93.4065, 0, 1, 1, 0, 1, 0, 0, 0, 0, -228.747, -227.782, 0, 1, 1, 0, 1, -228.896, -227.782, 0, 1, 1, 0, 1, -228.747, -227.518, 0, 1, 1, 0, 1, -228.896, -227.518, 0, 1, 1, 0, 1, 0, 0, 0, 0, -1.98906, 1.38796, 0, 1, 1, 0, 1, -1.93802, 1.38796, 0, 1, 1, 0, 1, -1.98906, 1.29722, 0, 1, 1, 0, 1, -1.93802, 1.29722, 0, 1, 1, 0, 1, 0, 0, 0, 0, -58.0307, -56.5009, 0, 1, 1, 0, 1, -57.8964, -56.5009, 0, 1, 1, 0, 1, -58.0307, -56.7398, 0, 1, 1, 0, 1, -57.8964, -56.7398, 0, 1, 1, 0, 1, 0, 0, 0, 0, -1.92656, 1.49907, 0, 1, 1, 0, 1, -1.87552, 1.49907, 0, 1, 1, 0, 1, -1.92656, 1.40833, 0, 1, 1, 0, 1, -1.87552, 1.40833, 0, 1, 1, 0, 1, 0, 0, 0, 0, -125.702, -123.716, 0, 1, 1, 0, 1, -125.771, -123.716, 0, 1, 1, 0, 1, -125.702, -123.592, 0, 1, 1, 0, 1, -125.771, -123.592, 0, 1, 1, 0, 1, 0, 0, 0, 0,-0.801563, 1.57315, 0, 1, 1, 0, 1, -0.750521, 1.57315, 0, 1, 1, 0, 1, -0.801563, 1.48241, 0, 1, 1, 0, 1, -0.750521, 1.48241, 0, 1, 1, 0, 1, 0, 0, 0, 0, -141.003, -138.069, 0, 1, 1, 0, 1, -140.834, -138.069, 0, 1, 1, 0, 1, -141.003, -138.369, 0, 1, 1, 0, 1, -140.834, -138.369, 0, 1, 1, 0, 1, 0, 0, 0, 0, -30.8589, -28.325, 0, 1, 1, 0, 1, -30.813, -28.325, 0, 1, 1, 0, 1, -30.8589, -28.4065, 0, 1, 1, 0, 1, -30.813, -28.4065, 0, 1, 1, 0, 1, 0, 0, 0, 0,-0.323438, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.271354, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.323438, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, -0.271354, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.385938, 0.797222, 0, 0.176471, 0.866667, 0.905882, 1, -0.333854, 0.797222, 0, 0.176471, 0.866667, 0.905882, 1, -0.385938, 0.70463, 0, 0.176471, 0.866667, 0.905882, 1, -0.333854, 0.70463, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.448438, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, -0.396354, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, -0.448438, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, -0.396354, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.510938, 0.575, 0, 0.176471, 0.866667, 0.905882, 1, -0.458854, 0.575, 0, 0.176471, 0.866667, 0.905882, 1, -0.510938, 0.482407, 0, 0.176471, 0.866667, 0.905882, 1, -0.458854, 0.482407, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.573438, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.521354, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.573438, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, -0.521354, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.510938, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.458854, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.510938, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, -0.458854, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.448438, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.396354, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.448438, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, -0.396354, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.260938, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.208854, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.260938, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, -0.208854, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.198437, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.146354, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.198437, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, -0.146354, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.135937, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.0838542, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.135937, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, -0.0838542, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.260938, 0.797222, 0, 0.176471, 0.866667, 0.905882, 1, -0.208854, 0.797222, 0, 0.176471, 0.866667, 0.905882, 1, -0.260938, 0.70463, 0, 0.176471, 0.866667, 0.905882, 1, -0.208854, 0.70463, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.198437, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, -0.146354, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, -0.198437, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, -0.146354, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,-0.135937, 0.575, 0, 0.176471, 0.866667, 0.905882, 1, -0.0838542, 0.575, 0, 0.176471, 0.866667, 0.905882, 1, -0.135937, 0.482407, 0, 0.176471, 0.866667, 0.905882, 1, -0.0838542, 0.482407, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,0.0734375, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.0213542, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.0734375, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, -0.0213542, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,0.0109375, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.0411458, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, -0.0109375, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0.0411458, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,0.0515625, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.103646, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.0515625, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0.103646, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.114063, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.166146, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.114063, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0.166146, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,0.0109375, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, 0.0411458, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, -0.0109375, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0.0411458, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,0.0515625, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, 0.103646, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, 0.0515625, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0.103646, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.114063, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, 0.166146, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, 0.114063, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0.166146, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.176563, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, 0.228646, 0.908333, 0, 0.176471, 0.866667, 0.905882, 1, 0.176563, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0.228646, 0.815741, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0,0.0515625, 0.797222, 0, 0.176471, 0.866667, 0.905882, 1, 0.103646, 0.797222, 0, 0.176471, 0.866667, 0.905882, 1, 0.0515625, 0.70463, 0, 0.176471, 0.866667, 0.905882, 1, 0.103646, 0.70463, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.114063, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.166146, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.114063, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0.166146, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.176563, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.228646, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.176563, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0.228646, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.239063, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.291146, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.239063, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0.291146, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.301562, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.353646, 0.686111, 0, 0.176471, 0.866667, 0.905882, 1, 0.301562, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0.353646, 0.593518, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.176563, 0.575, 0, 0.176471, 0.866667, 0.905882, 1, 0.228646, 0.575, 0, 0.176471, 0.866667, 0.905882, 1, 0.176563, 0.482407, 0, 0.176471, 0.866667, 0.905882, 1, 0.228646, 0.482407, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.239063, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.291146, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.239063, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0.291146, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.301562, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.353646, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.301562, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0.353646, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.364062, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.416146, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.364062, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0.416146, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0, 0, 0, 0, 0.426562, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.478646, 0.463889, 0, 0.176471, 0.866667, 0.905882, 1, 0.426562, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1, 0.478646, 0.371296, 0, 0.176471, 0.866667, 0.905882, 1]coordinates = [float_values[i:i+2] for i in range(0,len(float_values),2)]fig = plt.figure()ax = fig.add_subplot(111)x_values = [x for x, _ in coordinates]y_values = [y for _, y in coordinates]ax.scatter(x_values, y_values)plt.show() 运行结果如图: 这里有一个密集位置,箭头指向应该是让我们放大看 确实出现了原图的形状,但是flag旗帜的点也嵌在其中,但是对比位置好像有点问题,而且点的数量也不够,还有一个问题就是为什么这些位置没有被实际展现出来 那我们先解决为什么没有展现出来的问题,根据之前的分析,这里的几个跳转语句可能是问题所在,这里类似一个switch语句,通过数组的索引和其中的值来决定下一步的运算,有加减和一些别的运算.有点类似虚拟机的opcode 这里汇编有点没分析出来啥意思,拖到ida里调试看看伪代码 dword_E3D1301应该就是opcode数组,然后v14应该是指八个寄存器,然后case4有点没看像是一种加解密运算,然后case5和case6是两个相同的函数,传参只有一个不同,0xFFFFFF00和0xFF2DDBE7,可能与rgb的十六进制值有关,上在线转换网站上看一下 应该就是flag的黄色和原图的蓝色了,但是为什么同一个函数,只是颜色不同,怎么会有不显示和显示的情况呢,不清楚,hook一下看一下调用的时候其他参数有什么区别 hook代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;detours.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)//addr = [140008318] - 0x650#define QWORDADDR 0x140008318#define OFFSET 0x650typedef __int64 (*funptr)(int, int, int, int, int, __int64, __int64, __int64, __int64, __int64);INT64 func;__int64 __fastcall funcHook( int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10){ FILE* f = fopen(&quot;C:\\\\Users\\\\15386\\\\Desktop\\\\out.txt&quot;, &quot;a+&quot;); char in[100]; sprintf(in,&quot;a1:0x%08x,a2:0x%08x,a3:0x%08x,a4:0x%08x,a5:0x%08x\\n&quot;, a1, a2, a3, a4, a5); fputs(in, f); fclose(f); funptr fpt; fpt = (funptr)func; fpt(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); return 0;}void Start_Hook(){ DetourRestoreAfterWith(); DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); INT64 qword_addr; if (!ReadProcessMemory(GetCurrentProcess(), (LPCVOID*)QWORDADDR, &amp;qword_addr, 8, NULL)) { FILE* f = fopen(&quot;C:\\\\Users\\\\15386\\\\Desktop\\\\out.txt&quot;, &quot;a+&quot;); fputs(&quot;error ReadProcessMemory\\n&quot;, f); fclose(f); return; } func = qword_addr - OFFSET; DetourAttach((PVOID*)&amp;func, funcHook);//msg DetourTransactionCommit();}void Exit_Hook(){ DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach((PVOID*)&amp;func, funcHook); DetourTransactionCommit();}BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: Start_Hook(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: Exit_Hook(); break; } return TRUE;} 得到前五个参数内容 123456789101112131415161718192021222324252627282930313233343536373839404142a1:0xfffffc4a,a2:0x00000032,a3:0xff1fa3ac,a4:0x00130bd0,a5:0xffffff00a1:0x00000032,a2:0xfffffe7a,a3:0x001bcd69,a4:0xffe8bcc5,a5:0xffffff00a1:0xfffffc4a,a2:0x000000aa,a3:0xff8eb263,a4:0x00d91997,a5:0xffffff00a1:0x00000032,a2:0x000000e6,a3:0x001cf400,a4:0x00e82b18,a5:0xffffff00a1:0xfffffc4a,a2:0xffffff2e,a3:0x00391faa,a4:0x006ee5d2,a5:0xffffff00a1:0x00000032,a2:0x0000015e,a3:0x000ebe72,a4:0x00d77de2,a5:0xffffff00a1:0xfffffc86,a2:0xfffffef2,a3:0x00071150,a4:0x0074fb28,a5:0xffffff00a1:0x000000aa,a2:0xfffffef2,a3:0xffda3e17,a4:0x00c42e8b,a5:0xffffff00a1:0xfffffcfe,a2:0x000000e6,a3:0x0034cf2b,a4:0xff321ecf,a5:0xffffff00a1:0x0000006e,a2:0xfffffe7a,a3:0xffa49c19,a4:0x00d9e5f1,a5:0xffffff00a1:0xfffffcc2,a2:0x000000aa,a3:0xffca5ee7,a4:0x00c42d8b,a5:0xffffff00a1:0x0000028a,a2:0x00000032,a3:0x00eabf17,a4:0x00a7e3ab,a5:0xff2ddbe7a1:0x0000024e,a2:0x0000006e,a3:0x00c42d8b,a4:0x00cb0f37,a5:0xff2ddbe7a1:0x00000212,a2:0x000000aa,a3:0x00d717af,a4:0x001f5b13,a5:0xff2ddbe7a1:0x000001d6,a2:0x000000e6,a3:0x00c460e9,a4:0x00e9ad55,a5:0xff2ddbe7a1:0x0000019a,a2:0x00000122,a3:0x00c7a989,a4:0x00b9fd35,a5:0xff2ddbe7a1:0x000001d6,a2:0x00000122,a3:0x00ab7100,a4:0x00646cf8,a5:0xff2ddbe7a1:0x00000212,a2:0x00000122,a3:0x00c409a9,a4:0x0031cd9d,a5:0xff2ddbe7a1:0x000002c6,a2:0x00000032,a3:0x00d77e8b,a4:0x002f2773,a5:0xff2ddbe7a1:0x00000302,a2:0x00000032,a3:0x00d9ad01,a4:0x00996535,a5:0xff2ddbe7a1:0x0000033e,a2:0x00000032,a3:0x0039e156,a4:0x00da4a26,a5:0xff2ddbe7a1:0x000002c6,a2:0x0000006e,a3:0x0013207c,a4:0x00346848,a5:0xff2ddbe7a1:0x00000302,a2:0x000000aa,a3:0x00c9140b,a4:0x000b5fa7,a5:0xff2ddbe7a1:0x0000033e,a2:0x000000e6,a3:0x0053071f,a4:0x00c7ab3b,a5:0xff2ddbe7a1:0x0000037a,a2:0x00000122,a3:0x00d71106,a4:0x00d6329a,a5:0xff2ddbe7a1:0x000003b6,a2:0x00000122,a3:0x00eb60a1,a4:0x00a58d79,a5:0xff2ddbe7a1:0x000003f2,a2:0x00000122,a3:0x00eb67cd,a4:0x00f5e9d9,a5:0xff2ddbe7a1:0x0000042e,a2:0x00000122,a3:0x00d71161,a4:0x000d7d31,a5:0xff2ddbe7a1:0x000003b6,a2:0x00000032,a3:0x00677611,a4:0x00659df9,a5:0xff2ddbe7a1:0x000003f2,a2:0x00000032,a3:0x0040173d,a4:0x00557919,a5:0xff2ddbe7a1:0x0000042e,a2:0x00000032,a3:0x00d77661,a4:0x003d9d01,a5:0xff2ddbe7a1:0x0000046a,a2:0x00000032,a3:0x00efff9a,a4:0x00ca2e06,a5:0xff2ddbe7a1:0x000003f2,a2:0x0000006e,a3:0x00c404eb,a4:0x00b7178b,a5:0xff2ddbe7a1:0x0000042e,a2:0x000000aa,a3:0x00d7c6ef,a4:0x008b6337,a5:0xff2ddbe7a1:0x0000046a,a2:0x000000aa,a3:0x00d7701f,a4:0x00677b0b,a5:0xff2ddbe7a1:0x000004a6,a2:0x000000aa,a3:0x00d71171,a4:0x00fd4d21,a5:0xff2ddbe7a1:0x000004e2,a2:0x000000aa,a3:0x003906ab,a4:0x000bbf27,a5:0xff2ddbe7a1:0x0000046a,a2:0x000000e6,a3:0x00096663,a4:0x00ef5f33,a5:0xff2ddbe7a1:0x000004a6,a2:0x00000122,a3:0x00732157,a4:0x00835b9f,a5:0xff2ddbe7a1:0x000004e2,a2:0x00000122,a3:0x00353730,a4:0x00383434,a5:0xff2ddbe7a1:0x0000051e,a2:0x00000122,a3:0x006257a9,a4:0x009555e9,a5:0xff2ddbe7a1:0x0000055a,a2:0x00000122,a3:0x00d777af,a4:0x00df5bd3,a5:0xff2ddbe7 可以看到蓝色调用了31次,黄色调用了11次,正好对应正方形块数,验证了猜测. 前面的四个参数在蓝色调用的时候基本都是正数,黄色调用的时候则总会出现一些负数的情况,所以可能就是在这四个参数出了问题让绘制出现了失败,在蓝色调用的前两个参数有一些相同的情况,比如说第二个参数0x00000032这个值,出现了8次,对应了一行的八个方块,0x0000006e则对应三个方块,应该就是指的y坐标,第一个参数则可能会是x坐标,知道了这个,我们就可以通过hook这个绘制函数通过正确传参就能实现绘制,但是正确的位置在哪呢?位置被错误的计算了,只能从虚拟机运行入手了,写个脚本跑一下运行流程 123456789101112131415161718192021222324252627282930313233343536opcode = [0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000004, 0x00000000, 0x00000003, 0x000003E8, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00524895, 0x00000002, 0x00000000, 0x00000003, 0x00000002, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000005, 0x00000000, 0x00000003, 0x000001F4, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x005A8E2C, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000004, 0x00000000, 0x00000003, 0x000003E8, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00985AD2, 0x00000002, 0x00000000, 0x00000003, 0x00000002, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00A9685D, 0x00000002, 0x00000000, 0x00000003, 0x00000002, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000004, 0x00000000, 0x00000003, 0x000003E8, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000005, 0x00000000, 0x00000003, 0x000001F4, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00785CEF, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x0000012C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00963EA7, 0x00000002, 0x00000000, 0x00000003, 0x00000002, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000004, 0x00000000, 0x00000003, 0x000003E8, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000005, 0x00000000, 0x00000003, 0x000001F4, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00465215, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000005, 0x00000000, 0x00000003, 0x000001F4, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00856DCE, 0x00000002, 0x00000000, 0x00000003, 0x00000002, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000004, 0x00000000, 0x00000003, 0x000003E8, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00758C6E, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000005, 0x00000000, 0x00000003, 0x000001F4, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x0098A6B4, 0x00000002, 0x00000000, 0x00000003, 0x00000002, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000004, 0x00000000, 0x00000003, 0x000003E8, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00856ECE, 0x00000002, 0x00000000, 0x00000003, 0x00000002, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000258, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00ABFC52, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00856ECE, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x009654EA, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x008523AC, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x0086EACC, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00EA3245, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000001, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00854AEC, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00963DCE, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x0098EE44, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x0078A213, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00526339, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x0088574E, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x0012445A, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00965243, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000012C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00AA23E4, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000168, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00AA2488, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000001A4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00965224, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000012C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x00000002, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00263554, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00015478, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00963524, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00AEBCDF, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x0000003C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x008547AE, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x009685AA, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x0096335A, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00965234, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000012C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x00000078, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x007845EE, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000B4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00482526, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00326212, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x0000012C, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x00747475, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x00000168, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x002314EC, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000002, 0x00000008, 0x00000000, 0x00000003, 0x000001A4, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x00000009, 0x00000000, 0x00000003, 0x000000F0, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000005, 0x00000002, 0x00000004, 0x00000000, 0x00000002, 0x00000005, 0x00000001, 0x00000004, 0x009634EA, 0x00000002, 0x00000000, 0x00000006, 0x00000002, 0x00000001, 0x00000007, 0x00000006, 0x00000007]key = 0x0AD00001Freg = [0,0,0,0,0,0,0,0,50,50]rip = 0while rip &lt; len(opcode): match opcode[rip]: case 0: print(f&quot;+++0 reg[0]={reg[0]},reg[1]={reg[1]},reg[0]={reg[0]+reg[1]}&quot;) reg[0] += reg[1] case 1: print(f&quot;---1 reg[0]={reg[0]},reg[1]={reg[1]},reg[0]={reg[0]-reg[1]}&quot;) reg[0] -= reg[1] case 2: v10 = opcode[rip+1] rip += 2 # print(v10) print(f&quot;===2 reg[{opcode[rip]}]=reg[{v10}],reg[{opcode[rip]}]={reg[opcode[rip]]},reg[{v10}]={reg[v10]}&quot;) reg[opcode[rip]] = reg[v10] case 3: v11 = opcode[rip+1] rip += 2 print(f&quot;===3 reg[{opcode[rip]}]={v11},reg[{opcode[rip]}]={reg[opcode[rip]]},reg[{v10}]={v11}&quot;) reg[opcode[rip]] = v11 case 4: rip += 1 v12 = reg[0] v13 = reg[0]*(reg[1]+1) reg[0] = key^opcode[rip] reg[1] = (reg[0] ^ (reg[1] + v12)) % 256 + (((reg[0] ^ (v12 * reg[1])) % 256 + (((reg[0] ^ (reg[1] + v13)) % 256) &lt;&lt; 8)) &lt;&lt; 8) print(f&quot;decrypt reg[0]={reg[0]},reg[1]={reg[1]}&quot;) case 5: print(f&quot;call-5 reg[4]={reg[4]},reg[5]={reg[5]},reg[6]={reg[6]},reg[7]={reg[7]}&quot;) case 6: print(f&quot;call-6 reg[4]={reg[4]},reg[5]={reg[5]},reg[6]={reg[6]},reg[7]={reg[7]}&quot;) rip += 1 运行结果部分: 123456789101112131415161718192021222324252627282930313233===2 reg[0]=reg[8],reg[0]=0,reg[8]=50===2 reg[4]=reg[0],reg[4]=0,reg[0]=50===2 reg[0]=reg[4],reg[0]=50,reg[4]=50===3 reg[1]=1000,reg[1]=0,reg[4]=1000---1 reg[0]=50,reg[1]=1000,reg[0]=-950===2 reg[4]=reg[0],reg[4]=50,reg[0]=-950===2 reg[0]=reg[9],reg[0]=-950,reg[9]=50===2 reg[5]=reg[0],reg[5]=0,reg[0]=50===2 reg[0]=reg[4],reg[0]=50,reg[4]=-950===2 reg[1]=reg[5],reg[1]=1000,reg[5]=50decrypt reg[0]=2907850890,reg[1]=8060662===2 reg[3]=reg[0],reg[3]=0,reg[0]=2907850890===2 reg[0]=reg[1],reg[0]=2907850890,reg[1]=8060662===2 reg[1]=reg[3],reg[1]=8060662,reg[3]=2907850890===2 reg[6]=reg[0],reg[6]=0,reg[0]=8060662===2 reg[7]=reg[1],reg[7]=0,reg[1]=2907850890call-5 reg[4]=-950,reg[5]=50,reg[6]=8060662,reg[7]=2907850890===2 reg[0]=reg[8],reg[0]=8060662,reg[8]=50===2 reg[4]=reg[0],reg[4]=-950,reg[0]=50===2 reg[0]=reg[9],reg[0]=50,reg[9]=50===3 reg[1]=60,reg[1]=2907850890,reg[9]=60+++0 reg[0]=50,reg[1]=60,reg[0]=110===2 reg[5]=reg[0],reg[5]=50,reg[0]=110===2 reg[0]=reg[5],reg[0]=110,reg[5]=110===3 reg[1]=500,reg[1]=60,reg[5]=500---1 reg[0]=110,reg[1]=500,reg[0]=-390===2 reg[5]=reg[0],reg[5]=110,reg[0]=-390===2 reg[0]=reg[4],reg[0]=-390,reg[4]=50===2 reg[1]=reg[5],reg[1]=500,reg[5]=-390decrypt reg[0]=2908393011,reg[1]=11790239===2 reg[6]=reg[0],reg[6]=8060662,reg[0]=2908393011===2 reg[7]=reg[1],reg[7]=2907850890,reg[1]=11790239call-5 reg[4]=50,reg[5]=-390,reg[6]=2908393011,reg[7]=11790239 基本都是在case1的时候减了一个大数,然后call的参数就出现负数,简单的加个if条件,将减的那一步选择性的跳过,如果结果为负数,那么就不执行减操作,改下程序得到的参数貌似正常了,得到的“正确“参数如下: 1234567891011reg[4]=50,reg[5]=50,reg[6]=10637038,reg[7]=2907850890reg[4]=50,reg[5]=110,reg[6]=2908393011,reg[7]=3100563reg[4]=50,reg[5]=170,reg[6]=14547217,reg[7]=2912443085reg[4]=50,reg[5]=230,reg[6]=4632154,reg[7]=2913560642reg[4]=50,reg[5]=290,reg[6]=2910346480,reg[7]=545956reg[4]=50,reg[5]=350,reg[6]=5563432,reg[7]=2912304824reg[4]=110,reg[5]=230,reg[6]=2907066890,reg[7]=2285150reg[4]=170,reg[5]=230,reg[6]=10317121,reg[7]=2911202769reg[4]=230,reg[5]=230,reg[6]=2910162033,reg[7]=120253reg[4]=110,reg[5]=110,reg[6]=9170807,reg[7]=2912462507reg[4]=170,reg[5]=170,reg[6]=15283589,reg[7]=2911203025 尝试hook绘制函数传入这些参数进行绘制看看结果,试了很久一直没有显示,连原图的都不显示了,最后对照了一下第三个和第四个参数发现和之前hook来的参数不同,应该是计算的时候C有溢出但是python没有,重新用C写一遍模拟虚拟机运行的脚本运行得到第三个参数和第四个参数数组 12int reg6[11] = { 0xf814b4,0x1bcd69,0x87a34b,0x1cf400,0x391faa,0xebe72,0x71150,0xc7371b,0x34cf2b,0xd1b52d,0xb36fdf};int reg7[11] = { 0x130bd0,0x7515c9,0xd91997,0xe82b18,0x520efe,0xd77de2,0x788404,0xc42e8b,0x5b8fe7,0xd9e5f1,0xc42d8b }; 注入测试 只显示了四个方块,嘶,怎么会少了7块呢,根据前两个参数的大概位置分析在第2,5,7,9次黄色函数调用处,对比一下他们的虚拟机运行情况 在这里看到了有些call调用的前将第三个和第四个参数分别调换了位置,刚好2,5,7,9没有调换!!! 所以根据这个再把错误的参数位置调换一下进行注入测试 HOOK代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;DWORD64 HOOKADDR1 = (long long)GetModuleHandleA(&quot;2022游戏安全技术竞赛初赛.exe&quot;) + 0X11E4; // MEMCPY函数DWORD64 HOOKADDR2 = 0;DWORD64 SHEELCODE = 0X0000001400027E2;DWORD64 SHEELCODE2 = 0X0000001400027C9;BYTE oldByte[12];typedef void (*myMemecpy)(void* dest, const void* src, size_t n);typedef __int64 (*funptr)(int, int, int, int, int, __int64, __int64, __int64, __int64, __int64);//HOOK绘制函数修改传参__int64 __fastcall drawHook( int a1, int a2, int a3, int a4, int a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10){ int reg4[11] = { 50,50,50,50,50,50,110,170,230,110,170 }; int reg5[11] = { 50,110,170,230,290,350,230,230,230,110,170 }; int reg6[11] = { 0xf814b4,0x1bcd69,0x87a34b,0x1cf400,0x391faa,0xebe72,0x71150,0xc7371b,0x34cf2b,0xd1b52d,0xb36fdf }; int reg7[11] = { 0x130bd0,0x7515c9,0xd91997,0xe82b18,0x520efe,0xd77de2,0x788404,0xc42e8b,0x5b8fe7,0xd9e5f1,0xc42d8b }; for (int i = 0; i &lt; 11; i++) { if (i == 1 || i == 4 || i == 6 || i == 8) { continue; } else { int tmp = reg6[i]; reg6[i] = reg7[i]; reg7[i] = tmp; } } funptr fpt; fpt = (funptr)(HOOKADDR2 - 0x5EE); if (a5 == 0xffffff00) { static int i = -1; i++; return fpt(reg4[i], reg5[i], reg6[i], reg7[i], a5, a6, a7, a8, a9, a10); } return fpt(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);}//第二处hook,hook绘制函数void installHook2(){ //00000001400027E2, 0000000009E50412 // //0000000009E605EE | E9 1FFEFFFF | jmp 9E60412 | BYTE shellCode[] = {0xE9, 0x1F, 0xFE, 0xFF, 0xFF }; DWORD lpflOldProtect = 0; VirtualProtect((void*)HOOKADDR2, sizeof(shellCode), PAGE_EXECUTE_READWRITE, &amp;lpflOldProtect); memcpy((void*)HOOKADDR2, shellCode, sizeof(shellCode)); /* 00000001400027E2 | 48:B8 A91148F6FF7F0000 | mov rax,testhook.7FFFF64811A9 | 00000001400027EC | FFD0 | call rax | 00000001400027EE | 48:B8 F305E60900000000 | mov rax,9E605F3 | 00000001400027F8 | FFE0 | jmp rax | */ BYTE shellCode2[] = { 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xE0 };; *(DWORD64*)&amp;shellCode2[2] = (DWORD64)drawHook; *(DWORD64*)&amp;shellCode2[14] = HOOKADDR2 + 0X5; VirtualProtect((void*)(SHEELCODE), sizeof(shellCode2), PAGE_EXECUTE_READWRITE, &amp;lpflOldProtect); memcpy((void*)(SHEELCODE), shellCode2, sizeof(shellCode2)); /*0000000009E60412 | 48:B8 E227004001000000 | mov rax,2022游戏安全技术竞赛初赛.1400027E2 | 0000000009E6041C | FFE0 | jmp rax |*/ BYTE shellCode3[] = {0x48, 0xB8, 0xE2, 0x27, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xE0 };; *(DWORD64*)&amp;shellCode3[2] = (DWORD64)SHEELCODE; VirtualProtect((void*)(HOOKADDR2 - 0x5EE + 0X412), sizeof(shellCode3), PAGE_EXECUTE_READWRITE, &amp;lpflOldProtect); memcpy((void*)(HOOKADDR2 - 0x5EE + 0X412), shellCode3, sizeof(shellCode3));}void* memcpyHook(void* dest, const void* src, size_t n){ HOOKADDR2 = (DWORD64)dest - 0x1301 + 0x5EE;//跟第一个参数偏移0x1301 installHook2(); return memcpy(dest, src, n);}//第一处hook,hook call memcpyvoid installHook1(){ //00000001400011E4 | E9 E0150000 | jmp 2022游戏安全技术竞赛初赛.1400027C9 | BYTE shellCode[] = {0xE9, 0xE0, 0x15, 0x00, 0x00 }; DWORD lpflOldProtect = 0; VirtualProtect((void*)HOOKADDR1, sizeof(shellCode), PAGE_EXECUTE_READWRITE, &amp;lpflOldProtect); memcpy((void*)HOOKADDR1, shellCode, sizeof(shellCode)); /*00000001400027C9 | 48:B8 111348F6FF7F0000 | mov rax,testhook.7FFFF6481311 | 00000001400027D3 | FFD0 | call rax | 00000001400027D5 | E9 0FEAFFFF | jmp 2022游戏安全技术竞赛初赛.1400011E9 |*/ BYTE shellCode2[] = {0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xE9, 0x0F, 0xEA, 0xFF, 0xFF }; *(DWORD64*)&amp;shellCode2[2] = (DWORD64)memcpyHook; VirtualProtect((void*)SHEELCODE2, sizeof(shellCode2), PAGE_EXECUTE_READWRITE,&amp;lpflOldProtect); memcpy((void*)SHEELCODE2, shellCode2, sizeof(shellCode2));}BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: installHook1(); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;}","link":"/2024/08/06/2022%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8PC%E5%88%9D%E8%B5%9B/"},{"title":"2023腾讯游戏安全PC初赛","text":"小红是一个PC客户端安全爱好者。有一天她发现一台机器上有一个未知的程序名为contest.exe，这个程序会在当前同个目录下的”contest.txt” 目录里每秒重复写入一次密文的信息。她想了解这个程序究竟写入了什么，并试试能否反过来控制这个程序按自己的意图工作。 评分标准: （1）在64位Windows10系统上运行contest.exe, 找到明文的信息，作为答案提交（1分）。 （2）编写程序，运行时修改尽量少的contest.exe内存，让contest.exe 由写入密文信息变为写入明文信息成功。（满分2分） （3）编写程序，运行时修改尽量少的contest.exe内存，让contest.exe 往入自行指定的不同的文件里写入明文信息成功。（满分3分） （4）文档编写，详细描述（1）-（3）解题过程，详述提供的解题程序的演示方法。做到清晰易懂，操作可以复现结果。（满2分） （5）提供（2）和（3）解题演示所用的源代码。要求编码工整风格优雅（1分）、注释详尽（1分）。 解题要求: （1）编写代码，通过注入任何dll或者shellcode或者跨进程修改内存的方式来patch contest.exe的内存，但shellcode不能调用任何系统API。 （2）不得删改contest.exe的文件本身。不得使用任何文件和磁盘相关手段（比如同名文件、设置文件权限占坑等方式）阻止或者破坏contest.exe的执行。 （3）此题编程中不可使用内核驱动程序。 （4）必须使用64位Win10系统解题。 分析程序DIE查壳发现是带了VMP的,发现可以拖到x64dbg里调试,因为运行的时候每秒都会向文件中写入字符串信息,所以可以猜测用到了哪些函数 Sleep函数 fwrite,fopen,createFile等文件操作函数 观察符号列表,找到contest.exe模块的导入函数 只找到了Sleep函数,猜测其他函数是通过loadLibraryA来间接使用,先在Sleep函数下断 确实断下来了,栈回溯找到父函数 在这个函数里调用了Sleep函数,现在就需要判断这个函数是不是直接存在于死循环体 因为按照猜测程序应该是有一个死循环体,然后在其中调用了Sleep函数,但是可能有多层函数调用需要多次栈回溯 就像这样的代码模型: 1234567891011121314void run(){ while(1) { fopen(````); fwrite(````); fclose(```); A(); }}void A(){ Sleep(```);} 这里通过运行到返回发现程序不停止,说明这个函数已经直接存在于死循环体,那么其他关键文件操作函数也应该存在于这个函数的附近, 对附近所有Call指令下断,清空txt文件,根据回显发现在这两个call之间实现了文件写入 继续调试发现了是在00007FF7E9D2DA37这个函数内实现了文件内容写入,但是不是每次调用这个函数都会向文件写入,而是每两次调用写入一次文件,暂时不知道为什么,步进分析该函数 到了00007FF7E9D2BCB0这个函数,继续对这个函数内所有call指令下断点分析争取找到具体文件操作函数 下完断点,总共有十多个call指令,依次运行分析 第一个call指令运行完的返回值是一个字符串ZyAhZyk4YSgzfS4gZyA7,猜测是明文或者某个加解密的密钥,继续运行分析 第二个call指令的函数传参的第一个参数rcx也是一个字符串catchmeifyoucan,emm,这个很明显应该就是明文了,步进函数分析这个rbx函数是个什么东西 找到了一个疑似base64加密的表QRSTUVWXYZabcdefABCDEFGHIJKLMNOPwxyz0123456789+/ghijklmnopqrstuv,试着将明文和这个表进行一个base64变表加密 cyberchef跑一下一下发现确实是密文,那明文就确定了,就是catchmeifyoucan,继续分析 第四个call函数的第一个传参RCX是CreateFileA地址,那就应该是创建文件了,题目要求向不同的文件里写入明文信息,那么只要确定文件名所在的参数位置就可以了,观察传参 第6个参数是contest.txt,应该就是文件名地址了,继续分析 第七个call指令运行完文件就被写入了,然后rcx也是WriteFileA函数地址,所以这里面应该就是一个写入文件,第七个参数是写入字符串内容,根据搜索找到WriteFileA函数定义 1234567BOOL WriteFile( HANDLE hFile, // 需要写入数据的文件句柄 LPCVOID lpBuffer, // 指向要写入的数据缓冲区的指针 DWORD nNumberOfBytesToWrite, // 要写入的字节数 LPDWORD lpNumberOfBytesWritten, // 用于接收实际写入的字节数 LPOVERLAPPED lpOverlapped // 指向OVERLAPPED结构的指针，用于异步操作); 根据传参顺序和写入的字节数是DWORD类型推断第八个参数的低四字节可能是要写入的字节数,这里对应0x14 有了这些我们就可以初步编写代码,思路就是尝试hook创建文件和写入文件的两个call,传入需要的参数即可 这里最开始是想通过VirtualProtect函数和写入ShellCode来实现hook,但是在调试的时候发现了报错 显示没有写入的权限,那只能先加载dll进去调试一番 根据调试结果发现,在virtualProtect时返回了NULL,步进分析 到这发现了一个奇怪的jmp指令,和附近的其他函数形成鲜明对比,猜测作者在这动了手脚,hook了ZwProtectVirtualMemory函数,根据附近汇编代码取消钩子后运行,成功跑出结果 代码实现可以通过注入器UnHook ZwProtectVirtualMemory函数,然后再进行注入 注入器代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt;#include &lt;stdio.h&gt;#include &lt;tchar.h&gt;wchar_t dllPath[] = L&quot;C:\\\\Users\\\\15386\\\\Desktop\\\\腾旭游戏安全竞赛赛题\\\\23年第一轮\\\\wp\\\\Tencent2023.dll&quot;;wchar_t exeName[] = L&quot;contest.exe&quot;;DWORD64 UnHookAddr = 0x00007FFBC1F90990; // ZwProtectVirtualMemory地址BYTE UnHookShellCode[] = {0x4C, 0x8B, 0xD1, 0xB8, 0x50, 0x00, 0x00, 0x00, 0xF6, 0x04, 0x25, 0x08, 0x03, 0xFE, 0x7F, 0x01, 0x75, 0x03, 0x0F, 0x05, 0xC3, 0xCD, 0x2E, 0xC3};/* Unhook还原ZwProtectVirtualMemory00007FFBC1F90990 &lt; | 4C:8BD1 | mov r10,rcx |00007FFBC1F90993 | B8 50000000 | mov eax,50 | 50:'P'00007FFBC1F90998 | F60425 0803FE7F 01 | test byte ptr ds:[7FFE0308],1 |00007FFBC1F909A0 | 75 03 | jne ntdll.7FFBC1F909A5 |00007FFBC1F909A2 | 0F05 | syscall |00007FFBC1F909A4 | C3 | ret |00007FFBC1F909A5 | CD 2E | int 2E |00007FFBC1F909A7 | C3 | ret |*/BOOL InjectDll(DWORD dwPID, wchar_t* szDllPath){ HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) { printf(&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; } //UnHook DWORD oldProtect = 0; if (!VirtualProtectEx(hProcess, (LPVOID)UnHookAddr, sizeof(UnHookShellCode), PAGE_EXECUTE_READWRITE, &amp;oldProtect)) { printf(&quot;VirtualProtectEx failed!!! [%d]\\n&quot;, GetLastError()); return FALSE; } if (!WriteProcessMemory(hProcess, (LPVOID)UnHookAddr, UnHookShellCode, sizeof(UnHookShellCode), 0)) { printf(&quot;UnHook failed!!! [%d]\\n&quot;, GetLastError()); return FALSE; } printf(&quot;UnHook virtualProtect success!!!\\n&quot;); if (!(pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE))) { printf(&quot;VirtualAllocEx %d falied!!! [%d]\\n&quot;, hProcess,GetLastError()); return FALSE; } if (!WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL)) { printf(&quot;WriteProcess %d Memory fail [%d]\\n&quot;,hProcess, GetLastError()); return FALSE; } hMod = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;}DWORD ProcessFind(wchar_t* Exename){ HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (!hProcess) { return FALSE; } PROCESSENTRY32 info; info.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hProcess, &amp;info)) { return FALSE; } while (true) { if (memcmp(info.szExeFile, Exename, _tcslen(Exename)) == 0) { return info.th32ProcessID; } if (!Process32Next(hProcess, &amp;info)) { return FALSE; } } return FALSE;}int main(){ DWORD64 pid = ProcessFind(exeName); if (InjectDll(pid, dllPath)) { printf(&quot;InjectDll success\\n&quot;); } system(&quot;pause&quot;);} dll代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;DWORD64 HookAddrA = (DWORD64)GetModuleHandleA(&quot;contest.exe&quot;) + 0xCB90; //创建文件处,call rax,add rsp,3CDWORD64 funcA = (DWORD64)GetModuleHandleA(&quot;contest.exe&quot;) + 0xD6A0; // call rax的rax对应地址,需要hook的函数DWORD64 ShellCodeAddrA = (DWORD64)GetModuleHandleA(&quot;contest.exe&quot;) + 0x26B16;BYTE HookShellCodeA[] = { 0xE9,0x81,0x9F,0x01,0x00,0x90 };/* call rax 段代码00007FF7E9D2CB8D | 45:31C9 | xor r9d,r9d |00007FF7E9D2CB90 | E9 819F0100 | jmp contest.7FF7E9D46B16 | 创建文件00007FF7E9D2CB95 | 90 | nop |00007FF7E9D2CB96 | 48:8B45 A0 | mov rax,qword ptr ss:[rbp-60] |*/BYTE ShellCodeA[] = {0x48, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD6, 0x48, 0x83, 0xC4, 0x60, 0xE9, 0x6B, 0x60, 0xFE, 0xFF};/* shellCodeA00007FF7E9D46B16 | 48:BE 13117A9FFB7F0000 | mov rsi,tencent2023.7FFB9F7A1113 |00007FF7E9D46B20 | FFD6 | call rsi |00007FF7E9D46B22 | 48:83C4 60 | add rsp,60 |00007FF7E9D46B26 | E9 6B60FEFF | jmp contest.7FF7E9D2CB96 |00007FF7E9D46B2B | CC | int3 |*/typedef void (*funAptr)(DWORD64 RCX, DWORD64 RDX, DWORD64 R8, DWORD64 R9,DWORD64 Par5, DWORD64 Par6, DWORD64 Par7, DWORD64 Par8,DWORD64 Par9, DWORD64 Par10, DWORD64 Par11);DWORD64 HookAddrB = (DWORD64)GetModuleHandleA(&quot;contest.exe&quot;) + 0xCEFA;DWORD64 ShellCodeAddrB = (DWORD64)GetModuleHandleA(&quot;contest.exe&quot;) + 0x26BC0;BYTE HookShellCodeB[] = {0xE9, 0xC1, 0x9C, 0x01, 0x00, 0x90};/*call rax 段代码00007FF7E9D2CEF7 | 45:31C9 | xor r9d,r9d |00007FF7E9D2CEFA | E9 C19C0100 | jmp contest.7FF7E9D46BC0 | 写入文件00007FF7E9D2CEFF | 90 | nop |00007FF7E9D2CF00 | 48:8B45 A0 | mov rax,qword ptr ss:[rbp-60] |*/BYTE ShellCodeB[] = {0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x50, 0xE9, 0x2B, 0x63, 0xFE, 0xFF};/* shellCodeB00007FF7E9D46BC0 | 48:B8 AD127A9FFB7F0000 | mov rax,tencent2023.7FFB9F7A12AD |00007FF7E9D46BCA | FFD0 | call rax |00007FF7E9D46BCC | 48:83C4 50 | add rsp,50 |00007FF7E9D46BD0 | E9 2B63FEFF | jmp contest.7FF7E9D2CF00 |00007FF7E9D46BD5 | CC | int3 |*/DWORD64 funcB = (DWORD64)GetModuleHandleA(&quot;contest.exe&quot;) + 0xD6A0; // call rax的rax对应地址,需要hook的函数typedef void (*funBptr)( DWORD64 RCX, DWORD64 RDX, DWORD64 R8, DWORD64 R9, DWORD64 Par5, DWORD64 Par6, DWORD64 Par7, DWORD64 Par8, DWORD64 Par9, DWORD64 Par10,DWORD64 Par11, DWORD64 Par12, DWORD64 Par13, DWORD64 Par14);DWORD oldProtect = 0;char plainText[] = &quot;catchmeifyoucan&quot;;char fileName[] = &quot;myContest.txt&quot;;void __fastcall HookFuncA( DWORD64 RCX,DWORD64 RDX,DWORD64 R8,DWORD64 R9, DWORD64 Par5,DWORD64 Par6,DWORD64 Par7,DWORD64 Par8, DWORD64 Par9,DWORD64 Par10,DWORD64 Par11){ //第6个参数对应文件名地址 memcpy((void*)Par6, fileName, sizeof(fileName)); funAptr ptr = (funAptr)funcA; return ptr(RCX, RDX, R8, R9, Par5, Par6, Par7, Par8, Par9, Par10, Par11);}void __fastcall HookFuncB( DWORD64 RCX, DWORD64 RDX, DWORD64 R8, DWORD64 R9, DWORD64 Par5, DWORD64 Par6, DWORD64 Par7, DWORD64 Par8, DWORD64 Par9, DWORD64 Par10, DWORD64 Par11,DWORD64 Par12, DWORD64 Par13,DWORD64 Par14){ //第7个参数对应明文地址 //第8个参数的低四字节对应写入字节数 Par8 = (Par8 &amp; 0xFFFFFFFFFFFFFF00) | (strlen(plainText)); memcpy((void*)Par7, plainText, sizeof(plainText)); funBptr ptr = (funBptr)funcB; return ptr(RCX, RDX, R8, R9, Par5, Par6, Par7, Par8, Par9, Par10, Par11,Par12,Par13,Par14);}void InstallHookA(){ VirtualProtect((LPVOID)HookAddrA, sizeof(HookShellCodeA), PAGE_EXECUTE_READWRITE, &amp;oldProtect); memcpy((void*)HookAddrA, HookShellCodeA, sizeof(HookShellCodeA)); VirtualProtect((LPVOID)ShellCodeAddrA, sizeof(ShellCodeA), PAGE_EXECUTE_READWRITE, &amp;oldProtect); *(DWORD64*)&amp;ShellCodeA[2] = (DWORD64)HookFuncA; memcpy((void*)ShellCodeAddrA, ShellCodeA, sizeof(ShellCodeA));}void InstallHookB(){ VirtualProtect((LPVOID)HookAddrB, sizeof(HookShellCodeB), PAGE_EXECUTE_READWRITE, &amp;oldProtect); memcpy((void*)HookAddrB, HookShellCodeB, sizeof(HookShellCodeB)); VirtualProtect((LPVOID)ShellCodeAddrB, sizeof(ShellCodeB), PAGE_EXECUTE_READWRITE, &amp;oldProtect); *(DWORD64*)&amp;ShellCodeB[2] = (DWORD64)HookFuncB; memcpy((void*)ShellCodeAddrB, ShellCodeB, sizeof(ShellCodeB));}BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: InstallHookB(); InstallHookA(); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;}","link":"/2024/07/28/2023%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8PC%E5%88%9D%E8%B5%9B/"},{"title":"2023腾讯游戏安全PC决赛","text":"最近一直在做往年腾讯游戏安全PC端的复现，但是2023年决赛的题做到第三问就开始有点做不动了，想在网上找找题解但是并没有找到，于是便想分享一下自己的解题经验和第三问的思路。鉴于知识的局限性，文中可能存在疏漏或不足之处，如果发现任何错误或不准确之处，请不吝赐教。 题目 （一）解题过程第一问让我们杀死进程，可以尝试根据windowsAPI提供的TerminateProcess函数去停止进程，写份代码测试下 1234567891011121314151617181920212223242526272829bool KillProcessByName(const char* processName) { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe; pe.dwSize = sizeof(PROCESSENTRY32); if (Process32First(hSnapshot, &amp;pe)) { do { if (strcmp(pe.szExeFile, processName) == 0) { HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID); if (hProcess) { TerminateProcess(hProcess, 0); CloseHandle(hProcess); Num++; printf(&quot;Kill suc:[%d]\\n&quot;, Num); } } } while (Process32Next(hSnapshot, &amp;pe)); } CloseHandle(hSnapshot); return true;}int main(){ while(1) { KillProcessByName(&quot;WorkingService.exe&quot;); } return 0;} 以管理员身份启动测试 启动前： 启动后 （二）解题过程先DIE查壳发现有VMP，只能动调入手，先观察程序功能。程序启动后会有两个进程启动，并且其中之一占用CPU性能较高；程序目录会创建十六个文件，并会做重复的删除和重新创建的操作；观察任务管理器发现进程会自动重启，手动杀死进程后就会重生一个新的进程。 拖进xdbg里观察符号，发现引入了ShellExcuteA这个函数，正好是启动进程函数，对这个函数下断点，发现确实断了下来，观察传参窗口。 第六个参数不同，对应的是lpParameters（传入进程的参数），一个是working,一个是daemon restart 根据这个在控制台上运行加上参数working，发现只有一个工作进程，CPU占用100%，同理加上daemon restart，只有一个守护进程CPU占用不到1%。 调试参数为working的进程，观察线程发现有16个线程运行同一个函数，刚好对应16个txt日志文件的输出！！！ 于是进入线程入口开始分析，对所有可能的写入文件的windowsAPI下断，发现都没有断下来，于是向CreateFile等API下断， 所有线程在CreateFileA上成功断下，观察传参确定这是对日志文件的操作函数 有了这个依据，能确认的就是16个线程会循环通过CreateFileA打开文件，这可能是占用CPU的一个主要因素。但是跟之前运行的结果不同，调试发现，写入文件的API一直没有被调用，而正常运行的结果是，十六个文件会循环的做一个过程，文件被创建-&gt;文件被写入-&gt;文件被删除-&gt;新文件创建…。我通过加working参数运行，只会有一个循环过程，即不会有新文件诞生，文件内容也不会被修改。所以，十六个线程循环CreateFileA打开文件过程是无用功，只会徒增CPU负担！那么我们是不是可以HOOK CreateFileA这个函数，然后每个线程调用它的第二次的时候我们进行线程终止，是不是可以减少CPU的压力了呢？写份代码跑一下看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _DEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];DWORD tlsIndex;//tls索引typedef BOOL(WINAPI* ShellExecuteExA_t)(SHELLEXECUTEINFOA*);typedef HANDLE (WINAPI* CreateFileA_t)( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);ShellExecuteExA_t TrueShellExecuteExA = NULL;CreateFileA_t TrueCreateFileA = NULL;BOOL WINAPI HookedShellExecuteExA(SHELLEXECUTEINFOA* pExecInfo) {#if 1 //执行第一个ShellExecuteExA守护进程 static int Num = 0; DBGMGEBOX(&quot;ShellExecuteExA 被调用:Num = %d\\nhProcess = %p&quot;, Num, pExecInfo-&gt;hProcess); if (Num == 0) { Num++; return TrueShellExecuteExA(pExecInfo); } else { return TrueShellExecuteExA(pExecInfo); }#else //执行第二个ShellExecuteExA病毒进程 static int Num = 0; DBGMGEBOX(&quot;ShellExecuteExA 被调用:Num = %d \\n调用者窗口句柄 = 0x%p\\n&quot;, Num, pExecInfo-&gt;hwnd); if (Num == 0) { Num++; DBGMGEBOX(&quot;[2]:当前线程ID：%d&quot;, GetCurrentThreadId()); pExecInfo-&gt;lpFile = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\自动F8直到call.txt&quot;;//修改参数导致重启失败; return TrueShellExecuteExA(pExecInfo); } else { DBGMGEBOX(&quot;[1]:当前线程ID：%d&quot;, GetCurrentThreadId()); return TrueShellExecuteExA(pExecInfo); }#endif}HANDLE WINAPI HookCreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile){ //判断线程是否是第一次运行CreateFileA，是的话就放行，不是第一次运行就终止线程 // 获取当前线程的TLS值 LPVOID tlsValue = TlsGetValue(tlsIndex); if (tlsValue == NULL) { // 第一次运行，设置TLS值#ifdef _DEBUG DBGMGEBOX(&quot;放行\\nlpFileName:%s\\n&quot;, lpFileName);#endif TlsSetValue(tlsIndex, (LPVOID)1); } else { // 不是第一次运行，终止线程#ifdef _DEBUG DBGMGEBOX(&quot;终止\\nlpFileName:%s\\n&quot;, lpFileName);#endif ExitThread(0); } return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); /*TrueShellExecuteExA = (ShellExecuteExA_t)DetourFindFunction(&quot;shell32.dll&quot;, &quot;ShellExecuteExA&quot;); DetourAttach(&amp;(PVOID&amp;)TrueShellExecuteExA, HookedShellExecuteExA);*/ tlsIndex = TlsAlloc();//初始化TLS TrueCreateFileA = (CreateFileA_t)DetourFindFunction(&quot;kernelbase.dll&quot;, &quot;CreateFileA&quot;); DetourAttach(&amp;(PVOID&amp;)TrueCreateFileA, HookCreateFileA); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueShellExecuteExA, HookedShellExecuteExA); DetourDetach(&amp;(PVOID&amp;)TrueCreateFileA, HookCreateFileA); TlsFree(tlsIndex);//清理TLS DetourTransactionCommit(); break; } return TRUE;} 注入进去查看CPU，与不注入的CPU情况对比如图，进程CPU占比显著下降 现在我们能够确定，是这十六个线程循环打开文件（也可能做了其他的事情）占用CPU大量资源。但是直接线程退出的方式也会导致日志文件被删除，题目意思是说在保持WorkingService.exe正常运行不崩溃、主体功能无损的前提下，使之占用CPU下降到平均5%以下，WorkingService.exe的主体功能为写入信息。在没有源码的情况下提取这个部分，自行编写一个性能更佳的服务，现在直接退出线程的方式会导致日志文件删除过快，虽然写入了信息，但是根本没法看啊，所以我们为了日志文件更方便的浏览，应该在WriteFile之后保存文件。那我们得先hook一下删除文件的函数，看一下在哪调用的，然后选择过滤掉这个函数从而保存日志文件。 尝试hook一下DeleteFileA这个函数 发现没有被调用。 翻阅了下CreateFileA的文档，找到dwFlagsAndAttributes这个参数，发现这个参数包含了FILE_FLAG_DELETE_ON_CLOSE这个属性，意思是文件将在关闭所有句柄后立即删除 123456789HANDLE CreateFileA( LPCSTR lpFileName, // 文件名 DWORD dwDesiredAccess, // 访问模式 DWORD dwShareMode, // 共享模式 LPSECURITY_ATTRIBUTES lpSecurityAttributes, // 安全属性 DWORD dwCreationDisposition, // 创建或打开文件的方式 DWORD dwFlagsAndAttributes, // 文件属性 HANDLE hTemplateFile // 模板文件句柄); FILE_FLAG_DELETE_ON_CLOSE0x04000000 文件将在关闭所有句柄后立即删除，其中包括指定的句柄和任何其他打开或重复的句柄。 因此，只要我们改了这个属性，日志文件就不会再被删除，写代码测试下 1234567891011121314151617181920212223242526272829303132HANDLE WINAPI HookCreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile){ //缩小每个线程执行CreateFileA的次数，CPU降低到%5以下 // 获取当前线程的TLS值 LPVOID tlsValue = TlsGetValue(tlsIndex); if ((DWORD_PTR)tlsValue &lt;= 0x10) {#ifdef _KDEBUG DBGMGEBOX(&quot;放行\\nlpFileName:%s\\n&quot;, lpFileName);#endif dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL; TlsSetValue(tlsIndex, (LPVOID)((DWORD_PTR)tlsValue + 1)); } else {#ifdef _KDEBUG DBGMGEBOX(&quot;终止\\nlpFileName:%s\\n&quot;, lpFileName);#endif ExitThread(0); } return TrueCreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);} 测试得到文件确实没有被删除，并且密文也成功写入文件，CPU占用也少于5%（峰值3%，最后趋近于0） 到这工作进程已经差不多分析完了，但是别忘了还有一个守护进程，守护进程应该也算是正常功能的一部分，那我们现在要开始结合守护进程分析。根据之前分析得到工作进程启动是通过守护进程调用ShellExcuteExA来传入working参数实现的，而这个后面启动的进程才是我们应该去注入的。而且因为程序有循环自生自灭的一个功能，我们可能要考虑循环注入实现对所有工作进程的hook。首先考虑第一个问题，如何去注入ShellExcuteExA启动的工作进程，第一个方式是Hook ShellExcuteExA这个函数，在其启动前获取ShellExcuteExA返回值-&gt;进程句柄，然后通过进程句柄进行注入；第二个方式是编写一个辅助程序，循环对每一个WorkingService.exe进程进行注入，这个要考虑到hook是否会影响守护进程的正常功能。我想先试一下第二个方式，较为简单一点，先测试一下守护进程是否会调用CreateFileA函数，如果会的话，我们要进行一下过滤操作。Hook测试了下，守护进程先启动，然后是工作进程，但是迟迟没有调试弹窗出现，说明守护进程没有调用CreateFileA。 因此，采用方式二，只要对所有WorkingService.exe进程进行注入，Hook CreateFileA函数即可在正常程序功能执行的情况下，降低CPU能耗，写一个程序测试一下 1234567891011121314151617181920212223242526272829303132333435363738int main() { while (1) { int Num = 0; ve = GetPidByProcName(&quot;WorkingService.exe&quot;); if (!ve.empty()) { printf(&quot;There are currently %d processes\\n&quot;, ve.size()); //依次注入并用map标记是否被注入过 for (auto i : ve) { auto it = mp.find(i); if (it == mp.end())//没有被注入过 { HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, i); if (InjectDll(hProcess, dllPath)) { Num++; mp.insert({ i,true }); printf(&quot;Inject process Success!\\n&quot;, Num); } } else //曾经注入过该进程 { printf(&quot;[%d] Has Been Injected\\n&quot;,i); continue; } } } else { printf(&quot;Wating WorkingService.exe ...\\n&quot;); } system(&quot;cls&quot;); //Sleep(200); } return 0;} 这里使用Vector去接受所有WorkingService.exe进程的pid，然后用Map去映射一个bool值来判断是否这个进程被注入过，程序运行起来发现CPU能耗还是100%,但是程序告诉我注入成功。???疑惑住了 因为之前注入的时候可以成功降低CPU能耗的，我很确信我的dll是没问题的，所以问题可能就是注入的方式了。考虑到之前注入使用工具注入，在进程启动的同时注入dll，而现在注入是在程序完全跑起来之后，所以怀疑是被下了钩子破坏了注入。在ARK工具里扫一下钩子看一眼。 豁然开朗！第一个钩子勾住了NtProtectVirtualMemory函数，而我们注入模块的时候就会调用这个内核函数去修改内存权限，第二个钩子勾住了DbgUiRemoteBreakin函数，我也不知道这个函数是干什么的，问一下GPT得知 DbgUiRemoteBreakin函数是一个Windows API函数，它的作用是向指定的进程发送一个远程调试器的断点请求。当这个函数被调用时，目标进程会触发一个断点异常（通常是访问违规异常），如果目标进程已经有一个调试器附加，那么调试器就会捕获这个异常并进行处理。 这个函数通常用于以下情况： 附加调试器：如果你想要附加一个调试器到一个正在运行的进程，你可以调用DbgUiRemoteBreakin来使进程触发断点，然后使用调试器来附加到该进程。 检测调试：如果一个进程检测到自己被调试，它可以调用DbgUiRemoteBreakin来尝试断开任何远程调试器的连接。 看来是能附加调试的，勾住这个来反调试，哇哦，不错的方式。但是我们就先不管它了，先成功注入dll再说。所以现在看来还得先还原NtProtectVirtualMemory函数取消钩子，再调用注入函数，修改一下代码跑一下发现日志文件不能循环写入，应该是线程都退出之后，进程并未停止，猜测是线程函数里有计数的东西，到某个值之后会通知进程结束，从而让守护进程再生工作进程，于是我改了一下hook代码，让线程终止16次后终止进程，从而实现日志文件循环再生。 效果图： 题目二的结果应该就是这样了，能保持写入日志文件功能的同时不破坏工作进程循环启动的机制，大功告成！！！ 附一份exe源码和一份dll源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//main.cpp#include &lt;windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;map&gt;char dllPath[] = R&quot;(C:\\Users\\15386\\Desktop\\temp\\hookDll.dll)&quot;;std::vector&lt;DWORD64&gt;ve;std::map&lt;DWORD64, bool&gt;mp;BYTE jmpBytes[] = {0xE9, 0xE0, 0x26, 0x16, 0x00};BYTE originBytes[] = {0x4C, 0x8B, 0xD1, 0xB8, 0x50, 0x00, 0x00, 0x00, 0xF6, 0x04, 0x25, 0x08, 0x03, 0xFE, 0x7F, 0x01, 0x75, 0x03, 0x0F, 0x05, 0xC3, 0xCD, 0x2E, 0xC3};std::vector&lt;DWORD64&gt; GetPidByProcName(const char* processName) { HANDLE hProcessSnap = INVALID_HANDLE_VALUE; PROCESSENTRY32 pe32 = { 0 }; std::vector&lt;DWORD64&gt; vec; vec.clear(); hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hProcessSnap == INVALID_HANDLE_VALUE) { vec; } pe32.dwSize = sizeof(PROCESSENTRY32); if (Process32First(hProcessSnap, &amp;pe32)) { do { if (strcmp(pe32.szExeFile, processName) == 0) { vec.push_back(pe32.th32ProcessID); } } while (Process32Next(hProcessSnap, &amp;pe32)); } CloseHandle(hProcessSnap); return vec;}DWORD64 GetModuleBase(DWORD64 pid,const char* ModuleName){ HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid); if (hModuleSnap != INVALID_HANDLE_VALUE) { MODULEENTRY32 me32; me32.dwSize = sizeof(MODULEENTRY32); if (Module32First(hModuleSnap, &amp;me32)) { do { if (_stricmp(me32.szModule, ModuleName) == 0) { return (DWORD64)me32.modBaseAddr; } } while (Module32Next(hModuleSnap, &amp;me32)); } CloseHandle(hModuleSnap); } return 0;}BOOL InjectDll(HANDLE hProcess, LPCSTR dllPath) { LPVOID pRemoteDllPath = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE); if (pRemoteDllPath == NULL) { printf(&quot;VirtualAllocEx Failed:[%d]\\n&quot;, GetLastError()); return FALSE; } if (!WriteProcessMemory(hProcess, pRemoteDllPath, dllPath, strlen(dllPath) + 1, NULL)) { printf(&quot;WriteProcessMemory Failed:[%d]\\n&quot;, GetLastError()); VirtualFreeEx(hProcess, pRemoteDllPath, 0, MEM_RELEASE); return FALSE; } LPTHREAD_START_ROUTINE lpLoadLibrary = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (lpLoadLibrary == NULL) { printf(&quot;GetProcAddress Failed:[%d]\\n&quot;, GetLastError()); VirtualFreeEx(hProcess, pRemoteDllPath, 0, MEM_RELEASE); return FALSE; } HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, lpLoadLibrary, pRemoteDllPath, 0, NULL); if (hThread == NULL) { printf(&quot;CreateRemoteThread Failed:[%d]\\n&quot;, GetLastError()); VirtualFreeEx(hProcess, pRemoteDllPath, 0, MEM_RELEASE); return FALSE; } WaitForSingleObject(hThread, INFINITE); DWORD dwExitCode; if (GetExitCodeThread(hThread, &amp;dwExitCode) &amp;&amp; dwExitCode == 0) { printf(&quot;LoadLibraryA Failed in remote process\\n&quot;); CloseHandle(hThread); VirtualFreeEx(hProcess, pRemoteDllPath, 0, MEM_RELEASE); return FALSE; } CloseHandle(hThread); VirtualFreeEx(hProcess, pRemoteDllPath, 0, MEM_RELEASE); return TRUE;}BOOL RemoveHook(HANDLE hProcess,PVOID unHookAddr, BYTE* originBytes){ PDWORD oldProtect = 0; if (!WriteProcessMemory(hProcess, (PVOID)unHookAddr, originBytes, sizeof(originBytes), 0)) { printf(&quot;RemoveHook Failed!!!: [%d]\\n&quot;, GetLastError()); return FALSE; }}int main() { while (1) { int Num = 0; ve = GetPidByProcName(&quot;WorkingService.exe&quot;);//获取所有进程pid if (!ve.empty()) { printf(&quot;There are currently %d processes\\n&quot;, ve.size()); //依次注入并用map标记是否被注入过 for (auto i : ve) { auto it = mp.find(i); if (it == mp.end())//没有被注入过 { HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, i);//要用管理员权限运行，要不然为返回空 if (!hProcess) printf(&quot;OpenProcess Error:[%d]&quot;, GetLastError()); DWORD64 unHookAddr = GetModuleBase(i,&quot;ntdll.dll&quot;) + 0xA0990;//NtProtectVirtualMemory地址，ntdll + 0xA0990 if (RemoveHook(hProcess, (PVOID)unHookAddr, originBytes))//先取消NtProtectVirtualMemory钩子再注入 { if (InjectDll(hProcess, dllPath)) { Num++; mp.insert({ i,true });//注入成功后进行标记 printf(&quot;Inject process Success!\\n&quot;, Num); } } } else continue;//曾经注入过该进程 } } else printf(&quot;Wating WorkingService.exe ...\\n&quot;); Sleep(1000); system(&quot;cls&quot;); } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//dllmain.cpp#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdlib.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _KDEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];DWORD tlsIndex;//tls索引typedef BOOL(WINAPI* ShellExecuteExA_t)(SHELLEXECUTEINFOA*);typedef HANDLE (WINAPI* CreateFileA_t)( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);ShellExecuteExA_t TrueShellExecuteExA = NULL;CreateFileA_t TrueCreateFileA = NULL;BOOL WINAPI HookedShellExecuteExA(SHELLEXECUTEINFOA* pExecInfo) {#if 1 //执行第一个ShellExecuteExA守护进程 static int Num = 0; DBGMGEBOX(&quot;ShellExecuteExA 被调用:Num = %d\\nhProcess = %p&quot;, Num, pExecInfo-&gt;hProcess); if (Num == 0) { Num++; return TrueShellExecuteExA(pExecInfo); } else { return TrueShellExecuteExA(pExecInfo); }#else //执行第二个ShellExecuteExA病毒进程 static int Num = 0; DBGMGEBOX(&quot;ShellExecuteExA 被调用:Num = %d \\n调用者窗口句柄 = 0x%p\\n&quot;, Num, pExecInfo-&gt;hwnd); if (Num == 0) { Num++; DBGMGEBOX(&quot;[2]:当前线程ID：%d&quot;, GetCurrentThreadId()); pExecInfo-&gt;lpFile = &quot;C:\\\\Users\\\\Administrator\\\\Desktop\\\\自动F8直到call.txt&quot;;//修改参数导致重启失败; return TrueShellExecuteExA(pExecInfo); } else { DBGMGEBOX(&quot;[1]:当前线程ID：%d&quot;, GetCurrentThreadId()); return TrueShellExecuteExA(pExecInfo); }#endif}HANDLE WINAPI HookCreateFileA( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile){ //判断线程是否是第一次运行CreateFileA，是的话就放行，不是第一次运行就终止线程 // 获取当前线程的TLS值 LPVOID tlsValue = TlsGetValue(tlsIndex); if ((DWORD_PTR)tlsValue &lt;= 0x10) { // #ifdef _KDEBUG DBGMGEBOX(&quot;放行\\nlpFileName:%s\\n&quot;, lpFileName);#endif dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL; TlsSetValue(tlsIndex, (LPVOID)((DWORD_PTR)tlsValue + 1)); } else { static int Num = 0;//如果终止了十六个线程，再终止进程，使得守护线程再生工作进程 // 不是第一次运行，终止线程#ifdef _KDEBUG DBGMGEBOX(&quot;终止\\nlpFileName:%s\\n&quot;, lpFileName);#endif Num++; ExitThread(0); if (Num == 16) exit(0); } return TrueCreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); //ShellExecuteExA hook /*TrueShellExecuteExA = (ShellExecuteExA_t)DetourFindFunction(&quot;shell32.dll&quot;, &quot;ShellExecuteExA&quot;); DetourAttach(&amp;(PVOID&amp;)TrueShellExecuteExA, HookedShellExecuteExA);*/ tlsIndex = TlsAlloc();//初始化TLS TrueCreateFileA = (CreateFileA_t)DetourFindFunction(&quot;kernelbase.dll&quot;, &quot;CreateFileA&quot;); DetourAttach(&amp;(PVOID&amp;)TrueCreateFileA, HookCreateFileA); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueShellExecuteExA, HookedShellExecuteExA); DetourDetach(&amp;(PVOID&amp;)TrueCreateFileA, HookCreateFileA); TlsFree(tlsIndex);//清理TLS DetourTransactionCommit(); break; } return TRUE;} （三）思路分享接着是第三题，要求是WorkingService.exe的主体功能为写入信息。在没有源码的情况下提取这个部分，自行编写一个性能更佳的服务，完全替代WorkingService.exe写入同样的密文信息，且运行时平均占用CPU时间低于5%。（2分） 根据之前分析，现在一直的程序功能主要体现在，创建守护进程启动-&gt;启动工作进程-&gt;创建十六个线程-&gt;每个线程创建一个日志文件-&gt;向文件写入密文-&gt;进程退出-&gt;守护进程循环创建工作进程，大致功能应该就是这些，而现在要解决的问题就是日志文件名和日志密文是怎么产生的。 在WriteFile下个断点看一眼密文的大致模样。 猜测有可能是base64加密，因为之前查看字符串有看到base64的码表，还是一个魔改码表，直接丢cyberchef试一下解密 好熟悉的字符串，这不正是初赛题的明文嘛，这个明显就是base64加密明文了，但是还有一个疑问，就是不同的文件会打印出不同的密文，把十六个文件的密文提取出来对比一下 123456789101112131415161 F2FU4Wht52lm+2dV4WFu 61282 4WECF2ht52lm+2dV4WFu 205122 4WECF2ht52lm+2dV4WFu 220603 Fx9U4RY7ERcwDRkDFx84 227084 Fx8CFxY7ERcwDRkD4WFu 252965 Fx9U4RZt5xcwDRkDFx84 253766 Fx8CFxY7ERcwDRkDFx84 256203 Fx9U4RY7ERcwDRkDFx84 257562 4WECF2ht52lm+2dV4WFu 261363 Fx9U4RY7ERcwDRkDFx84 277047 4R9U4RY7ERcwDWdV4WE4 279768 4WECF2ht5xcwDRkDFx84 283803 Fx9U4RY7ERcwDRkDFx84 286249 Fx9U4RY7EWlm+xkDFx84 2876410 4WECFxY7ERcwDWdV4WFu 2990411 Fx9U4RY7ERcwDWdV4WE4 31648 对比发现十六个线程有十一个密文，16:11的不规则性我觉得甚至不止十一个，因为这个采样只是采取了一个进程创建的十六个线程，如果有更多进程可能就意味着更多种密文。 根据base64编码规则，如果码表和明文都一致的话，那密文就只能有一个，说明每个线程的码表和明文至少有一个不一致。那现在只能继续分析他的加密方式，在现有的码表处下断追踪到加密函数 在内存窗口发现传入的第一个参数是一个字符串地址-&gt;c tc me an，貌似跟catchmeifyoucan明文很像，所以这是修改了明文，然后再通过正常的码表进行base64加密？提取出这个明文，试一下对着这个码表加密，对比运行后的密文就知道了， 123456明文：0x15, 0x61, 0x02, 0x15, 0x68, 0x1B, 0x13, 0x69, 0x66, 0x79, 0x6F, 0x75, 0x63, 0x17, 0x18实际密文：F2ECF2g7EWlm+2dV4R84正常base64密文：F2ECF2g7EWlm+2dV4R84明文：0x63, 0x17, 0x74, 0x63, 0x1E, 0x6D, 0x65, 0x1F, 0x10, 0x0F, 0x19, 0x03, 0x15, 0x61, 0x6E实际密文：4R9U4RZt5xcwDRkDF2Fu正常base64密文：4R9U4RZt5xcwDRkDF2Fu 对比了多组，确信了码表是对的ABCDEFGHIJKLMNOPwxyz0123456789+/ghijklmnopqrstuvQRSTUVWXYZabcdef,但是调试这个加密的过程中发现，一个线程至少会有两组明文，上面就是出自同一个线程。并且这个函数加密后的密文跟实际文件密文不同，下面是提取的两组密文和实际文件密文 1234//34288线程文件密文：4WFU4Wht52lm+2dV4WFu密文1 ：Fx8C4Wg7ERcwDWdV4WE4密文2 ：4WFUFxZt52lm+xkDFx9u 现在还有很多问题在里面，首先是明文为什么一个线程有两组，加密得到的两组密文跟文件密文有什么关系？两组密文实在是太奇怪了，我试着把他们联系起来，于是我将两组密文用base64还原得到明文也进行了对比，发现了一个惊喜。 这两个明文的有效字符组合起来刚好是catchmeifyoucan！！！ 接着就是其他无效字符了，提取出十六进制看看有没有联系 Fx8C4Wg7ERcwDWdV4WE4-&gt;0x15,0x17,0x02,0x63,0x68,0x1b,0x13,0x1f,0x10,0x0f,0x6f,0x75,0x63,0x61,0x184WFUFxZt52lm+xkDFx9u-&gt;0x63,0x61,0x74,0x15,0x1e,0x6d,0x65,0x69,0x66,0x79,0x19,0x03,0x15,0x17,0x6e 貌似没什么关系，考虑到多个文件的写入密文不同，继续提取其他线程的密文 1234//14032 线程文件密文：Fx8CFxY7ERcwDRkDFx84密文1 ：Fx8C4Wg7ERcwDWdV4WE4密文2 ：4WFUFxZt52lm+xkDFx9u 拿这个线程的文件密文拿去解密，得到十六进制数组:0x15,0x17,0x02,0x15,0x1e,0x1b,0x13,0x1f,0x10,0x0f,0x19,0x03,0x15,0x17,0x18，刚好由34288线程的两组非可视字符十六进制组成。根据这个思路我把之前提取的密文进行了解密，发现线程之间的非字符不一定是成对的，但是非字符的十六进制跟所在索引是一定的，也就是说所有非可视字符的十六进制都是从上面这个数组里取，我试图多运行几遍进程反驳我这个猜想，因为这个十六进制数组并没有什么规律，但是运行结果都显示这个数组是一定的。 所以现在可以确定的是，明文catchmeifyoucan会和这个数组以某种方式进行混合，最后组成真正的明文进行base64换表加密得到文件密文。现在就需要继续研究这个混合的方式，因为进程会启动十六个线程来写日志，而且在之前的观察中看到在CreateFileA函数之前，密文就已经储存在寄存器中，所以是CreateThread和CreateFileA函数之间进行了明文混合和base64加密，对这三个关键地方下断点调试 123{0x15, 0x17, 0x02, 0x15, 0x1E, 0x1B, 0x13, 0x1F, 0x10, 0x0F, 0x19, 0x03, 0x15, 0x17, 0x18}; 可以看到，第一个参数即为之前分析的十六进制数组的指针，做一层栈回溯找明文混合方式 对base64的第一个参数位置（明文指针）下硬件访问断点，找到写入明文内存的位置 明文进行了一个字节一个字节的写入，仔细看这段VM给的混淆汇编代码， 其实就是一个 123mov r8, qword ptr ds:[rdi]mov r9b, byte ptr ds:[rdi+0x8]mov byte ptr ds:[r8], r9b 那就意味着我们要追踪[RDI]看看是怎么来的，由于这段代码已经被VM了，控制流混淆导致根本没法手动追踪，用xdbg自动追踪功能打印日志看看 足足有30000行汇编 往上回溯第一层发现[rdi]从RFLAGS寄存器来的，如果真要手动回溯的话，就要回溯十多个标志位，手动分析逻辑写源码不大现实（不禁再次感叹VM的强大） 根据题目要求 提取WorkingService.exe的主体功能可以以二进制指令块的形式，也可以以自写源码的形式 可以考虑提取二进制指令块的形式写功能，那我们就可以把这段追踪得来的汇编代码转成ShellCode写入到自己程序的内存里，然后通过VirtualProtect修改成可执行的运行一下从而提取这份功能。只要获取这份功能就可以完成第三问了，感觉工程量挺大的就不写了。 程序分析总结启动程序后会先默认按照参数daemon restart启动一个守护进程，守护进程通过设置参数working和调用ShellExcuteA来启动工作进程，工作进程会创建16个线程来循环调用CreateFileA保持文件存在（第二问需要通过修改参数实现相同功能并减少CPU占用率）并调用一次WriteFile来写入密文，密文由两个明文和两种加密组成，明文是catchmeifyoucan字符串和{0x15, 0x17, 0x02, 0x15, 0x1E, 0x1B, 0x13, 0x1F, 0x10, 0x0F, 0x19, 0x03, 0x15, 0x17, 0x18}数组，第一种加密是某种替换加密，第二种加密是base64变表加密。","link":"/2024/08/13/2023%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8PC%E5%86%B3%E8%B5%9B/"},{"title":"2024腾讯游戏安全PC初赛","text":"小Q是一个PC客户端安全爱好者。有一天他得到了一个未知工具，含有一个exe、一个sys和一份使用说明。说明写道:ACE的宝库钥匙由两串 token组成．运行这组程序．它们会将两串 token藏于内存中。宝库有两位守护者会制裁使用违禁工具的冒险家，在寻宝时务必谨慎小心。 题目 （一）解题过程拿到hack.exe，浅分析一下发现加了VM，并且有检测黑客工具的行为，检测到了之后即使关闭黑客程序也会影响程序正常运行，但是xdbg稍微改一下还是可以动调的，在xdbg里下一些可能的函数断点，我这里在这些地方下了断点 运行发现程序会多次在WriteProcessMemory下断下，hook一下观察传参 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//dllmain.cpp#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _KDEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];typedef BOOL(WINAPI* WriteProcessMemory_t)( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten );WriteProcessMemory_t TrueWriteProcessMemory = NULL;BOOLWINAPIHookWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten){ char fileName[12] = { 0 }; sprintf(fileName, &quot;out%d.txt&quot;, (int)hProcess % 1000); HANDLE hFile = CreateFile(fileName, FILE_APPEND_DATA, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { DBGMGEBOX(&quot;CreateFile Fail&quot;); return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten); } SetFilePointer(hFile, 0, NULL, FILE_END); DWORD bytesWritten; BOOL result = WriteFile(hFile, lpBuffer, nSize, &amp;bytesWritten, NULL); CloseHandle(hFile); DBGMGEBOX(&quot;findProcess WriteProcessMemory:%p,size:%d\\n&quot;, hProcess,nSize); return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); TrueWriteProcessMemory = (WriteProcessMemory_t)DetourFindFunction(&quot;kernel32.dll&quot;, &quot;WriteProcessMemory&quot;); DetourAttach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; } return TRUE;} 这里输出了三个txt文件 其中out200.txt文件有明显的PE头 去除前面的字节，把文件丢到DIE里分析一下发现是dll64文件并且貌似没加壳，所以hack.exe通过WriteProcessMemory往某个进程写入了一个dll?怀疑是远程注入，至于做了什么，有可能跟token有关，继续分析。 ida64打开发现程序的dllMain入口还是被加密了 还是继续动调，随便找了个64位的可执行文件，拖到X64dbg里运行，直接用xdbg的注入方式将out200.dll注入进程，在 入口点下断点，并且对一些可疑的WINDOWS API下断观察进程行为 这里我对下面这几个API下了断点 运行，第一次成功在openProcess函数断下 观察传参窗口，找到了一个系统进程名称字符串winlogon.exe，而这里调用的是openProcess，疑似是对系统进程winlogon.exe做了一些操作。继续分析，运行到返回，回溯一层函数，找到一段没有被加密的代码 汇编代码不是很好看，根据偏移在IDA里反汇编看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149__int64 __fastcall sub_1800063D0(_DWORD *Dst, DWORD dwProcessId){ __m128i si128; // xmm0 __m128i v6; // xmm0 __int64 result; // rax __m128i v10; // xmm2 size_t v14; // rbx __int64 v15; // rax int v16; // r14d HANDLE Toolhelp32Snapshot; // rsi HANDLE v18; // rax __int64 v21; // rbx CHAR Caption[16]; // [rsp+40h] [rbp+0h] BYREF _RBP = (unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64; if ( !dwProcessId ) { *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)_RBP = 0xE795A71250E2465Aui64; si128 = _mm_load_si128((const __m128i *)_RBP); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xE795A7603F90341Fui64; v6 = _mm_xor_si128(si128, *(__m128i *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20)); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0x84FAD5301FE45158ui64; *(__m128i *)_RBP = v6; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xBF19D3ADD5D97A59ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A0) = 0xE795A7603F90341Fui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = 0xBD1C9CA3F4C12EC9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = 0xA727C05763438E84ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B0) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B8) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+210h+var_70] vpxor ymm1, ymm0, ymmword ptr [rbp+210h+Text] vmovdqa ymmword ptr [rbp+210h+Text], ymm1 vzeroupper } MessageBoxA(0i64, (LPCSTR)(_RBP + 32), (LPCSTR)((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64), 0);LABEL_3: GetLastError(); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xE795A7603F90341Fui64; *(_QWORD *)_RBP = 0x88D6871250E2465Aui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 8) = 0xC65BF98DB9906C58ui64; *(__m128i *)_RBP = _mm_xor_si128( _mm_load_si128((const __m128i *)_RBP), *(__m128i *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20)); return sub_180006A00((void *)((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64)); } if ( !(unsigned __int8)sub_180006FC0() ) { *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A0) = 0xE795A7603F90341Fui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x48) = 0x44F651D568826090i64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1C0) = 0x52C9FCDC77FF5FC3i64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xDDD2E92971C27548ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xA43EB7C9E8CF4E1Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = 0xA62FD5B4C980079Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = 0xD55585772756849Aui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = 0x52C9FCDC7DDE2DACi64; v10 = _mm_load_si128((const __m128i *)(_RBP + 64)); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1C8) = 0x44F651D568826090i64; _XMM2 = _mm_xor_si128(v10, *(__m128i *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1C0)); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B0) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B8) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+210h+var_70] vpxor ymm1, ymm0, ymmword ptr [rbp+210h+Text] vmovdqa [rbp+210h+var_1D0], xmm2 vmovdqa ymmword ptr [rbp+210h+Text], ymm1 vzeroupper } sub_180006A00((void *)(_RBP + 32)); } v14 = -1i64; if ( dwProcessId == -1 ) { Dst[34] = GetCurrentProcessId(); *((_QWORD *)Dst + 13) = -1i64; } else { Dst[34] = dwProcessId; v18 = OpenProcess(0x1FFFFFu, 0, dwProcessId); *((_QWORD *)Dst + 13) = v18; if ( !v18 ) { *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = 0xA727C0574231E1F6ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0x84FAD53051F54450ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A0) = 0xE795A7603F90341Fui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xA92981ACBCD97A59ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = 0xCF59BCC699AA419Bui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B0) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B8) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+210h+var_70] vpxor ymm1, ymm0, ymmword ptr [rbp+210h+Text] vmovdqa ymmword ptr [rbp+210h+Text], ymm1 vzeroupper } sub_180006A00((void *)(_RBP + 32));//打印报错信息 goto LABEL_3; } } Dst[30] = 0x1FFFFF; v15 = -1i64; do ++v15; while ( *((_BYTE *)Dst + v15) ); if ( !v15 ) { v16 = Dst[34]; Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0); if ( Toolhelp32Snapshot != (HANDLE)-1i64 ) { *(_DWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = 304; memset((void *)(_RBP + 100), 0, 0x12Cui64); if ( Process32First(Toolhelp32Snapshot, (LPPROCESSENTRY32)(_RBP + 96)) ) { while ( *(_DWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x68) != v16 ) { if ( !Process32Next(Toolhelp32Snapshot, (LPPROCESSENTRY32)(_RBP + 96)) ) goto LABEL_20; } do ++v14; while ( *(_BYTE *)(_RBP + 140 + v14) ); memmove(Dst, (const void *)(_RBP + 140), v14); }LABEL_20: CloseHandle(Toolhelp32Snapshot); } } *((_QWORD *)Dst + 18) = sub_1800068D0(Dst, Dst); v21 = 0i64; *(_DWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 8) = Dst[34]; *(_QWORD *)_RBP = 0i64; EnumWindows(EnumFunc, (unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64); result = *(_QWORD *)_RBP; if ( *(_QWORD *)_RBP ) v21 = *(_QWORD *)_RBP; *((_QWORD *)Dst + 16) = v21; return result;} 这段代码一次进行了获取进程pid，打开进程，遍历模块等操作，并且在函数失败后做了一些奇奇怪怪的东西，对一些地址赋上了一些64位的值，猜测是隐藏字符串来打印调试信息用的，再通过messagebox和outputDebugString给出调试信息，显示打开进程失败，猜测是因为hack.exe启动是管理员启动，这里失去了管理员权限。 分析完这个函数，继续回溯一层，运行到返回，定位到这个地方 继续根据偏移转到IDA里看反汇编 123456789101112131415161718192021222324252627int sub_180001990(){ size_t v0; // rbx DWORD v1; // eax __m128i Dst; // [rsp+20h] [rbp-48h] BYREF __int64 v4; // [rsp+30h] [rbp-38h] __int64 v5; // [rsp+38h] [rbp-30h] __m128i Src; // [rsp+40h] [rbp-28h] BYREF Dst.m128i_i64[0] = 0xE795A7603F90341Fui64; Dst.m128i_i64[1] = 0xC65BF3E99CAA093Cui64; Src.m128i_i64[0] = 0x89FAC00F53FE5D68ui64; Src.m128i_i64[1] = 0xC65BF3E9F9D26C12ui64; Src = _mm_xor_si128(_mm_load_si128(&amp;Src), Dst); v0 = -1i64; do ++v0; while ( Src.m128i_i8[v0] ); memmove(dword_1800349A0, &amp;Src, v0); Dst.m128i_i64[0] = 0i64; v4 = 0i64; v5 = 15i64; sub_180004770(&amp;Dst, &amp;Src, v0); v1 = sub_1800070A0(&amp;Dst); sub_1800063D0(dword_1800349A0, v1); return atexit(sub_180020C90);} 前面应该是一个加密的字符串操作，用python打印出字符串 123456789101112131415161718192021def hex_xor_to_string(a, b): result = a ^ b hex_str = hex(result)[2:] if len(hex_str) % 2 != 0: hex_str = '0' + hex_str result_str = ''.join(chr(int(hex_str[i:i+2], 16)) for i in range(0, len(hex_str), 2)) return result_strx1 = 0xE795A7603F90341Fx2 = 0xC65BF3E99CAA093Cy1 = 0x89FAC00F53FE5D68y2 = 0xC65BF3E9F9D26C12result1 = hex_xor_to_string(x1, y1)result2 = hex_xor_to_string(x2, y2)print(&quot;Result 1:&quot;, result1)print(&quot;Result 2:&quot;, result2)#Result 1: nogolniw#Result 2: exe. 得到的刚好是winlogon.exe字符串，然后程序将这个字符串转移到了dword_1800349A0全局变量中，目的应该是隐藏字符串，接着sub_180004770函数也是一个类似memmove操作，把这个字符串传到了Dst局部变量中，接着在sub_1800070A0中传入这个字符串，貌似是在根据字符串获取进程PID，接着调用sub_1800063D0函数根据pid打开进程，并将进程句柄存储到了某个地方 12v18 = OpenProcess(0x1FFFFFu, 0, dwProcessId);*((_QWORD *)Dst + 13) = v18; 随后return exit退出。 随后我在退出函数传参的时候看到了一个hProcess 一个全局变量，很有可能在其他地方对句柄进行了读取，交叉引用一下定位到如下函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void sub_180007C10(){ HANDLE v1; // rcx void *v2; // rdx __int128 v3; // xmm0 __int128 v4; // xmm1 HANDLE FileA; // rbx __int64 v8; // rcx _BYTE *v9; // rdx unsigned __int64 v10; // rdx _QWORD *v11; // rcx char Buffer; // [rsp+60h] [rbp+0h] BYREF _RBP = (unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64; while ( byte_180032C00 ) { if ( !byte_180034961 &amp;&amp; !byte_180034960 ) sub_1800041D0(); v1 = hProcess; v2 = (void *)(qword_180034968 + 2766); *(_BYTE *)_RBP = 15; WriteProcessMemory(v1, v2, (LPCVOID)((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64), 1ui64, 0i64); byte_180032C00 = 0; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xAA32D3B2B7C50388ui64; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = 0xA0A195500DCC0E5Cui64; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = 0x943E9588CFCF645Dui64; v3 = *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x10); *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xA727C0574231D098ui64; v4 = *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20); *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = 0xE795A7603F90341Fui64; *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = v3; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x88) = 0xC65BF3E99CAA093Cui64; *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = v4; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x98) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+0D0h+var_50] vpxor ymm1, ymm0, ymmword ptr [rbp+0D0h+FileName] vmovdqa ymmword ptr [rbp+0D0h+FileName], ymm1 vzeroupper } FileA = CreateFileA((LPCSTR)(_RBP + 96), 0x40000000u, 0, 0i64, 3u, 0x80u, 0i64); if ( FileA != (HANDLE)-1i64 ) { ((void (__fastcall *)(unsigned __int64))loc_180007A20)(_RBP + 48); v8 = -1i64; if ( *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x48) &lt; 0x10ui64 ) { do ++v8; while ( *(_BYTE *)(_RBP + 48 + v8) ); v9 = (_BYTE *)(_RBP + 48); } else { v9 = *(_BYTE **)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30); do ++v8; while ( v9[v8] ); } WriteFile(FileA, v9, v8, (LPDWORD)(_RBP + 8), 0i64); CloseHandle(FileA); v10 = *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x48); if ( v10 &gt;= 0x10 ) { v11 = *(_QWORD **)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30); if ( v10 + 1 &gt;= 0x1000 ) { v11 = (_QWORD *)*(v11 - 1); if ( (unsigned __int64)(*(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) - (_QWORD)v11 - 8i64) &gt; 0x1F ) invalid_parameter_noinfo_noreturn(); } j_j_free(v11); } } }} 看到了有WriteProcessMemory写入hProcess内存操作，CreateFileA，WriteFile，打开和写入文件操作，但是并没有找到hProcess的赋值语句，也就是说这个进程句柄还不知道是谁的，猜测赋值被隐藏了，但是可以猜测可能是winlogon.exe进程句柄。byte_180032C00是一个全局的标志变量，强制函数只能执行一次，对应的是运行程序时仅一次的初始化操作。接着看一下CreateFileA函数，同样的文件名被隐藏了，python解析一下 123456789101112131415161718192021222324252627282930def hex_xor_to_string(a, b): result = a ^ b hex_str = hex(result)[2:] if len(hex_str) % 2 != 0: hex_str = '0' + hex_str result_str = ''.join(chr(int(hex_str[i:i+2], 16)) for i in range(0, len(hex_str), 2)) return result_strx1 = 0xA0A195500DCC0E5Cx2 = 0x943E9588CFCF645Dx3 = 0xAA32D3B2B7C50388x4 = 0xA727C0574231D098y1 = 0xE795A7603F90341Fy2 = 0xC65BF3E99CAA093Cy3 = 0xCF59BCC699A060E9y4 = 0xA727C0574231E1F6result1 = hex_xor_to_string(x1, y1)result2 = hex_xor_to_string(x2, y2)result3 = hex_xor_to_string(x3, y3)result4 = hex_xor_to_string(x4, y4)print(&quot;Result 1:&quot;, result1)print(&quot;Result 2:&quot;, result2)print(&quot;Result 3:&quot;, result3)print(&quot;Result 4:&quot;, result4)res = result1[::-1] + result2[::-1] + result3[::-1] + result4[::-1]print(res) 整个拼起来是字符串C:\\2024GameSafeRace.token1，应该是创建了一个文件，然后向这个文件写入了token1了，接着往下 loc_180007A20这个函数内部被加密了，猜测是对token1的解密过程，然后通过WriteFile写入C:\\2024GameSafeRace.token1中，并不是很像去分析这个函数，直接加载驱动看看能不能直接运行得到2024GameSafeRace.token1文件。 找到下没找到，回头看看CreateFileA函数，核查一下后面几个参数 1FileA = CreateFileA((LPCSTR)(_RBP + 96), 0x40000000u, 0, 0i64, 3u, 0x80u, 0i64); 看来是参数在作怪，CreateFileA函数传入OPEN_EXISTING参数，如果没有指定文件，则函数会返回失败，那也好办，自己创建一个就好了。 C:\\2024GameSafeRace.token1成功被写入 010打开找到token1:757F4749AEBB1891EF5AC2A9B5439CEA token2的寻找就偏简单了，加载驱动后留意一下dbgView的打印信息就可以获取 组合一下就是token2：803f14a24d64f3e697957c252e3a5686 （二）解题过程题目要求： 编写程序，运行时修改尽量少的内存，让两段token输出成功。（满分2分） 根据之前分析的token1，我们可以知道程序会在CreateFileA后解密token1然后写入到C:\\2024GameSafeRace.token1中，但是会因为CreateFileA参数OPEN_EXISTING条件不满足而失败，所以我们只需要修改这个传参，改成OPEN_ALWAYS，即可实现输出token1，那我们只需要hook CreateFileA函数修改传参即可，但是有个问题，因为不是hack.exe本身调用CreateFileA函数，而是hack.exe注入了一个dll到winlogon.exe，然后再winlogon.exe里调用CreateFileA函数，所以我们可以考虑在注入前修改WriteProcessMemory函数参数buffer，从而在注入前patch dll，或者编写代码直接注入winlogon.exe，hook CreateFileA函数修改传参，但是考虑到第二种方式可能不被允许，winlogon.exe毕竟是系统进程，题目应该是要我们通过patch dll的方式解题。 这里我们要patch 传参，通过ida找到传参的汇编代码 在winhex里找到对应所在文件偏移 也就是在0x7171处OPEN_EXISTING:0x3是要patch的地方，把这个参数修改成OPEN_ALWAYS:0x4即可。下面编写代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//dllmain.cpp#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _KDEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];typedef BOOL(WINAPI* WriteProcessMemory_t)( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten );WriteProcessMemory_t TrueWriteProcessMemory = NULL;BOOLWINAPIHookWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten){ if (nSize == 4506624 &amp;&amp; *((PUCHAR)lpBuffer + 0x7171) == 0x3) { *((PUCHAR)lpBuffer + 0x7171) = 0x4; DBGMGEBOX(&quot;Hook Success!\\n&quot;); } return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); TrueWriteProcessMemory = (WriteProcessMemory_t)DetourFindFunction(&quot;kernel32.dll&quot;, &quot;WriteProcessMemory&quot;); DetourAttach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; } return TRUE;} 成功输出token1文件： 然后是token2，既然是内核输出，那只能是在ace.sys里做点手脚，DIE查壳发现ace.sys的大部分代码都被加壳过了，静态代码不好看，只能先猜测token2的输出调用了DbgPrint或者DbgPrintEx，因为之前输出token2的时候开启了Verbose Kernel outPut，猜测之所以正常输出失败是因为DbgPrintEx的level值太低，仅将字符串传递给内核调试器，不执行输出操作。 hook DbgPrintEx函数看一眼传参。 123456789101112131415161718192021222324252627282930313233343536#include &lt;ntifs.h&gt;#include &lt;ntdef.h&gt;#include &lt;ntstatus.h&gt;#include &lt;ntddk.h&gt;#include &lt;stdarg.h&gt;#include &quot;R0Hook.h&quot;#define dbgFilter &quot;Kvancy:&quot;typedef ULONG(*FuncPtr) (ULONG ComponentId, ULONG Level, PCSTR Format, ...);HOOK_MANAGER hookManager;ULONG myDbgPrintEx(ULONG ComponentId, ULONG Level, PCSTR Format, ...) { Unhook(&amp;hookManager); FuncPtr func = (FuncPtr)hookManager.target; kPrint(&quot;%s DbgPrintEx ComponentId:%lu,Level:%lu\\n&quot;,dbgFilter, ComponentId, Level); va_list args; va_start(args, Format); NTSTATUS s = func(ComponentId, Level, Format, args); va_end(args); ApplyHook(&amp;hookManager); return s;}void DriverUnload(PDRIVER_OBJECT pDriver) { kPrint(&quot;%s DriverUnload\\n&quot;, dbgFilter); Unhook(&amp;hookManager);}NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = DriverUnload; PVOID dbgPrintEx = DbgPrintEx; InitializeHookManager(&amp;hookManager, dbgPrintEx, myDbgPrintEx); ApplyHook(&amp;hookManager); DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, &quot;%s DriverEntry\\n&quot;,dbgFilter); return STATUS_SUCCESS;} 发现加载ace驱动后，有大量的level:5的调试信息输出 也就是说，程序通过设置调试信息的重要级别来控制调试信息是否正常输出，于是可以提高level级别来输出token2，那么最简单的方式就是hook之后修改level后传回去，编写代码hook测试下。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;ntifs.h&gt;#include &lt;ntdef.h&gt;#include &lt;ntstatus.h&gt;#include &lt;ntddk.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &quot;R0Hook.h&quot;#define dbgFilter &quot;Kvancy:&quot;typedef ULONG(*FuncPtr) (ULONG ComponentId, ULONG Level, PCSTR Format, ...);HOOK_MANAGER hookManager;char buffer[1024]; ULONG myDbgPrintEx(ULONG ComponentId, ULONG Level, PCSTR Format, ...) { Unhook(&amp;hookManager); FuncPtr func = (FuncPtr)hookManager.target; va_list args; va_start(args, Format); vsprintf(buffer, Format, args); va_end(args); NTSTATUS s = func(ComponentId, 0, &quot;%s&quot;, buffer);//修改level为0 ApplyHook(&amp;hookManager); return s;}void DriverUnload(PDRIVER_OBJECT pDriver) { kPrint(&quot;Kvancy: DriverUnload\\n&quot;); Unhook(&amp;hookManager);}NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = DriverUnload; PVOID dbgPrintEx = DbgPrintEx; InitializeHookManager(&amp;hookManager, dbgPrintEx, myDbgPrintEx); ApplyHook(&amp;hookManager); DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, &quot;Kvancy: DriverEntry\\n&quot;); return STATUS_SUCCESS;} 成功输出token2，但是根据题目要求是不能修改系统模块代码的，也就是说hook内核函数的方法不能过这道题，还是得想想别的方法。现在已知的ace.sys的行为就是驱动会在被加载之后做了某些操作会使得系统持续调用DbgPrintEx来输出token2，但是ace.sys其实做了某种操作后就被卸载掉了，如下图所示。 可以想到就是说驱动启动了一个线程或者进程，让该任务持续输出token2，创建完随后再卸载自己并且不停止这个线程或者进程。先枚举进程看看有没有奇怪的进程出现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586VOID WriteToFile(PUNICODE_STRING FilePath, PCHAR Data){ OBJECT_ATTRIBUTES objAttr; IO_STATUS_BLOCK ioStatusBlock; HANDLE fileHandle; NTSTATUS status; UNICODE_STRING unicodeFilePath; RtlInitUnicodeString(&amp;unicodeFilePath, FilePath-&gt;Buffer); InitializeObjectAttributes(&amp;objAttr, &amp;unicodeFilePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL); status = ZwCreateFile( &amp;fileHandle, FILE_APPEND_DATA | SYNCHRONIZE, &amp;objAttr, &amp;ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0 ); if (NT_SUCCESS(status)) { size_t dataLength = strlen(Data); ZwWriteFile(fileHandle, NULL, NULL, NULL, &amp;ioStatusBlock, Data, (ULONG)dataLength, NULL, NULL); ZwClose(fileHandle); } else { DbgPrint(&quot;Failed to create file: %08X\\n&quot;, status); }}VOID EnumProcesses(){ NTSTATUS status; PVOID buffer; ULONG bufferSize = 0x10000; // Initial buffer size, can grow if needed ULONG returnLength; CHAR logBuffer[1024]; UNICODE_STRING filePath; RtlInitUnicodeString(&amp;filePath, L&quot;\\\\??\\\\C:\\\\Users\\\\15386\\\\Desktop\\\\1.txt&quot;); buffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!buffer) { DbgPrint(&quot;Failed to allocate buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &amp;returnLength); if (status == STATUS_INFO_LENGTH_MISMATCH) { ExFreePool(buffer); bufferSize = returnLength; buffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!buffer) { DbgPrint(&quot;Failed to allocate larger buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &amp;returnLength); } if (NT_SUCCESS(status)) { PSYSTEM_PROCESS_INFORMATION processInfo = (PSYSTEM_PROCESS_INFORMATION)buffer; while (TRUE) { if (processInfo-&gt;ImageName.Buffer) { _snprintf(logBuffer, sizeof(logBuffer), &quot;Process ID: %lu, Name: %wZ\\n&quot;, (ULONG)(ULONG_PTR)processInfo-&gt;ProcessId, &amp;processInfo-&gt;ImageName); } else { _snprintf(logBuffer, sizeof(logBuffer), &quot;Process ID: %lu, Name: [System Process]\\n&quot;, (ULONG)(ULONG_PTR)processInfo-&gt;ProcessId); } WriteToFile(&amp;filePath, logBuffer); if (processInfo-&gt;NextEntryOffset == 0) break; processInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)processInfo + processInfo-&gt;NextEntryOffset); } } ExFreePool(buffer);} 结果发现好像没有奇怪的进程被创建出来，那么有可能是驱动利用PsCreateSystemThread创建了一个内核线程。hookPsCreateSystemThread函数看看驱动加载时是否调用了这个函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;ntifs.h&gt;#include &lt;ntdef.h&gt;#include &lt;ntstatus.h&gt;#include &lt;ntddk.h&gt;#include &lt;stdarg.h&gt;#include &quot;R0Hook.h&quot;#define dbgFilter &quot;Kvancy:&quot;typedef ULONG(*FuncPtr) ( PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);HOOK_MANAGER hookManager;NTSTATUS myPsCreateSystemThread( PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext){ Unhook(&amp;hookManager); FuncPtr func = (FuncPtr)hookManager.target; kPrint(&quot;%s myPsCreateSystemThread StartRoutine:%p\\n&quot;, dbgFilter, StartRoutine); NTSTATUS s = func(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, StartRoutine, StartContext); ApplyHook(&amp;hookManager); return s;}void DriverUnload(PDRIVER_OBJECT pDriver) { kPrint(&quot;%s DriverUnload\\n&quot;, dbgFilter); Unhook(&amp;hookManager);}NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = DriverUnload; PVOID dbgPrintEx = PsCreateSystemThread; InitializeHookManager(&amp;hookManager, dbgPrintEx, myPsCreateSystemThread); ApplyHook(&amp;hookManager); DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, &quot;%s DriverEntry\\n&quot;, dbgFilter); return STATUS_SUCCESS;} 发现在token2输出前确实有PsCreateSystemThread函数调用，虽然不确定是不是ace.sys创建的。在windbg里反汇编看看线程函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687880: kd&gt; u FFFFBA0729013DB0 l 100ffffba07`29013db0 488bc4 mov rax,rspffffba07`29013db3 48895808 mov qword ptr [rax+8],rbxffffba07`29013db7 48897818 mov qword ptr [rax+18h],rdiffffba07`29013dbb 4c897020 mov qword ptr [rax+20h],r14ffffba07`29013dbf 55 push rbpffffba07`29013dc0 488d68a1 lea rbp,[rax-5Fh]ffffba07`29013dc4 4881eca0000000 sub rsp,0A0hffffba07`29013dcb 48bf4e93328b546b331e mov rdi,1E336B548B32934Ehffffba07`29013dd5 49bed520794add1d6d4b mov r14,4B6D1DDD4A7920D5hffffba07`29013ddf 0f57c0 xorps xmm0,xmm0ffffba07`29013de2 488d4d37 lea rcx,[rbp+37h]ffffba07`29013de6 0f114537 movups xmmword ptr [rbp+37h],xmm0ffffba07`29013dea e8d1030000 call ffffba07`290141c0ffffba07`29013def 48b8a14f122fb3276d4b mov rax,4B6D27B32F124FA1hffffba07`29013df9 4c8d45e7 lea r8,[rbp-19h]ffffba07`29013dfd 4889456f mov qword ptr [rbp+6Fh],raxffffba07`29013e01 ba05000000 mov edx,5ffffba07`29013e06 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e0a 33c9 xor ecx,ecxffffba07`29013e0c 488945e7 mov qword ptr [rbp-19h],raxffffba07`29013e10 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e14 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e18 488945ef mov qword ptr [rbp-11h],raxffffba07`29013e1c 4c89756f mov qword ptr [rbp+6Fh],r14ffffba07`29013e20 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e24 48894517 mov qword ptr [rbp+17h],raxffffba07`29013e28 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e2c 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e30 660f6f45e7 movdqa xmm0,xmmword ptr [rbp-19h]ffffba07`29013e35 4889451f mov qword ptr [rbp+1Fh],raxffffba07`29013e39 660fef4517 pxor xmm0,xmmword ptr [rbp+17h]ffffba07`29013e3e 488b0543330000 mov rax,qword ptr [ffffba07`29017188]ffffba07`29013e45 660f7f45e7 movdqa xmmword ptr [rbp-19h],xmm0ffffba07`29013e4a ff15c8210000 call qword ptr [ffffba07`29016018]ffffba07`29013e50 33db xor ebx,ebxffffba07`29013e52 48b8f0104b32dd1d6d4b mov rax,4B6D1DDD324B10F0hffffba07`29013e5c 4c8d45f7 lea r8,[rbp-9]ffffba07`29013e60 4889456f mov qword ptr [rbp+6Fh],raxffffba07`29013e64 ba05000000 mov edx,5ffffba07`29013e69 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e6d 33c9 xor ecx,ecxffffba07`29013e6f 488945f7 mov qword ptr [rbp-9],raxffffba07`29013e73 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e77 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e7b 488945ff mov qword ptr [rbp-1],raxffffba07`29013e7f 4c89756f mov qword ptr [rbp+6Fh],r14ffffba07`29013e83 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e87 48894527 mov qword ptr [rbp+27h],raxffffba07`29013e8b 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e8f 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e93 660f6f45f7 movdqa xmm0,xmmword ptr [rbp-9]ffffba07`29013e98 440fb64c1d37 movzx r9d,byte ptr [rbp+rbx+37h]ffffba07`29013e9e 4889452f mov qword ptr [rbp+2Fh],raxffffba07`29013ea2 660fef4527 pxor xmm0,xmmword ptr [rbp+27h]ffffba07`29013ea7 488b05da320000 mov rax,qword ptr [ffffba07`29017188]ffffba07`29013eae 660f7f45f7 movdqa xmmword ptr [rbp-9],xmm0ffffba07`29013eb3 ff155f210000 call qword ptr [ffffba07`29016018]ffffba07`29013eb9 48ffc3 inc rbxffffba07`29013ebc 4883fb10 cmp rbx,10hffffba07`29013ec0 7c90 jl ffffba07`29013e52ffffba07`29013ec2 48b8df20794add1d6d4b mov rax,4B6D1DDD4A7920DFhffffba07`29013ecc 4c8d4507 lea r8,[rbp+7]ffffba07`29013ed0 4889456f mov qword ptr [rbp+6Fh],raxffffba07`29013ed4 ba05000000 mov edx,5ffffba07`29013ed9 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013edd 33c9 xor ecx,ecxffffba07`29013edf 48894507 mov qword ptr [rbp+7],raxffffba07`29013ee3 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013ee7 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013eeb 4889450f mov qword ptr [rbp+0Fh],raxffffba07`29013eef 4c89756f mov qword ptr [rbp+6Fh],r14ffffba07`29013ef3 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013ef7 48894547 mov qword ptr [rbp+47h],raxffffba07`29013efb 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013eff 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013f03 660f6f4507 movdqa xmm0,xmmword ptr [rbp+7]ffffba07`29013f08 4889454f mov qword ptr [rbp+4Fh],raxffffba07`29013f0c 660fef4547 pxor xmm0,xmmword ptr [rbp+47h]ffffba07`29013f11 488b0570320000 mov rax,qword ptr [ffffba07`29017188]ffffba07`29013f18 660f7f4507 movdqa xmmword ptr [rbp+7],xmm0ffffba07`29013f1d ff15f5200000 call qword ptr [ffffba07`29016018]ffffba07`29013f23 b9ce0a0000 mov ecx,0ACEhffffba07`29013f28 e833e9ffff call ffffba07`29012860ffffba07`29013f2d e9adfeffff jmp ffffba07`29013ddfffffba07`29013f32 cc int 3ffffba07`29013f33 cc int 3ffffba07`29013f34 4152 push r10 导入到ida里看伪代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __noreturn sub_180005148(){ __m128i v0; // xmm0 __int64 i; // rbx __m128i v2; // xmm0 __int64 v3; // r9 __m128i v4; // xmm0 __m128i v5; // [rsp+30h] [rbp-19h] BYREF __m128i v6; // [rsp+40h] [rbp-9h] BYREF __m128i v7; // [rsp+50h] [rbp+7h] BYREF __m128i v8; // [rsp+60h] [rbp+17h] __m128i v9; // [rsp+70h] [rbp+27h] __int128 v10; // [rsp+80h] [rbp+37h] BYREF __m128i v11; // [rsp+90h] [rbp+47h] while ( 1 ) { v10 = 0i64; ((void (__fastcall *)(__int128 *))((char *)&amp;loc_180005556 + 2))(&amp;v10); v5.m128i_i64[0] = 0x4B6D27B32F124FA1i64; v5.m128i_i64[1] = 0x1E336B548B32934Ei64; v8.m128i_i64[0] = 0x4B6D1DDD4A7920D5i64; v0 = _mm_load_si128(&amp;v5); v8.m128i_i64[1] = 0x1E336B548B32934Ei64; v5 = _mm_xor_si128(v0, v8); MEMORY[0x31305A8047353130](0i64, 5i64, &amp;v5); for ( i = 0i64; i &lt; 16; ++i ) { v6.m128i_i64[0] = 0x4B6D1DDD324B10F0i64; v6.m128i_i64[1] = 0x1E336B548B32934Ei64; v9.m128i_i64[0] = 0x4B6D1DDD4A7920D5i64; v2 = _mm_load_si128(&amp;v6); v3 = *((unsigned __int8 *)&amp;v10 + i); v9.m128i_i64[1] = 0x1E336B548B32934Ei64; v6 = _mm_xor_si128(v2, v9); MEMORY[0x31305A8047353130](0i64, 5i64, &amp;v6, v3); } v7.m128i_i64[0] = 0x4B6D1DDD4A7920DFi64; v7.m128i_i64[1] = 0x1E336B548B32934Ei64; v11.m128i_i64[0] = 0x4B6D1DDD4A7920D5i64; v4 = _mm_load_si128(&amp;v7); v11.m128i_i64[1] = 0x1E336B548B32934Ei64; v7 = _mm_xor_si128(v4, v11); MEMORY[0x31305A8047353130](0i64, 5i64, &amp;v7); sub_180003BF8(2766i64); }} 好像是做了一个字符串解密然后输出的操作，浅浅用python跑一下解析字符串验证猜想。 1234567891011121314151617181920212223242526def hex_xor_to_string(a, b): result = a ^ b hex_str = hex(result)[2:] if len(hex_str) % 2 != 0: hex_str = '0' + hex_str result_str = ''.join(chr(int(hex_str[i:i+2], 16)) for i in range(0, len(hex_str), 2)) return result_strx1 = 0x4B6D27B32F124FA1x2 = 0x1E336B548B32934Ey1 = 0x4B6D1DDD4A7920D5y2 = 0x1E336B548B32934Eresult1 = hex_xor_to_string(x1, y1)result2 = hex_xor_to_string(x2, y2)print(&quot;Result 1:&quot;, result1)print(&quot;Result 2:&quot;, result2)res = result1[::-1] + result2[::-1]print(res) 打印出了token基本上确定了这个线程就是打印token的线程，现在就是要想怎么patch这个线程函数使得token能够输出出来。 ) 这里有个mov edx,5语句，将DbgPrintEx函数的level设置成5，可以考虑patch这个语句，将5改成0，那么只需要patch一个字节，共三处。但是又要怎么patch呢，首先不能通过现在这种方式hook PsCreateSystemThread函数调用来确定StartRoutine地址（题目要求不能修改系统模块代码），也就是说得想另外一个办法确定这个线程的地址，然后通过偏移来确定需要patch的地址。 那么怎么确定这个线程地址呢，如果通过ZwQuerySystemInformation枚举内核模块然后枚举模块下的所有线程的话，已经卸载了的ace.sys模块还能被枚举到么？问了下GPT好像是不能的，还可以考虑用StartRoutine地址的后几位做特征，匹配所有线程的开始地址的后几位，但是这种方式又感觉怕遇到地址特征一模一样的，感觉还是不大行。又问GPT怎么寻找到某个内核线程，得到答复是除了ZwQuerySystemInformation枚举，还有通过PsLookupThreadByThreadId函数从进程id和线程id查找的。 那么线程id和进程id又从哪获取呢？因为之前hook过PsCreateSystemThread函数，翻阅文档找到了一个ClientId参数，这个参数指向接收新线程的客户端标识符的结构，即一个pid，一个tid，但是pid，tid应该都是系统分配的吧，能是一个固定值么？hook一下看看输出 诶，tid貌似是系统分配的，但是pid一直都是4，很奇怪，pid=4代表的是什么进程呢？之前刚好枚举过进程来找有没有新进程创建，现在正好能派上用场。 貌似是一个系统进程，GPT了一下发现原来如果驱动程序通过内核模式创建系统线程（使用PsCreateSystemThread），这些线程通常会在系统进程下运行，PID为4。原来如此，驱动程序和进程是一个级别的，但是驱动程序创建的这个线程是在系统进程之下的，而不是属于驱动模块，只是线程起始地址隶属于模块地址空间的，驱动卸载并不影响线程的运行。 这样的话，我们要找的线程因为模块被卸载了，所以它不在所有模块地址空间内，只要枚举所有系统进程pid=4下的所有线程，然后通过判断线程的起始地址是否在所有模块地址之内，即可判断它是否是我们要找的线程。这下思路就通了，开始编写代码实现patch。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &quot;header.h&quot;PVOID MoudleBaseAddress[1024];ULONG64 MoudleSize[1024];ULONG ModuleCount = 0;ULONG Offset1 = 0x52, Offset2 = 0xB5, Offset3 = 0x125;BOOLEAN IsAddressInKnownModules(PVOID Address, PVOID* ModuleBaseAddresses, ULONG64* ModuleSize, ULONG ModuleCount){ for (size_t i = 0; i &lt; ModuleCount; i++) { if (Address &gt;= ModuleBaseAddresses[i] &amp;&amp; Address &lt; (ULONG64)ModuleBaseAddresses[i] + ModuleSize[i]) { return TRUE; } } return FALSE;}PVOID EnumSystemModulesForProcess(HANDLE TargetProcessId){ NTSTATUS status; ULONG bufferSize = 0x10000; PVOID processBuffer = NULL; PVOID moduleBuffer = NULL; ULONG returnLength; // 查询进程信息 processBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!processBuffer) { DbgPrint(&quot;Failed to allocate buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, processBuffer, bufferSize, &amp;returnLength); if (status == STATUS_INFO_LENGTH_MISMATCH) { ExFreePool(processBuffer); bufferSize = returnLength; processBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!processBuffer) { DbgPrint(&quot;Failed to allocate larger buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, processBuffer, bufferSize, &amp;returnLength); } // 查询模块信息 moduleBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'modl'); if (!moduleBuffer) { DbgPrint(&quot;Failed to allocate buffer for module information\\n&quot;); ExFreePool(processBuffer); return; } status = ZwQuerySystemInformation(SystemModuleInformation, moduleBuffer, bufferSize, &amp;returnLength); if (status == STATUS_INFO_LENGTH_MISMATCH) { ExFreePool(moduleBuffer); bufferSize = returnLength; moduleBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'modl'); if (!moduleBuffer) { DbgPrint(&quot;Failed to allocate larger buffer for module information\\n&quot;); ExFreePool(processBuffer); return; } status = ZwQuerySystemInformation(SystemModuleInformation, moduleBuffer, bufferSize, &amp;returnLength); } // 遍历模块信息 if (NT_SUCCESS(status)) { PSYSTEM_MODULE_INFORMATION moduleInfo = (PSYSTEM_MODULE_INFORMATION)moduleBuffer; ModuleCount = moduleInfo-&gt;ModulesCount; for (ULONG i = 0; i &lt; moduleInfo-&gt;ModulesCount; i++) { PSYSTEM_MODULE_INFORMATION_ENTRY moduleEntry = &amp;moduleInfo-&gt;Modules[i]; MoudleBaseAddress[i] = moduleEntry-&gt;Base; MoudleSize[i] = moduleEntry-&gt;Size; } } // 遍历进程信息 if (NT_SUCCESS(status)) { PSYSTEM_PROCESS_INFORMATION processInfo = (PSYSTEM_PROCESS_INFORMATION)processBuffer; while (TRUE) { if (processInfo-&gt;ProcessId == TargetProcessId) { PSYSTEM_THREAD_INFORMATION threadInfo = (PSYSTEM_THREAD_INFORMATION)(processInfo + 1); for (ULONG i = 0; i &lt; processInfo-&gt;NumberOfThreads; i++) { if (!IsAddressInKnownModules(threadInfo[i].StartAddress, MoudleBaseAddress, MoudleSize, ModuleCount)) { DbgPrint(&quot;Find it:%p\\n&quot;,threadInfo[i].StartAddress); return threadInfo[i].StartAddress; } } break; } if (processInfo-&gt;NextEntryOffset == 0) break; processInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)processInfo + processInfo-&gt;NextEntryOffset); } } // 清理分配的内存 ExFreePool(processBuffer); ExFreePool(moduleBuffer); return 0;}VOID UnloadDriver(PDRIVER_OBJECT DriverObject) { KdPrint((&quot;Driver Unloaded\\n&quot;));}NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = UnloadDriver; KdPrint((&quot;Driver Loaded\\n&quot;)); HANDLE targetPid = (HANDLE)4; // 系统进程的 PID PVOID targetAddress = EnumSystemModulesForProcess(targetPid); UCHAR valueToWrite = 0x00; // 要写入的字节值 UCHAR valueToRead = 0x05; // 要写入的字节值 ULONG numHasChanged = 0x00; if (*(PUCHAR)((ULONG64)targetAddress + Offset1) == valueToRead) { *(PUCHAR)((ULONG64)targetAddress + Offset1) = valueToWrite; numHasChanged++; } if (*(PUCHAR)((ULONG64)targetAddress + Offset2) == valueToRead) { *(PUCHAR)((ULONG64)targetAddress + Offset2) = valueToWrite; numHasChanged++; } if (*(PUCHAR)((ULONG64)targetAddress + Offset3) == valueToRead) { *(PUCHAR)((ULONG64)targetAddress + Offset3) = valueToWrite; numHasChanged++; } DbgPrint(&quot;numHasChanged:%d\\n&quot;, numHasChanged); return STATUS_SUCCESS;} 成功输出token2 （三）解题过程题目要求： 编写程序，运行时修改尽量少的内存，让shellcode 往自行指定的位置写入token1成功。（满分3分） 要求任意位置，也就是要修改CreateFileA函数的第一个参数的值，根据之前分析的C:\\2024GameSafeRace.token1字符串是由十六进制异或得到的，也就是下面这些 可以考虑的是patch这些十六进制数据，把异或的key改成0，然后密文改成明文即可，因为明文异或0还是明文，但是考虑到要尽量修改少量的内存，我们最好还是保持key不变，自定义密文解密到我们所要的文件地址。跑个python脚本解出新的密文，得到新的密文，接着找到密文所在文件的偏移然后patch即可，给出解题代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//dllmain.cpp#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _KDEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];typedef BOOL(WINAPI* WriteProcessMemory_t)( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten );WriteProcessMemory_t TrueWriteProcessMemory = NULL;BOOLWINAPIHookWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten){ if (nSize == 4506624 &amp;&amp; *((PUCHAR)lpBuffer + 0x7171) == 0x3) { *((PUCHAR)lpBuffer + 0x7171) = 0x4; *(PULONG64)((ULONG64)lpBuffer + 0x7082) = 0x94e7c2136acc0e5c;// *(PULONG64)((ULONG64)lpBuffer + 0x7093) = 0x8207c5d1af9f3860; *(PULONG64)((ULONG64)lpBuffer + 0x70F1) = 0xa905cca9edcb138c; *(PULONG64)((ULONG64)lpBuffer + 0x7108) = 0xa753b8236c56809a; //C:\\Users\\15386\\Desktop\\flag.txt DBGMGEBOX(&quot;Hook Success!\\n&quot;); } return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); TrueWriteProcessMemory = (WriteProcessMemory_t)DetourFindFunction(&quot;kernel32.dll&quot;, &quot;WriteProcessMemory&quot;); DetourAttach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; } return TRUE;} 注入hook成功后，成功在桌面的flag.txt输出token1","link":"/2024/09/23/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8PC%E5%88%9D%E8%B5%9B/"},{"title":"CS2外置透视辅助实现","text":"完整源代码：https://github.com/Kvancy/CS2-ESP-Cheat 先思考一个问题，如果要做透视，我们需要什么？ 首先是敌人的世界坐标，有了敌人世界坐标我们才能进行转换和绘制； 其次是敌人和队友的标识符，有个这个我们才能过滤掉友军，只针对敌人进行绘制 还有一个就是血量，通过判断敌人是否存活来进行过滤掉死去的敌人，不对死去的进行绘制 按照惯例，做外挂功能的第一步要先找到基址和偏移，哪些量的基址和偏移？上面分析的这三个至少要有吧 基址寻找再思考一个问题，关于坐标，敌军友军的标识符，血量的内存布局可能是怎么样的？ 根据C++面向对象编程中的内存布局，我们能做一些猜测 CS2这么大的游戏，大概率是面向对象编程 根据编程经验，游戏世界往往会存在一个或多个抽象类，而我们要研究的角色，可能只是一个子类 坐标，血量，标识符可能不尽是角色类的特有成员，内存布局可能存在较大差异 揣着这些猜测，开始寻找基址和偏移 进入练习模式打开控制台（~），输入如下指令 sv_cheats ${0/1}$; //舞弊方式，0表明关掉，1表明开启(任意挪动指令必须开启舞弊方式) bot_stop ${0/1}$; //bot终止行为，0表明关掉BOT逐渐主题活动，1表明开启BOT终止主题活动 mp_roundtime_defuse {n}$ ;//设置每回合的时间 mp_restartgame 1 //重启该回合 打开CE针对角色血量进行搜索，定位到血量地址，找到如下可能的地址。 利用二分法锁定内存地址的值，打开控制台输入 hurtme 1指令，观察哪一个地址锁定后血量不再下降，或者用修改数据的方法看看哪个是真实地址，哪些是随着真实地址变动的“虚假地址”。 找到真实血量内存地址。 进行指针扫描，设置最大偏移地址5560和最大偏移层数5，经验所得，大多数游戏可以用这两个值找到，找不到的时候适当调整即可。 找到294个指针路径，为了进一步筛选，继续hurt me 修改血量，通过指针扫描器-&gt;重新扫描内存-&gt;要查找的数值，设置当前血量值，重新扫描。 得到235个指针路径，同理可以进行多次筛选，最终测得233个指针路径。 此时关闭游戏（记得提前保存好ptr文件，一般扫描后就保存了），重新打开游戏。再次重新扫描内存，进一步筛选得到40个指针路径 可以看到第四层偏移全是2A8，对应的是血量在所属类的偏移值，到这我们基本就可以利用其中之一作为自己角色血量的基址和偏移了 这里选择最后一条 血量偏移 0x2A8 0xC0 0x8 0x10 0x50 “server.dll”+01343108 我们继续找人物坐标的基址和偏移，因为在三维世界里，二维坐标X，Y的方向不是很好确认，但是Z坐标一般都是一样的，往上走，Z坐标增加，往下走，Z坐标减小，有些游戏可能会反过来，但是不影响，只是稍微更麻烦一点。只要找到了三个坐标其中之一，另外两个也就在附近了（存放在一个结构体中），这里我们找Z坐标。 我们到这个地点，有个上下坡的地方，方便修改Z坐标。 接着就是一顿CE搜索，我这里最终筛到300多个地址，实在是筛选不下去了，都像是Z坐标，接着按照二分法，一半锁定一半不锁定，去找一个地址，锁定住之后角色跳不起来，筛选到如下地址 尝试修改数据测试真实性,修改成-20000 这tm给我干哪来了我擦了，准备下包！修改一下Z坐标回到地面 擦，修改多了，完了，掉下去就死了，寄。。。 但是现在基本确认了这个地址是真实Z的坐标，其他的只是因变量，对这个地址进行指针扫描。扫描到93条指针路径，进一步按之前步骤筛选，找到一个能用的 接着我们在这个地址观察一下附近是否会出现X，Y坐标，发现前面两个就是X,Y坐标，基本确认了我们角色的基址和偏移 因为这个只是我们的坐标，其他角色的坐标还没去搜索，挨个搜索肯定不现实，那还有什么办法去快速找到其他角色的基址和偏移呢？ 根据我们的一点点开发经验可以猜测游戏里面大概有这么一份代码模型 1234567891011class Game{ int time;//随便举的例子 Player player[10];}class Player{ float blood; int TeamNum; Point3D pos;} 根据这个猜想，只要我们获得了Player的内存大小，我们就可以根据我们角色的地址枚举出其他角色的地址，从而获取其他角色的位置属性。嘶，但是这个角色类的内存大小貌似不好求。我又想到一个方法，如果角色内存大小不是很大的话，我们可以在CE中通过在我们的坐标附近去寻找，是否还有像坐标的地址，如果找到了，那么很可能是其他角色的坐标，我们就可以直接两个坐标地址相减获取角色内存大小，浅试一下。 找了一下，并没有找到，显然这招对这游戏并不是一个好方法，可能CS2是用类指针数组去存十个人物地址的，也可能是用链表去存的，这方法还是太笨了。只能想另一种方式了。 还记得我们最开始的C++内存布局揣测么，那既然我们已经找到了基地址和五层偏移，那就意味着我们角色的地址很可能就在这个基地址的相对四层或者三层（或者更少）偏移计算得到，那我们假设，游戏的十个角色是被new出来的，也就是用类指针数组存储十个人物地址的，那我们的角色地址找到之后，偏移8个字节（64位的游戏），那是不是就是其他角色的类指针？再试一次，如下是我们之前找到的基地址和偏移 试着修改第一层到第四层的偏移值，修改+8。 到第二层偏移+8时，刚好对应浮点数-120，符合地图的Z坐标范围，点开内存看一眼之前是不是X,Y坐标 好像是，让机器人动起来试一试 没错了！继续+8或者-8定位另外八个角色的第二层偏移。 直到第二层偏移为60时，内存指向空，所以十个人物的角色第二层偏移是10,18,20,28,30,38,40,48,50,58（十六进制）,刚好对应十个人物角色 至此，人物位置分析完成，获取的基地址和偏移为 坐标偏移 0x128 0x38 0x70 0x10 0x50 “server.dll”+01343108 突然忘了，其他人物血量还没定位，但是这样一看，其他人物的血量地址也出来了，因为血量的前两层偏移和坐标前两层偏移相同，也只需要在第二层偏移（m+8*n）即可。 继续第三个地址寻找，队伍标识符，按经验推测，会将敌军还是友军置为bool类型，只需要判断01就可以区分保卫者和潜伏者，但是我在控制台输入的时候，他会告诉我这些信息。 貌似就是队伍标识符了，但是我们海狮要确定这个的基地址和偏移，根据之前两个基地址和偏移，我们可以进行推测基地址和前两个偏移值都是相同的，只要获取后面的偏移即可。继续用CE进行搜索吧，这里要利用CS2的这个功能去转换阵营，要不然没法CE搜索 先假设潜伏者为2，保卫者为3，进行CE搜索，找到这些地址， 再尝试修改这些数据，修改一次攻击一下友军，看一下提示是否想同，直到出现这个画面 我穿着保卫服却显示我在潜伏者，并且视保卫者为敌人，对这个地址进行指针扫描 进行指针扫描，找到前两层偏移一样的并进行记录 发现前两层偏移并没有一样的，如果用这些基地址和偏移的话，我们就还得去找其他角色地址的偏移，那太麻烦了，根据这个最后的偏移都是314，试着将我们得到的两个基地址和偏移的最后一个偏移分别改成314看看是否对应结果3，发现带入血量的最后一个偏移时结果对应。 看来血量和队伍标识符是同属一个子类的，所以队伍标识符的基地址和偏移我们拿到了，这里做一下记录 队伍标识符偏移 0x314 0xc0 0x08 0x10 0x50 “server.dll”+01343108 接着进行视图矩阵的搜索，搜索方法也很简单，只要搜索矩阵中16个浮点数的其中之一就可以了。我们可以针对某个值进行搜索，这个值会在-1.0-1.0之间（也可能稍微超过一点点）,当视角朝向天空是，该值趋近于1.0，朝向地面时，该值趋近于-1.0，根据这个我们可以控制角色看向天空，然后搜索0.8-1.2之间的数值，同理朝向地面，我们搜索-0.8–1.2之间的数值，还可以变动视角搜索变动的值，我这里就是用这种方法进行搜索视图矩阵的。 两次搜索就能筛选到40000数值，接着筛选。最后搜索到还剩1200个地址， 但是我们看见了绿色的基址，把这些基址复制下来一一查看内存布局，看看是否有矩阵特征。 看这三个矩阵，随着视角都是会变动的，但是都是不对的，比如第一个矩阵，有些数据保持不变，不显红色，排除；第二个矩阵，只是一个3*4的矩阵，排除；第三个矩阵，第一行和第二行的前三个数据不符合矩阵数据规范，超过了1.0，排除。一直到这个内存地址 发现数据刚好符合规范并且是4*4的矩阵，记录下该地址 视图矩阵偏移 client.dll+19CB4D0 到这基址和偏移寻找就完成了，接着开始写我们的透视辅助代码 代码实现main.cpp 1234567891011121314151617181920#include &quot;kWindow.h&quot;#include &quot;kGame.h&quot;#include &quot;kPlayerPawn.h&quot;#define isWorldwide 1#if isWorldwide#define WINDOWNAME &quot;Counter-Strike 2&quot;#elsedefine WINDOWNAME &quot;反恐精英：全球攻势&quot;#endifkWindow* window = nullptr;kGame* game = nullptr;kRender* render = nullptr;int main(){ window = new kWindow(WINDOWNAME); game = new kGame(TEXT(&quot;cs2.exe&quot;), window-&gt;getRect()); window-&gt;msgLoop(game); } msgLoop 123456789101112131415void kWindow::msgLoop(kGame* game){ kRender* render = new kRender(hWnd); MSG msg; ZeroMemory(&amp;msg, sizeof(msg)); while (msg.message != WM_QUIT) { if (PeekMessage(&amp;msg, NULL, 0U, 0U, PM_REMOVE)) { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } else { doCheat(render,game); } }} doCheat 1234567891011121314151617void kWindow::doCheat(kRender* render, kGame* game){ game-&gt;refreshData(); game-&gt;showAllPlayer(); render-&gt;beginRender(); for (size_t i = 0; i &lt; 10; i++) { if (game-&gt;m_playPawn[i].getTeamNum() == game-&gt;m_playPawn[0].getTeamNum()) continue; if (!game-&gt;m_playPawn[i].isAlive()) continue; point2D pos = game-&gt;world2screen(game-&gt;getPlayerPawnPos(i), game-&gt;getMatrix()); point2D posHead = game-&gt;world2screen(game-&gt;m_playPawn[i].getPosHead(), game-&gt;getMatrix()); render-&gt;drawRectangle(pos.x, (pos.y + posHead.y) / 2, 60, posHead.y - pos.y); } render-&gt;endRender();} refreshData 123456789101112131415161718192021222324252627282930313233343536bool kGame::refreshData(){ auto server = cs2-&gt;get_module_handle(TEXT(&quot;server.dll&quot;)); auto client = cs2-&gt;get_module_handle(TEXT(&quot;client.dll&quot;)); DWORD64 player = 0; if (!cs2-&gt;read&lt;DWORD64&gt;(server + 0x1343108, player)) return false; if (!cs2-&gt;read&lt;DWORD64&gt;(player + 0x50, player)) return false; DWORD64 TeamNum = 0; for (size_t i = 0; i &lt; 10; i++) { if (!cs2-&gt;read&lt;DWORD64&gt;(player + 0x10 + 0x08*i, TeamNum)) return false; if (!cs2-&gt;read&lt;DWORD64&gt;(TeamNum + 0x08, TeamNum)) return false; if (!cs2-&gt;read&lt;DWORD64&gt;(TeamNum + 0xC0, TeamNum)) return false; if (!cs2-&gt;read&lt;int&gt;(TeamNum + 0x314, m_playPawn[i].m_iTeamNum)) return false; } DWORD64 Pos = 0; for (size_t i = 0; i &lt; 10; i++) { if (!cs2-&gt;read&lt;DWORD64&gt;(player + 0x10 + 0x08 * i, Pos)) return false; if (!cs2-&gt;read&lt;DWORD64&gt;(Pos + 0x70, Pos)) return false; if (!cs2-&gt;read&lt;DWORD64&gt;(Pos + 0x38, Pos)) return false; if (!cs2-&gt;read&lt;point3D&gt;(Pos + 0x120, m_playPawn[i].m_pPos)) return false; } DWORD64 Health = 0; for (size_t i = 0; i &lt; 10; i++) { if (!cs2-&gt;read&lt;DWORD64&gt;(player + 0x10 + 0x08 * i, Health)) return false; if (!cs2-&gt;read&lt;DWORD64&gt;(Health + 0x08, Health)) return false; if (!cs2-&gt;read&lt;DWORD64&gt;(Health + 0xC0, Health)) return false; if (!cs2-&gt;read&lt;int&gt;(Health + 0x2A8, m_playPawn[i].m_iHealth)) return false; } if (!cs2-&gt;read&lt;Matrix4x4&gt;(client + 0x19CB4D0, m_mViewMatrix)) return false;} 效果展示","link":"/2024/04/23/CS2/"},{"title":"Rookie diary","text":"除了编程和逆向之外的常用工具的使用，记载一些其他常用的工具的使用过程防止自己继续花时间找解决办法 1. GitHub: github已经创建仓库后，将本地文件上传： 在本地文件夹中右键 Git Bash Here 输入 git init 在本地建立.git文件夹 输入 git remote add origin git@github.com:Kvancy/GameHall.git 设置远程仓库，origin后面地址从仓库SSH块复制 输入 git add . 输入 git commit -m &quot;版本号&quot; 输入 git checkout -b main 将上传分支设置为main(也可以是其他，自定义) 输入 git push -u origin main 上传文件到main分支 删除分支 远端分支 git push origin --delete [branch_name] 本地分支 git branch [branch_name] -d 查看分支 查看本地分支 git branch 查看远程分支 git branch -r 查看本地和远程分支 git branch -a 更换远程仓库地址 git remote -v #查看远端地址 git remote #查看远端仓库名 git remote set-url origin https://gitee.com/xx/xx.git (新地址) git push报错，显示仓库中有一部分代码，要先pull 参考链接 方法一： git pull origin [main]分支名 重新add和commit相应文件 git push origin [main] 分支名 方法二： 强推： git push -f origin [main] 分支名 2. VScode的环境配置： launch.json文件配置（调试的配置，必须先编译得到exe） 12345678910111213141516171819202122232425262728293031{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;C/C++: g++.exe 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true,//设置成true才能调试 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:\\\\MinGW\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot; }, ], &quot;version&quot;: &quot;2.0.0&quot;} tasks.json文件配置（编译作用）,这里默认g++，不需要动，在终端-配置任务中修改 12345678910111213141516171819202122232425262728{ &quot;tasks&quot;: [ { &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, &quot;command&quot;: &quot;C:\\\\MinGW\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}&quot; }, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;detail&quot;: &quot;调试器生成的任务。&quot; } ], &quot;version&quot;: &quot;2.0.0&quot;} setting.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061{ &quot;C_Cpp_Runner.cCompilerPath&quot;: &quot;C:/MinGW/bin/g++.exe&quot;, &quot;C_Cpp_Runner.cppCompilerPath&quot;: &quot;g++&quot;, &quot;C_Cpp_Runner.debuggerPath&quot;: &quot;gdb&quot;, &quot;C_Cpp_Runner.cStandard&quot;: &quot;c11&quot;, &quot;C_Cpp_Runner.cppStandard&quot;: &quot;gnu++14&quot;, &quot;C_Cpp_Runner.msvcBatchPath&quot;: &quot;&quot;, &quot;C_Cpp_Runner.useMsvc&quot;: false, &quot;C_Cpp_Runner.warnings&quot;: [ &quot;-Wall&quot;, &quot;-Wextra&quot;, &quot;-Wpedantic&quot;, &quot;-Wshadow&quot;, &quot;-Wformat=2&quot;, &quot;-Wcast-align&quot;, &quot;-Wconversion&quot;, &quot;-Wsign-conversion&quot;, &quot;-Wnull-dereference&quot; ], &quot;C_Cpp_Runner.msvcWarnings&quot;: [ &quot;/W4&quot;, &quot;/permissive-&quot;, &quot;/w14242&quot;, &quot;/w14287&quot;, &quot;/w14296&quot;, &quot;/w14311&quot;, &quot;/w14826&quot;, &quot;/w44062&quot;, &quot;/w44242&quot;, &quot;/w14905&quot;, &quot;/w14906&quot;, &quot;/w14263&quot;, &quot;/w44265&quot;, &quot;/w14928&quot; ], &quot;C_Cpp_Runner.enableWarnings&quot;: true, &quot;C_Cpp_Runner.warningsAsError&quot;: false, &quot;C_Cpp_Runner.compilerArgs&quot;: [], &quot;C_Cpp_Runner.linkerArgs&quot;: [], &quot;C_Cpp_Runner.includePaths&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;C_Cpp_Runner.includeSearch&quot;: [ &quot;*&quot;, &quot;**/*&quot; ], &quot;C_Cpp_Runner.excludeSearch&quot;: [ &quot;**/build&quot;, &quot;**/build/**&quot;, &quot;**/.*&quot;, &quot;**/.*/**&quot;, &quot;**/.vscode&quot;, &quot;**/.vscode/**&quot; ], &quot;C_Cpp_Runner.useAddressSanitizer&quot;: false, &quot;C_Cpp_Runner.useUndefinedSanitizer&quot;: false, &quot;C_Cpp_Runner.useLeakSanitizer&quot;: false, &quot;C_Cpp_Runner.showCompilationTime&quot;: false, &quot;C_Cpp_Runner.useLinkTimeOptimization&quot;: false, &quot;C_Cpp_Runner.msvcSecureNoWarnings&quot;: false} c_cpp_properties 1234567891011121314151617181920{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;windows-clang-x86&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-clang-x86&quot;, &quot;compilerPath&quot;: &quot;C:/MinGW/bin/g++.exe&quot; } ], &quot;version&quot;: 4} 3. 虚拟机配置：bcdedit /set hypervisorlaunchtype off 4. 服务器博客搭建1. 登录宝塔面板 远程连接云服务器的控制台 访问宝塔面板的安全入口，可通过控制台 su root bt default 查询网址， 目前设置成了 47.97.68.254:1111/Kvancy 用户名是Kvancy 2. 本地下载hexo博客系统 curl --silent --location https://rpm.nodesource.com/setup_14.x|sudo bash yum -y install nodejs npm install hexo-cli -g hexo init blog cd blog/ npm install hexo server 默认4000端口没用的话，使用 hexo server -p5000指定端口，如果想直接通过ip访问博客，可以通过 hexo server -p80设置端口。也可以通过 /blog/node_modules/hexo-server/index.js修改port值从而修改默认端口号 有时候开启多个端口设置hexio会访问失败，通过 netstat -nultp查看所有端口号，kill -9 id id为进程id，杀死进程即可，kill - num 代表的意思如下 num 1 2 3 9 15 18 19 20 含义 进程重新被加载 删除进程在内存中的数据 删除鼠标在内存中的数据 强行结束单个进程 正常关闭进程 运行暂停的进程 暂停某个进程 把进程打入后台 3. 本地Hexo一键部署到远程服务器 参考链接 yum install -y wget &amp;&amp; wget -O install.sh https://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh ed8484bec 安装宝塔面板 yum install git 安装git adduser git 配置git用户 chmod 740 /etc/sudoers 赋予用户权限 ``vi /etc/sudoers 进入权限管理文件 root ALL=(ALL) ALL git ALL=(ALL) ALL 在这条上面加上这行 chmod 400 /etc/sudoers 修改sudoers文件权限 sudo passwd git 设置git 用户的密码，这里设置了 ‘root’ su - git 给用户添加ssh密钥，git mkdir -p ~/.ssh touch ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorzied_keys chmod 700 ~/.ssh vim ~/.ssh/authorized_keys 将ssh密钥粘贴进去，用于远程登录服务器 ssh -v git@你的 ip 地址 输入密码 即可成功登录云服务器 su root 创建一个git仓库，新建一个 post-receive 文件，用来存储本地的提交 cd /home/git git init --bare blog.git #在/home/git下创建新仓库blog.git chown git:git -R blog.git #给予git用户权限 cd blog.git/hooks vim post-receive 配置钩子文件，使得每次本地上传时，远程自动同步下载 #!/bin/bash `git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f` 写入钩子代码 chmod +x /home/git/blog.git/hooks/post-receive 授予钩子可执行权限 以上是服务器配置 ------ deploy: #配置本地hexo的_config.yml文件 type: git repo: root@你的ip地址:/home/git/blog.git #仓库地址 branch: master #分支 12345614. ```js #上传到远程服务器端git仓库，远程通过钩子自动下载同步 #这些也是部署之后每次上传时执行的命令 hexo clean hexo g -d #编译并部署， hexo s #本地用来测效果 结束撒花，哦对了，如果有nginx需求，参考这个链接，可以设置默认访问80端口，输入ip默认到博客界面 4. 针对Kratos-Rebirth主题的配置参考链接 根目录下_config.yml 先理清两个概念，根目录下的deploy配置repo是对应仓库地址用http或者ssh地址都行，但是http协议下的 hexo -d容易报错，可能延迟太高了，建议使用ssh地址举例如下：git@github.com:Kvancy/Kvancy.github.io.git 根目录下url的配置是远程部署的网站地址，不是仓库地址，所以可以这样填 url: https://kvancy.github.io/ 还有一个叫做文章永久链接格式，permalink的配置，默认配置如下：:year/:month/:day/:title/ 意思是，在每次 hexo -g生成html时，默认文章目录结构是按照年月日文章名排布的，因为这个我一直以为是我commit版本加了’/‘导致的错误，弄了半天没弄明白，搞得我放弃云服务器转到github上来，现在明白了，但是想想还是就到github上吧 index_generator:属性配置，这个的per-page属性是指主页面下最多几个文章，也就是说几个文章之后需要进入下一个page，这个主题调成4个我个人感觉最好的 index: post_type: false 这个设置成false可以让主页上的文章预览时有自定义的图片 主题文件夹下_config.yml配置关于特效，参考链接 先说第一个，也是搞了我很久的一个问题，关于网站havicon标志的配置。我一直在根目录下对havicon进行部署，一度以为我的路径或者图片有问题，因为其中没有havicon的有关配置，我就像其他主题一样自己加上去，甚至去查过可以直接在服务器根目录下放着havicon.ico文件，浏览器会自己查找，试过了发现在 hexo -g的时候根目录结构会改变，行不通，后来翻阅作者的配置说明得知，在主题文件夹下site_logo处配置 site_logo: /images/favicon.ico #网站的favicon snow下雪动画设置成true，enable_dark设置成false，亮色主题。 去除主页上栏图片改用一整个图片做背景是在customStyles下吧images的banner属性地址设置成空，在src/scss/kr-color/default.css文件有有关对应默认设置的图片地址，把resource文件下该图片名改一下即可，独留background属性，地址为/images/bg.jpg，这个相对路径判断：”hexo -g”生成public文件后，进入public文件，这个是浏览器的根目录，在根目录下的images文件夹即对应了这个相对路径，下面的avatar也是如此寻址设图 siteLeaveEvent: true这个设置成true可以有监控离开和进入网页的动作，从而做出动效 引入了鼠标跟踪特效，源js代码链接 并对该特效进行修改，characters = [&quot;0&quot;, &quot;1&quot;]; 把音符改成了二进制；引入步骤是，copy并自定义修改js代码后，把文件名改成Suzhi.js（博主名），再copy一份到Suzhi.min.js，前者放在src/js目录下，后者放到source/js代码下；在layout/_partial找到after-footer.ejs文件，进去对照id = snow的写法复制一个对应id= Suzhi的（前端不是很懂，就是copy就完了！），参考如下： 123456&lt;% if(theme.mouse_trace_js){ %&gt; &lt;div&gt; &lt;canvas id=&quot;Suzhi&quot;&gt;&lt;/canvas&gt; &lt;%- js_theme_cdn('js/Suzhi.min.js', {async: true}) %&gt; &lt;/div&gt;&lt;% } %&gt; 然后在theme主题下的config_yml文件加一个 mouse_trace_js: true #鼠标跟踪动画就行 引入boom.js，text.js，更改了鼠标点击特效，前者是爆炸烟花波纹，后者是文字特效 5. 关于Typora1. YAML Front Matter的使用 每次上传md文件到博客时，都需要给文章起个标题，并且配置文章属性，如下是属性配置格式 1234567891011121314title: c++笔记date: 2023/9/18categories: 笔记tags: - 笔记sticky: 100pic:comments: falsetoc: trueexpire: trueonly: - home - category - tag pic : 可以指定这篇文章是否使用自定义的缩略图名称（在文章资源文件夹内），而不是使用随机化的图标 sticky : (number)重要的文章，把它们置顶吧！数字越大优先级越高哦~ comments : (true/false)是否为单篇文章指定开启或关闭评论区 toc： (true/false)该文章是否需要生成目录 only： 指定文章显示的位置，有以下关键词： home: 在首页显示 category: 在分类页显示 tag: 在标签页显示 留空或是不配置此项，则文章在所有该出现的位置都会显示。 层级之间相互平等，没有覆盖关系。 特别地，如果配置了此项，但是使用的并不是以上的关键词（例如只留了一个- none，那么文章就被隐藏起来了） 2. 控制文章预览字数 在你想要预览结束的地方添加markdown源代码 `` 3. 图片的插入与上传 在偏好设置的图像位置设置，插入图片时—-上传图片；勾选对本地位置的图片应用上述规则；上传服务—-PicGo(app), 路径找到Picgo的exe程序路径；在smms上注册一个账号，获得账号API token，作为接下来的密钥；下载PicGo(app)之后，在图床设置里将密钥填入SM.MS图床，SM.MS-登录用户； 在插件设置那里搜索smms-user，下载之后点击插件右下角的设置，点击配置plugin,配置uploader,把密钥填入后重启；在Typora偏好设置里有验证图片上传的选项 现在的话就可以在每次插入图片时实现自动上传到SMMS图床，并直接更改md文件中图片地址为远程图片地址，如果有大量没处理的本地图片，可以通过格式–图像–上传所有本地图片操作实现自动上传图片并更改图片路径 6. python学习积累:pyenv - python环境转换,参考链接: https://github.com/pyenv-win/pyenv-win Run pyenv install &lt;version&gt; to install the supported version Run pyenv global &lt;version&gt; to set a Python version as the global version Check which Python version you are using and its path 12&gt; pyenv version&lt;version&gt; (set by \\path\\to\\.pyenv\\pyenv-win\\.python-version) commands List all available pyenv commands local Set or show the local application-specific Python version global Set or show the global Python version shell Set or show the shell-specific Python version install Install 1 or more versions of Python uninstall Uninstall 1 or more versions of Python update Update the cached version DB rehash Rehash pyenv shims (run this after switching Python versions) vname Show the current Python version version Show the current Python version and its origin version-name Show the current Python version versions List all Python versions available to pyenv exec Runs an executable by first preparing PATH so that the selected Python which Display the full path to an executable whence List all Python versions that contain the given executable 123456789101112#list转变字符串a = ['P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\\\', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', '\\\\', ']', '^', '_', '`', 'a', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', '|', '}', '~', '\\x7f']T = ''.join(a)print(T)#list转bytes数组enc = [0x25, 0x6F, 0x3D, 0x6C, 0xF9, 0xE0, 0xCF, 0x3F, 0x2E, 0x24, 0xC6, 0x7B, 0x81, 0xBF, 0x55, 0x4F, 0x0D, 0x99, 0x87, 0x47, 0x48, 0xF7, 0xB9, 0x98, 0xFB, 0x1B, 0x22, 0xEC, 0x84, 0x23, 0xFD, 0xB2]my_bytearray = bytearray()my_bytearray.extend(enc)my_bytes = bytes(my_bytearray)print(my_bytes) #b'%o=l\\xf9\\xe0\\xcf?.$\\xc6{\\x81\\xbfUO\\r\\x99\\x87GH\\xf7\\xb9\\x98\\xfb\\x1b&quot;\\xec\\x84#\\xfd\\xb2' 7. &lt;&lt;深入理解计算机系统&gt;&gt;存储器 程序的局部性有两种不同的形式-时间局部性和空间局部性 一般而言,良好局部性的程序比局部性差的程序运行的更快 理解: 在一个具有良好局部性的程序中,如果一个内存位置被引用了一次,那么程序很可能在不远的将来引用附近的一个内存位置 原因: 在硬件层,局部性原理允许计算机设计者通过引入称为高速缓存存储器的小而快速的存储器来保存最近被引用的指令和数据项,从而提高对主存的访问速度 例如下面代码,func1会比func2更快 1234567891011121314151617181920212223int func1(int a[M[N]]){ int i,j,sum=0; for(i=0;i&lt;M;i++) { for(j&lt;0;j&lt;N;j++) { sum += a[M][N]; } }}int func2(int a[M[N]]){ int i,j,sum=0; for(i=0;i&lt;N;i++) { for(j&lt;0;j&lt;M;j++) { sum += a[M][N]; } }} 其实就是遍历二维数组的时候从行遍历变成了列遍历,从而破坏了函数的空间局限性 存储器层次架构: 速度 存储器 高速 寄存器 L1高速缓存(SRAM) L2高速缓存(SRAM) L3高速缓存(SRAM) 主存 本地磁盘 低速 远程二级存储(分布式文件系统,web服务器) 链接源程序main.c到可执行文件的几个步骤 生成Ascii码的中间文件main.i 翻译成汇编语言文件main.s 运行汇编器,生成一个可重定位目标文件main.o 最后运行链接器程序生成可执行文件main.exe gcc编译生成各种文件的几种指令 gcc --help可查询 gcc -E test.c -o test.i gcc -S test.c -o test.i gcc -c test.c -o test.o gcc test.o -o test linux下从应用程序中加载和链接动态链接共享库 1234#include&lt;dlfcn.h&gt;void* dlopen(const char* filename,int flag) //成功返回指向句柄的指针,flag可取RTLD_NOW或者RTLD_LAZY,指示链接器立即/延迟解析,JNI基本思想就是使用dlopen来调用.so共享库void dlsym(void* handle char *symbol); //成功返回指向符号的指针,若出错则为NULL,symbol为调用的函数名称int dlclose(void* handle); //不用时卸载该库 共享库的一个主要目的就是允许多个进程共享内存中相同的库代码,但是又不希望各个进程消耗过多的内存和时间加载完整的共享库 所以现代系统通过生成PIC(位置无关代码)代码来解决这个问题,无限多个进程可以共享一个共享模块的代码段的单一副本 gcc使用-fpic选项指示GNU编译系统生成PIC代码,编译共享库时总是使用该选项 未防止程序对整个共享库内导出函数进行重定位,引入了PLT表和GOT表两个概念 PLT表和GOT表是动态链接过程中的重要部分，它们可以实现程序在运行时按需加载外部库函数，提高程序的效率和安全性。我来给你讲讲它们的作用和原理。 PLT表（Procedure Linkage Table）是程序链接表，它包含了调用外部库函数的跳转指令，每个指令都会跳转到GOT表中的一个地址。PLT表的第一个条目是一个特殊的入口，它会调用动态链接器（ld）来解析函数的真实地址，并将其写入GOT表中。这个过程称为运行时重定位或惰性绑定，它可以避免在程序启动时就进行所有的重定位，从而减少启动时间和内存占用。 GOT表（Global Offset Table）是全局偏移表，它是一个存储外部库函数地址的数据段，每个条目对应一个PLT表中的条目。GOT表的前三个条目是特殊的，它们分别存储了动态段（.dynamic）的地址、链接映射对象（link_map）的地址和运行时解析函数（_dl_runtime_resolve）的地址。这些信息是动态链接器进行重定位所需要的。当程序第一次调用一个外部库函数时，GOT表中对应的条目会被重定位为真实的函数地址，并被缓存起来。当程序再次调用同一个函数时，就可以直接从GOT表中读取地址并跳转过去，无需再次进行重定位。 Docker获取容器 IP：如果你需要使用容器的 IP 地址连接，可以使用 docker inspect 命令获取容器的 IP 地址： 1docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mysql Mysql启动mysql,必须指定MYSQL_ROOT_PASSWORD1属性 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql phpmyadminphpmyadmin连接mysql进行管理,指定PMA_HOST来指定mysql容器ip, -e PMA_USER=root -e PMA_PASSWORD=root为mysql账号密码 1docker run --name phpmyadmin -d -p 8080:80 -e PMA_HOST=172.17.0.3 -e PMA_PORT=3306 -e PMA_USER=root -e PMA_PASSWORD=root phpmyadmin 部署可执行jar包https://www.jb51.net/article/255143.htm 一、准备工作1、创建存放docker配置文件、jar包的文件夹在宿主机上，创建文件夹：/home/admin/app，用于存放bash文件和jar包。然后在该文件夹下，创建bash文件和容器配置文件 2、创建bash文件12vi run.shjava -jar /usr/data/app-1.0.0.jar /usr/data是docker容器内的路径 我们不必真的到容器内创建这个路径 后面会将此路径挂载到当前文件夹：/home/admin/app 3、创建容器配置文件1234vi DockerfileFROM java:8 EXPOSE 8081 ENTRYPOINT [&quot;sh&quot;,&quot;/usr/data/run.sh&quot;] 8081是我们这个jar包的对外端口 二、构建镜像仍然在/home/admin/app下，构建镜像。注意最后一个“.”，表示 Dockerfile 文件在当前目录下。 1docker build -t myapp:1.0.0 . 三、创建容器并运行1docker run -d -it --name=myapp -p 8081:8081 -v /home/admin/app:/usr/data myapp:1.0.0 docker引擎重启后自动运行（也可以理解为操作系统重启后自动运行，如果docker是开机自动运行的话） 1docker run --restart=always -d -it --name=myapp -p 8082:8081 -v /home/admin/app:/usr/data myapp:1.0.0 -v，将容器内的/usr/data挂载到宿主机的/home/admin/app。以后jar包有更新，丢到宿主机的/home/admin/app，然后重启容器即可。 -d: 后台运行容器，并返回容器ID； -d, –detach=false Run container in background and print container ID -i: 以交互模式运行容器，通常与 -t 同时使用； -i, –interactive=false Keep STDIN open even if not attached -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； -t, –tty=false Allocate a pseudo-TTY 四、删除多余或失败的容器、镜像以上步骤，可能存在波折，不小心就创建了许多并不称心如意的容器和镜像，占用了心水名称和端口，必先删之而后快。 1、观察已经有哪些容器1docker ps -a 加上 -a 参数，可以列出没有在运行的容器。 2、删除指定容器docker rm $name 或者 容器ID 3、观察已经有哪些镜像1docker images 4、删除指定镜像1docker rmi -f $name 或者 镜像ID 要删除镜像，首先要删除它派生的容器。 Mysql连接mysql数据库注意事项: 修改root用户远程连接权限:1GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION; 查看是否修改成功12use mysql;select host,user from user; 刷新权限1flush privileges; 更新用户密码:使用 ALTER USER 语句来更新用户密码。例如，如果你想要更新用户名为 user 的密码 1ALTER USER 'user'@'%' IDENTIFIED BY 'newpassword'; 创建新用户：使用 CREATE USER 语句创建新用户。例如，创建一个用户名为 user 的新用户： 1CREATE USER 'user'@'%' IDENTIFIED BY 'yourpassword'; Navicat连接在docker的mysql创建用户,设置连接权限后,Navicat设置主机127.0.0.1/localhost(mysql容器的ip虽然本地ping不通,但是可以连上) java文件打包jar 编译Java源文件: 打开终端或命令提示符，然后使用javac命令编译你的Java源文件。例如，如果你的主类是Main.java，你可以使用以下命令： 1javac Main.java 检查编译结果: 编译后，你应该在相同的目录下看到Main.class文件（以及可能的任何内部类文件，例如Main$1.class等）。 创建JAR文件: 使用jar命令来创建JAR文件。如果你的主类是Main，并且你想创建一个名为MyApplication.jar的JAR文件，你可以使用以下命令：(注意Main后有个空格,指将所有以Main为前缀的class都选上) 1jar cvfe MyApplication.jar Main *.class 这里的c表示创建新的JAR文件，v表示在创建过程中显示详细输出，f指定JAR文件的名称，e表示指定应用程序的入口点（主类），后面跟着主类的名称和.class文件的通配符。 确保JAR文件的可执行性: 如果你的JAR文件中包含的是应用程序的主类，你可能还需要在JAR文件的清单（MANIFEST.MF）中指定主类。这可以通过以下命令完成： 12echo &quot;Main-Class: Main&quot; &gt; manifest.txtjar cvfm MyApplication.jar manifest.txt *.class 这里m表示指定清单文件，manifest.txt是包含Main-Class属性的文件。 运行JAR文件: 一旦JAR文件创建完成，你可以通过以下命令来运行它： 1java -jar MyApplication.jar 清理: 如果你不需要.class文件了，可以删除它们以节省空间： 1rm *.class","link":"/2023/07/08/Rookie%20diary/"},{"title":"smc总结","text":"SMC（Software-Based Memory Encryption）是一种局部代码加密技术，它可以提高恶意代码的抗分析能力，但也存在一些局限性。作为一名CTF比赛的爱好者，虽然经常接触SMC加密技术，但是对其原理和实现并不深入了解，只是停留在解题的层面。最近，在为新生出题的过程中，产生了将SMC加密技术应用在出题上的想法，于是决定深入探究这门技术的原理、实现和应用。本文旨在分享作者学习SMC加密技术的心得，以及介绍如何利用SMC加密技术设计出有趣和有挑战性的CTF题目本文的结构如下：第一部分介绍SMC加密技术的基本概念和原理；第二部分介绍SMC加密技术的实现方法和工具；第三部分介绍SMC加密技术在CTF出题中的应用和案例 SMC加密技术的基本概念和原理SMC（Software-Based Memory Encryption）是一种局部代码加密技术，它可以将一个可执行文件的指定区段进行加密，使得黑客无法直接分析区段内的代码，从而增加恶意代码分析难度和降低恶意攻击成功的可能性。SMC的基本原理是在编译可执行文件时，将需要加密的代码区段（例如函数、代码块等）单独编译成一个section（段），并将其标记为可读、可写、不可执行（readable, writable, non-executable），然后通过某种方式在程序运行时将这个section解密为可执行代码，并将其标记为可读、可执行、不可写（readable, executable, non-writable）。这样，攻击者就无法在内存中找到加密的代码，从而无法直接执行或修改加密的代码。具体介绍见原文:https://zhuanlan.zhihu.com/p/624554464 SMC加密技术的实现方法PS:为了方便,部分示例代码省去了对字节码加密和解密的操作,请注意辨别 1.数组保存字节码-&gt;调整内存执行权限-&gt;函数指针运行先提取加密段代码的字节码写入加密段代码,通过调试工具获取加密代码对应的字节码,例如: 12345byte addData[] = {0x55,0x89,0xe5,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0x5d,0xc3};// int add(int a,int b)// {// return a+b;// } 通过VirtualProtect函数调整内存为可执行的,定义函数指针,指向addData,调用函数指针 BOOL VirtualProtect( [in] LPVOID lpAddress, // 要更改保护属性的页区域的起始地址 [in] SIZE_T dwSize, // 要更改保护属性的区域的大小（以字节为单位） [in] DWORD flNewProtect,// 新的保护属性值 [out] PDWORD lpflOldProtect // 用于接收原来保护属性值的指针);第三个参数flNewProtect包括但不限于:PAGE_EXECUTE 可执行PAGE_EXECUTE_READ 可读可执行PAGE_EXECUTE_READWRITE 可读可写可执行最简单的一种实现方式,以add函数为例 1234567891011121314151617181920#include &quot;mytool.h&quot;typedef int (*FnAdd)(int,int);byte addData[] = {0x55,0x89,0xe5,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0x5d,0xc3};// int add(int a,int b)// {// return a+b;// }int main(){ DWORD fOldProtect = 0; if(!VirtualProtect(addData,sizeof(addData),PAGE_EXECUTE,&amp;fOldProtect)) { perror(&quot;VirtualProtect failed&quot;); system(&quot;pause&quot;); } FnAdd add = (FnAdd)addData; printf(&quot;%d&quot;,add(3,4));//7 system(&quot;pause&quot;); return 0;} 运行成功,在IDA中查看效果(未加密的)函数如期的到了data段通过这种方式即可实现大部分的加密算法,例如tea,base64,rc4等但是对于一些复杂的逻辑加密,可能需要引入外界的库函数,比如说CTF中简单的输入输出提示,需要用到printf,scanf等库函数举例如下,当add中嵌套了printf时 12345678910111213141516171819202122#include &quot;mytool.h&quot;typedef int (*FnAdd)(int,int);byte addData[] = {0x55,0x89,0xe5,0x83,0xec,0x28,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0x89,0x45,0xf4,0x8b,0x45,0xf4,0x89,0x44,0x24,0x4,0xc7,0x4,0x24,0x6a,0x50,0x40,0x0,0xe8,0x21,0x26,0x0,0x0,0x8b,0x45,0xf4,0xc9,0xc3};// int add(int a,int b)// {// int c = a+b;// printf(&quot;%d&quot;,c);// return c;// }int main(){ DWORD fOldProtect = 0; if(!VirtualProtect(addData,sizeof(addData),PAGE_EXECUTE,&amp;fOldProtect)) { perror(&quot;VirtualProtect failed&quot;); system(&quot;pause&quot;); } FnAdd add = (FnAdd)addData; add(3,4); system(&quot;pause&quot;); return 0;} 正常生成但是运行失败,汇编窗口动调发现在call指令时发生了报错分析可知,call指令后跟的是printf的相对地址,在转换到data段之后相对地址发生改变,访问到了非printf地址第一种解决方法:可以定义函数指针,在加密函数内通过函数指针来利用库函数如下: 123456789101112131415161718192021222324#include &quot;mytool.h&quot;typedef int (*PRINTF) (const char *__format, ...);typedef int (*FnAdd)(int,int,PRINTF);byte addData[] = {0x55,0x89,0xe5,0x83,0xec,0x28,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0x89,0x45,0xf4,0x66,0xc7,0x45,0xf1,0x25,0x64,0xc6,0x45,0xf3,0x0,0x8b,0x45,0xf4,0x89,0x44,0x24,0x4,0x8d,0x45,0xf1,0x89,0x4,0x24,0x8b,0x45,0x10,0xff,0xd0,0x8b,0x45,0xf4,0xc9,0xc3};// int add(int a,int b,PRINTF print)// {// int c = a+b;// char format[] = &quot;%d&quot;;//原.rdata段数据,尽量使用栈来保存函数参数// print(format,c);// return c;// }int main(){ DWORD fOldProtect = 0; if(!VirtualProtect(addData,sizeof(addData),PAGE_EXECUTE,&amp;fOldProtect)) { perror(&quot;VirtualProtect failed&quot;); system(&quot;pause&quot;); } FnAdd add = (FnAdd)addData; add(3,4,printf); system(&quot;pause&quot;); return 0;} IDA中伪代码:从这个例子可以看出，这种传参方式很容易暴露自己的意图，此地无银三百两的感觉,并且会出现调用多个库函数时代码可读性差的问题为了优化隐蔽性和可读性，我们可以利用kernel32.dll模块来获取LoadLibraryA和GetProcAddress函数的地址，进而动态加载我们需要的模块和函数。具体的实现步骤在Get_Func函数中有详细说明。下面是修改后的程序，可正常运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//mytool.htypedef HINSTANCE (*LOADLIBRARY)(LPCSTR);//LoadLibraryA的地址typedef FARPROC (*GETPROCADDRESS)(HINSTANCE, LPCSTR);//GetProcAddress的地址int Get_Func(int fnNum){//通过传参来返回GetProcAddress函数地址和LoadLibraryA函数地址 asm( &quot;mov %esp, %ebp\\n&quot; &quot;push $0\\n&quot; &quot;push $0x7373\\n&quot; &quot;push $0x65726464\\n&quot; &quot;push $0x41636f72\\n&quot; &quot;push $0x50746547\\n&quot; // GetProcAddress &quot;push $0\\n&quot; &quot;push $0x41797261\\n&quot; &quot;push $0x7262694c\\n&quot; &quot;push $0x64616f4c\\n&quot; // LoadLibraryA &quot;mov %esp, %ecx\\n&quot; &quot;push %ecx\\n&quot; // esp传参过去 &quot;cmp $0,0x8(%ebp)\\n&quot;//传参是0就得到LoadLibraryA的地址 &quot;jnz label2\\n&quot; &quot;call Get_Load\\n&quot; &quot;jmp label1\\n&quot;&quot;label2:&quot; &quot;call Get_Proc\\n&quot;//传参是1就得到GetProcAddress的地址&quot;label1:&quot; &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret\\n&quot;&quot;Func_GetModule:&quot; &quot;push %ebp\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;sub $0x20, %esp\\n&quot; &quot;push %esi\\n&quot; &quot;mov %fs:0x30, %esi\\n&quot; // PEB结构体地址 &quot;mov 0xc(%esi), %esi\\n&quot; // LDR结构体地址 &quot;mov 0x1c(%esi), %esi\\n&quot; // list &quot;mov (%esi), %esi\\n&quot; // list 第二项kernel32或者kernelbase &quot;mov 0x8(%esi), %esi\\n&quot; // dllbase &quot;mov %esi, %eax\\n&quot; &quot;pop %esi\\n&quot; &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret\\n&quot;&quot;Func_GetAddr:&quot; &quot;push %ebp\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;sub $0x20, %esp\\n&quot; &quot;mov 0x8(%ebp), %edx\\n&quot; // dllbase &quot;mov 0x3c(%edx), %esi\\n&quot; // if_anew &quot;lea (%edx, %esi), %esi\\n&quot; // NT header &quot;mov 0x78(%esi), %esi\\n&quot; // 导出表RVA &quot;lea (%edx, %esi), %esi\\n&quot; // 导出表VA &quot;mov 0x1c(%esi), %edi\\n&quot; // EAT RVA &quot;lea (%edx, %edi), %edi\\n&quot; // EAT VA &quot;mov %edi, -0x4(%ebp)\\n&quot; // 保存 &quot;mov 0x20(%esi), %edi\\n&quot; // ENT RVA &quot;lea (%edx, %edi), %edi\\n&quot; // ENT VA &quot;mov %edi, -0x8(%ebp)\\n&quot; // 保存 &quot;mov 0x24(%esi), %edi\\n&quot; // EOT RVA &quot;lea (%edx, %edi), %edi\\n&quot; // EOT VA &quot;mov %edi, -0xc(%ebp)\\n&quot; // 保存 &quot;xor %eax, %eax\\n&quot; &quot;jmp tag_cmpfirst\\n&quot; &quot;tag_cmpLoop:&quot; &quot;inc %eax\\n&quot; &quot;tag_cmpfirst:&quot; &quot;mov -0x8(%ebp), %esi\\n&quot; // ENT &quot;mov (%esi, %eax, 4), %esi\\n&quot; // RVA &quot;lea (%edx, %esi), %esi\\n&quot; // 函数名称字符串地址 &quot;mov 0xc(%ebp), %edi\\n&quot; &quot;mov 0x10(%ebp), %ecx\\n&quot; // 循环次数，ebp+0x10是传来的参数 &quot;repe cmpsb\\n&quot; &quot;mov -0xc(%ebp), %esi\\n&quot; &quot;jne tag_cmpLoop\\n&quot; &quot;mov -0xc(%ebp), %esi\\n&quot; // EOT &quot;xor %edi, %edi\\n&quot; // 为了不影响结果清空edi &quot;mov (%esi, %eax, 2), %di\\n&quot; // word类型,EAT表索引 &quot;mov -0x4(%ebp), %edx\\n&quot; // EAT &quot;mov (%edx, %edi, 4), %esi\\n&quot; // 函数地址RVA &quot;mov 0x8(%ebp), %edx\\n&quot; // dllbase &quot;lea (%edx, %esi), %eax\\n&quot; // 最终函数地址 &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret $0xc\\n&quot; // 在栈中弹出三个参数&quot;Get_Load:&quot; &quot;push %ebp\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;sub $0x10, %esp\\n&quot; &quot;call Func_GetModule\\n&quot; // 获取kernel模块基址 &quot;mov %eax, -0x4(%ebp)\\n&quot; // 保存模块基址 &quot;lea 0xc(%ebp), %ecx\\n&quot; // load地址 &quot;push $0xc\\n&quot; &quot;push %ecx\\n&quot; &quot;push %eax\\n&quot; &quot;call Func_GetAddr\\n&quot; // 三个参数，第一个模块基址，第二个字符串地址，第三个字符串长度 loadlibrarya &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret\\n&quot;&quot;Get_Proc:&quot; &quot;push %ebp\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;sub $0x10, %esp\\n&quot; &quot;call Func_GetModule\\n&quot; // 获取kernel模块基址 &quot;mov %eax, -0x4(%ebp)\\n&quot; // 保存模块基址 &quot;push $0xe\\n&quot; &quot;lea 0x1c(%ebp), %ecx\\n&quot; // Get字符串 &quot;push %ecx\\n&quot; &quot;push -0x4(%ebp)\\n&quot; // 模块基址 &quot;call Func_GetAddr\\n&quot; // 三个参数，第一个模块基址，第二个字符串地址，第三个字符串长度 GetProcAddress &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret\\n&quot; );} 1 这里就是通过Get_Func来获取GetProcAddress函数地址和LoadLibraryA函数地址从而在加密函数内可以调用这两个函数来获取其他库函数地址Get_Func函数具体实现方式大致是(大佬略过~~):通过FS段寄存器获取TEB的地址，然后通过TEB的ProcessEnvironmentBlock成员（偏移量为0x30）获取PEB的地址,再通过PEB结构体获取其成员Ldr(加载模块列表)(偏移量为0xc),通过Ldr结构体访问InInitializationOrderModuleList成员(导入模块列表)(偏移量0x1c),InInitializationOrderModuleList的第二个成员即为kernel32.dll模块,我们想要的GetProcAddress函数地址和LoadLibraryA函数地址都在kernel32.dll里面了,通过了解PE文件结构访问其导出表即可 好了,转成字节码试一下效果原函数转成字节码之后代码如下: 123456789101112131415161718192021222324252627282930#include &quot;mytool.h&quot;typedef int (*PRINTF) (const char *__format, ...);typedef int (*GET_FUNC)(int); typedef int (*FnAdd)(int,int,GET_FUNC);byte addData[] = {0x55,0x89,0xe5,0x83,0xec,0x48,0xc7,0x4,0x24,0x0,0x0,0x0,0x0,0x8b,0x45,0x10,0xff,0xd0,0x89,0x45,0xf4,0xc7,0x4,0x24,0x1,0x0,0x0,0x0,0x8b,0x45,0x10,0xff,0xd0,0x89,0x45,0xf0,0xc7,0x45,0xdd,0x6d,0x73,0x76,0x63,0xc7,0x45,0xe1,0x72,0x74,0x2e,0x64,0x66,0xc7,0x45,0xe5,0x6c,0x6c,0xc6,0x45,0xe7,0x0,0x8d,0x45,0xdd,0x89,0x4,0x24,0x8b,0x45,0xf4,0xff,0xd0,0x89,0x45,0xec,0xc7,0x45,0xd6,0x70,0x72,0x69,0x6e,0x66,0xc7,0x45,0xda,0x74,0x66,0xc6,0x45,0xdc,0x0,0x8d,0x45,0xd6,0x89,0x44,0x24,0x4,0x8b,0x45,0xec,0x89,0x4,0x24,0x8b,0x45,0xf0,0xff,0xd0,0x89,0x45,0xe8,0xc7,0x45,0xd2,0x25,0x64,0xa,0x0,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0x89,0x44,0x24,0x4,0x8d,0x45,0xd2,0x89,0x4,0x24,0x8b,0x45,0xe8,0xff,0xd0,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0xc9,0xc3};//add字节码// int add(int a,int b,GET_FUNC get_func)// {// LOADLIBRARY load = (LOADLIBRARY)get_func(0);// GETPROCADDRESS ProcAddress = (GETPROCADDRESS)get_func(1);// char Module_name[] = &quot;msvcrt.dll&quot;;// HINSTANCE mAddress = load(Module_name);// char fnName[] = &quot;printf&quot;;// PRINTF print = (PRINTF)ProcAddress(mAddress,fnName);// char format[] = &quot;%d\\n&quot;;// print(format,a+b);// return a+b;// }int main(){ DWORD fOldProtect = 0; if(!VirtualProtect(addData,sizeof(addData),PAGE_EXECUTE,&amp;fOldProtect)) { perror(&quot;VirtualProtect failed&quot;); system(&quot;pause&quot;); } FnAdd add = (FnAdd)addData; add(3,4,Get_Func); system(&quot;pause&quot;); return 0;} 运行成功,输出7在IDA中的伪代码窗口如下: 隐藏性有所提升,但是还可以进一步提升我们可以把Get_Func函数也通过SMC加密,从而进一步提高代码的隐藏性 12345678910111213141516171819202122232425262728293031323334#include &quot;mytool.h&quot;typedef int (*PRINTF) (const char *__format, ...);typedef int (*GET_FUNC)(int); typedef int (*FnAdd)(int,int,GET_FUNC);byte addData[] = {0x55,0x89,0xe5,0x83,0xec,0x48,0xc7,0x4,0x24,0x0,0x0,0x0,0x0,0x8b,0x45,0x10,0xff,0xd0,0x89,0x45,0xf4,0xc7,0x4,0x24,0x1,0x0,0x0,0x0,0x8b,0x45,0x10,0xff,0xd0,0x89,0x45,0xf0,0xc7,0x45,0xdd,0x6d,0x73,0x76,0x63,0xc7,0x45,0xe1,0x72,0x74,0x2e,0x64,0x66,0xc7,0x45,0xe5,0x6c,0x6c,0xc6,0x45,0xe7,0x0,0x8d,0x45,0xdd,0x89,0x4,0x24,0x8b,0x45,0xf4,0xff,0xd0,0x89,0x45,0xec,0xc7,0x45,0xd6,0x70,0x72,0x69,0x6e,0x66,0xc7,0x45,0xda,0x74,0x66,0xc6,0x45,0xdc,0x0,0x8d,0x45,0xd6,0x89,0x44,0x24,0x4,0x8b,0x45,0xec,0x89,0x4,0x24,0x8b,0x45,0xf0,0xff,0xd0,0x89,0x45,0xe8,0xc7,0x45,0xd2,0x25,0x64,0xa,0x0,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0x89,0x44,0x24,0x4,0x8d,0x45,0xd2,0x89,0x4,0x24,0x8b,0x45,0xe8,0xff,0xd0,0x8b,0x55,0x8,0x8b,0x45,0xc,0x1,0xd0,0xc9,0xc3};byte get_func[] = {0x55, 0x89, 0xE5, 0x89, 0xE5, 0x6A, 0x00, 0x68, 0x73, 0x73, 0x00, 0x00, 0x68, 0x64, 0x64, 0x72, 0x65, 0x68, 0x72, 0x6F, 0x63, 0x41, 0x68, 0x47, 0x65, 0x74, 0x50, 0x6A, 0x00, 0x68, 0x61, 0x72, 0x79, 0x41, 0x68, 0x4C, 0x69, 0x62, 0x72, 0x68, 0x4C, 0x6F, 0x61, 0x64, 0x89, 0xE1, 0x51, 0x83, 0x7D, 0x08, 0x00, 0x75, 0x07, 0xE8, 0x91, 0x00, 0x00, 0x00, 0xEB, 0x05, 0xE8, 0xA8, 0x00, 0x00, 0x00, 0x89, 0xEC, 0x5D, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x20, 0x56, 0x64, 0x8B, 0x35, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x76, 0x0C, 0x8B, 0x76, 0x1C, 0x8B, 0x36, 0x8B, 0x76, 0x08, 0x89, 0xF0, 0x5E, 0x89, 0xEC, 0x5D, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x20, 0x8B, 0x55, 0x08, 0x8B, 0x72, 0x3C, 0x8D, 0x34, 0x32, 0x8B, 0x76, 0x78, 0x8D, 0x34, 0x32, 0x8B, 0x7E, 0x1C, 0x8D, 0x3C, 0x3A, 0x89, 0x7D, 0xFC, 0x8B, 0x7E, 0x20, 0x8D, 0x3C, 0x3A, 0x89, 0x7D, 0xF8, 0x8B, 0x7E, 0x24, 0x8D, 0x3C, 0x3A, 0x89, 0x7D, 0xF4, 0x31, 0xC0, 0xEB, 0x01, 0x40, 0x8B, 0x75, 0xF8, 0x8B, 0x34, 0x86, 0x8D, 0x34, 0x32, 0x8B, 0x7D, 0x0C, 0x8B, 0x4D, 0x10, 0xF3, 0xA6, 0x8B, 0x75, 0xF4, 0x75, 0xE9, 0x8B, 0x75, 0xF4, 0x31, 0xFF, 0x66, 0x8B, 0x3C, 0x46, 0x8B, 0x55, 0xFC, 0x8B, 0x34, 0xBA, 0x8B, 0x55, 0x08, 0x8D, 0x04, 0x32, 0x89, 0xEC, 0x5D, 0xC2, 0x0C, 0x00, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x10, 0xE8, 0x6F, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xFC, 0x8D, 0x4D, 0x0C, 0x6A, 0x0C, 0x51, 0x50, 0xE8, 0x80, 0xFF, 0xFF, 0xFF, 0x89, 0xEC, 0x5D, 0xC3, 0x55, 0x89, 0xE5, 0x83, 0xEC, 0x10, 0xE8, 0x51, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xFC, 0x6A, 0x0E, 0x8D, 0x4D, 0x1C, 0x51, 0xFF, 0x75, 0xFC, 0xE8, 0x60, 0xFF, 0xFF, 0xFF, 0x89, 0xEC, 0x5D, 0xc3};// int add(int a,int b,GET_FUNC get_func)// {// LOADLIBRARY load = (LOADLIBRARY)get_func(0);// GETPROCADDRESS ProcAddress = (GETPROCADDRESS)get_func(1);// char Module_name[] = &quot;msvcrt.dll&quot;;// HINSTANCE mAddress = load(Module_name);// char fnName[] = &quot;printf&quot;;// PRINTF print = (PRINTF)ProcAddress(mAddress,fnName);// char format[] = &quot;%d\\n&quot;;// print(format,a+b);// return a+b;// }int main(){ DWORD fOldProtect = 0; if(!VirtualProtect(addData,sizeof(addData),PAGE_EXECUTE,&amp;fOldProtect)|| !VirtualProtect(get_func,sizeof(get_func),PAGE_EXECUTE,&amp;fOldProtect) ) { perror(&quot;VirtualProtect failed&quot;); system(&quot;pause&quot;); } FnAdd add = (FnAdd)addData; GET_FUNC get_fn = (GET_FUNC)get_func; add(3,4,get_fn); system(&quot;pause&quot;); return 0;} 实现效果: 2.新建可执行的节段存储加密函数3.Linux下把加密代码放到数据段: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;// 一个全局变量，用来存放机器指令unsigned char code[8] = {0};// 一个函数指针，用来指向机器指令的地址typedef int (*func_ptr)();int main(){ // 获取当前系统的内存页大小 int pagesize = sysconf(_SC_PAGESIZE); printf(&quot;pagesize = %d\\n&quot;, pagesize); // 计算全局变量code的地址所在的内存页的起始地址 unsigned long start = (unsigned long)code &amp; ~(pagesize - 1); printf(&quot;start = %p\\n&quot;, (void *)start); // 计算全局变量code的地址所在的内存页的结束地址 unsigned long end = ((unsigned long)code + sizeof(code) + pagesize - 1) &amp; ~(pagesize - 1); printf(&quot;end = %p\\n&quot;, (void *)end); // 计算全局变量code所占用的内存页的长度 size_t len = end - start; printf(&quot;len = %ld\\n&quot;, len); // 给全局变量code所在的内存页可执行权限 int ret = mprotect((void *)start, len, PROT_READ | PROT_EXEC); if (ret == -1) { perror(&quot;mprotect&quot;); return -1; } // 在全局变量code中写入一段机器指令，其功能是将rax加1并返回 // 该指令的二进制码为：48 ff c0 c3 code[0] = 0x48; code[1] = 0xff; code[2] = 0xc0; code[3] = 0xc3; // 将函数指针指向全局变量code的地址 func_ptr f = (func_ptr)code; // 调用函数指针，执行机器指令 int result = f(); printf(&quot;result = %d\\n&quot;, result); return 0;} CTF出题中的应用,","link":"/2023/09/17/smc%E6%80%BB%E7%BB%93/"},{"title":"Typora破解复现","text":"最近在逛论坛的时候看到有人写了一份Typora的破解复现，看了下破解过程感觉不是很难，又因为实验室招新活动开始，刚好手里缺技术演示的材料，于是便想自己着手看看这个一直在用的工具是怎么被破解的，记录一下破解过程 1. 找到app.asar文件解包得到License.js加密代码根据火绒剑在系统日志里监控Typore的启动，找到可疑的asar文件，程序访问并读取了该文件，并启动了其中的main.node模块，疑似开发者对加密源代码的解密过程 找到app.asar文件，根据日志显示，可以猜测这个类似压缩包，问Bing得知 asar是一种用于打包Electron应用程序源代码的文件格式，它可以让应用程序更容易分发和运行。asar文件的工作原理是将所有文件连接在一起，不进行压缩，但支持随机访问。asar文件可以使用asar命令行工具或者electron-packager等工具来创建或解压 根据提示内容进行解压， asar extract app.asar unpacked 得到unpacked文件，貌似找到关于许可证的有关文件–License.js，Winhex打开看一眼 有种base64编码的感觉，难道只是base64编码加密？拖进CyberChef解密一下 可能还有一层或几层加密 2. 从main.node文件找License.js的解密逻辑根据火绒剑日志显示，在app.asar解包后运行了main.node模块，又根据前面License.js被加密了，可以推测main.node有可能运行时解密了License.js文件，先DIE看一眼main.node，DLL64位，IDA64打开，先不管其他的，shift+f12查找字符串 疑似有base64解密过程，交叉引用找到引用处伪代码 根据Bing得知 napi_get_named_property 是一个 Node-API 的函数，它的作用是从一个对象中获取一个指定名称的属性，并返回它的值。 1napi_status napi_call_function(napi_env env, napi_value recv, napi_value func, size_t argc, const napi_value* argv, napi_value* result); 其中，参数的含义是： env: 当前调用 N-API 的环境。 recv: 要作为函数接收者的对象，通常是 this 的值。 func: 要调用的函数对象。 argc: 要传递的参数的个数。 argv: 要传递的参数的数组。 result: 用于接收函数返回值的指针。 分析得知，这段代码类似给v40进行解码，v40 = base64.from(v38)，v38又来自函数的第三个参数a3+8，猜测这个a3+8指向的就是密文的地址，动调验证下，x64dbg直接拖Typora，手动下一个main.node的断点，再根据IDA中给出的偏移计算出调试器里解密函数的地址，根据64位下寄存器默认传参顺序是ECX,EDX,R8,R9知道a3的值储存在R8中，所以R8+8指向密文地址，验证： 这里的数据刚好对应的是atom.js里的密文 验证成功，继续分析 找到类似加密算法的密钥初始化，用findcrypt看一眼发现了AES的S盒和逆S盒，推测这里应该是AES的密钥，而且长度为32个字节，猜测是256位模式 接着找AES解密线索，找到F4E0偏移处函数 里面有S盒和异或的继续分析，确定下ECB模式还是CBC模式 进入3A8F偏移处函数分析，在这里先猜测block应该是密文（void 指针数组） 函数里面又出现了一个循环异或，可以肯定这是个CBC模式下的异或偏移量了，那偏移量又是怎么来的呢，追踪a2（密文地址）进行判断的话，函数里面是复制了一份a2给v3，也就是说v3可能指向了密文 那么result就是偏移量了，偏移量来自密文地址+v5处，进行16次循环，也就是说偏移量可能来自密文的0-15个字节位？ 3. CyberChef验证猜测依据之前的猜测，main.node通过base64解码，再AES，CBC模式解码，密钥IDA动调得到 0x4E, 0xE1, 0xB3, 0x82, 0x94, 0x9A, 0x02, 0x4B, 0x80, 0x2F, 0x52, 0xB4, 0xB4, 0xFE, 0x57, 0xF1, 0xBE, 0xF4, 0x08, 0x53, 0x10, 0x92, 0x56, 0xE2, 0xC2, 0x0D, 0xEC, 0xA3, 0xDD, 0x8D, 0xD5, 0x6D 偏移量为密文的前16个字节，带入CyberChef检验 这下应该是得到了License.js源码，下载得到文件，找在线js美化工具美化 4. 最终的Patch简单审计了下代码，不懂的找Bing问就是。首先应该patch掉网络验证类似request的东西，找到了几处 patch后的License.js源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394LL50Du2bPNkYky7Grequire(&quot;Env.js&quot;);var Dict = require(&quot;Dict.js&quot;), electron = require(&quot;electron&quot;), shell = electron.shell, app = electron.app, ipc = electron.ipcMain, BrowserWindow = electron.BrowserWindow, isWin = &quot;win32&quot; == process.platform, isMac = &quot;darwin&quot; == process.platform, isLinux = &quot;linux&quot; == process.platform, WindowController = require(&quot;WindowController.js&quot;), Raven = require(&quot;raven&quot;), errorShown = !1;const mustRequire = function(e) { try { return require(e) } catch (e) { if (errorShown) return; errorShown = !0; var n = e.message; setTimeout(() =&gt; { errorShown = !1, dialog = require(&quot;electron&quot;).dialog, dialog.showMessageBox(null, { type: &quot;error&quot;, buttons: [&quot;OK&quot;], defaultId: 0, cancelId: 0, title: &quot;A required module cannot be loaded by Typora&quot;, message: n.split(&quot;\\n&quot;)[0] + &quot;\\n\\nPlease check if that file exists or reinstall Typora to fix.&quot; }).then(({ response: e }) =&gt; { process.exit(1) }) }, 1500) }};var installDate, lastShown, hasLicense = null, email = &quot;&quot;, licenseCode = &quot;&quot;, fingerPrint = &quot;&quot;;const ActiveResponseCode = { SUCCESS: 0, OUT_OF_LIMIT: 1, INVALIDATE: -1, WRONG_USER: -2 }, PUB_KEY = &quot;-----BEGIN PUBLIC KEY-----\\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7nVoGCHqIMJyqgALEUrc\\n5JJhap0+HtJqzPE04pz4y+nrOmY7/12f3HvZyyoRsxKdXTZbO0wEHFIh0cRqsuaJ\\nPyaOOPbA0BsalofIAY3mRhQQ3vSf+rn3g+w0S+udWmKV9DnmJlpWqizFajU4T/E4\\n5ZgMNcXt3E1ips32rdbTR0Nnen9PVITvrbJ3l6CI2BFBImZQZ2P8N+LsqfJsqyVV\\nwDkt3mHAVxV7FZbfYWG+8FDSuKQHaCmvgAtChx9hwl3J6RekkqDVa6GIV13D23LS\\nqdk0Jb521wFJi/V6QAK6SLBiby5gYN6zQQ5RQpjXtR53MwzTdiAzGEuKdOtrY2Me\\nDwIDAQAB\\n-----END PUBLIC KEY-----\\n\\n&quot;, DAY_IN_MS = 864e5;var HOST = &quot;https://store.typora.io&quot;;const decrypt = e =&gt; {return JSON.parse(Buffer.from(e, &quot;base64&quot;).toString(&quot;utf8&quot;))}, makeHash = function() { var e = Array.from(arguments); const n = require(&quot;crypto&quot;).createHash(&quot;sha256&quot;); return e.forEach(e =&gt; { n.update(e) }), n.digest(&quot;base64&quot;) }, readLicenseInfo = () =&gt; { const e = getLicenseLocalStore().get(&quot;SLicense&quot;); if (!e) return null; const [n, t, i] = e.split(&quot;#&quot;), a = decrypt(n); return a.fingerprint != fingerPrint ? null : (Object.assign(a, { failCounts: t, lastRetry: new Date(i) }), a) }, writeInstallDate = async e =&gt; { console.log(`writeInstallDate fromBTime=${e}`); var n = new Date; if (e) try { var t = await require(&quot;fs-extra&quot;).stat(app.getPath(&quot;userData&quot;) + &quot;/profile.data&quot;); n = new Date(t.birthtime), t.birthtime } catch (e) {} installDate = n; const i = n.toLocaleDateString(&quot;en-US&quot;); return getLicenseLocalStore().put(&quot;IDate&quot;, i), installDate };var licenseLocalStoreInstance = null;const getLicenseLocalStore = function() { if (null == licenseLocalStoreInstance) if (isWin) licenseLocalStoreInstance = WindowsLicenseLocalStore(); else { var e = app.setting.prepDatabase(fingerPrint); licenseLocalStoreInstance = { put: function(n, t) { console.log(`ls put ${n}`), e.getState()[n] = t, e.write() }, get: function(n) { return e.getState()[n] } } } return licenseLocalStoreInstance};function WindowsLicenseLocalStore() { const e = mustRequire(&quot;native-reg&quot;); return { get: function(n) { const t = e.openKey(e.HKCU, &quot;Software\\\\Typora&quot;, e.Access.READ); if (null == t) return &quot;&quot;; const i = e.getValue(t, null, n); return e.closeKey(t), i }, put: function(n, t) { const i = e.createKey(e.HKCU, &quot;Software\\\\Typora&quot;, e.Access.WRITE); e.setValueSZ(i, n, t), e.closeKey(i) } }}const getFingerPrint = async() =&gt; { if (!fingerPrint) { if (isWin) { const e = mustRequire(&quot;native-reg&quot;), n = e.openKey(e.HKEY.LOCAL_MACHINE, &quot;SOFTWARE\\\\Microsoft\\\\Cryptography&quot;, e.Access.WOW64_64KEY | e.Access.READ); fingerPrint = e.getValue(n, null, &quot;MachineGuid&quot;), e.closeKey(n) } else fingerPrint = await require(&quot;node-machine-id&quot;).machineId({ original: !0 }); fingerPrint || Raven.captureMessage(&quot;[License] Failed to get fingerPrint&quot;), fingerPrint = makeHash(fingerPrint, &quot;typora&quot;).substr(0, 10).replace(/[/=+-]/g, &quot;a&quot;), isMac &amp;&amp; (fingerPrint += &quot;darwin&quot;) } return fingerPrint};var licenseInitialed = !1;const watchLicense = async e =&gt; { console.log(&quot;[watchLicense]&quot;), firstValidateLicense(e), await validateTrail(), console.log(`[watchLicense] hasLicense: ${hasLicense}`), showLicensePanelIfNeeded(), addToAnalysis() }, addToAnalysis = () =&gt; { var e = Raven.getContext().tags; e.hasLicense = hasLicense, Raven.mergeContext(e) }, getOS = () =&gt; process.platform.replace(/\\d+/, &quot;&quot;), renewLicense = async(e, n) =&gt; { const t = (new Date).toLocaleDateString(&quot;en-US&quot;); const { deviceId: i, lastRetry: a } = e || {}; if (!n &amp;&amp; new Date - a &lt; 432e5) return; const s = { v: getOS() + &quot;|&quot; + app.getVersion(), license: licenseCode, l: i, u: app.setting.generateUUID(), type: global.devVersion ? &quot;dev&quot; : &quot;&quot; }; JSON.stringify(s); }, getInstallDate = e =&gt; { var n = new Date(getLicenseLocalStore().get(&quot;IDate&quot;)); if (isNaN(n.getTime())) return e ? null : new Date; if (e) return n; var t = 1641734774922; return isNaN(t) ? t = new Date(&quot;2021-10-01&quot;) : (t = new Date(t), isNaN(t.getTime()) &amp;&amp; (t = new Date(&quot;2021-10-01&quot;))), n &lt; t ? t : n }, getTrailRemains = (e, n) =&gt; { n = n || 15; var t = Math.floor((new Date - installDate) / 864e5), i = Math.max(0, n - t); return e &amp;&amp; (i &gt; n || isNaN(i)) &amp;&amp; (i = n), i }, validateTrail = async() =&gt; { var e = (installDate = getInstallDate(!global.devVersion)) ? getTrailRemains(!1) : 100; (e &gt; 15 || isNaN(e)) &amp;&amp; (console.log(&quot;[validateTrail] Read from incorrupted InstallDate&quot;), await writeInstallDate(!0), e = 15), console.log(`[validateTrail] installDate is ${installDate.toLocaleDateString(&quot;en-US&quot;)}, trail remains: ${e} days`) };function fillLicense(e, n) { licenseCode = n, (hasLicense = !(!(email = e) || !licenseCode)) &amp;&amp; onFillLicense()}function unfillLicense(e) { hasLicense || (e = &quot;&quot;), email = &quot;&quot;, licenseCode = &quot;&quot;, hasLicense = !1, getLicenseLocalStore().put(&quot;SLicense&quot;, &quot;&quot;), e &amp;&amp; showDialog(Dict.getPanelString(&quot;Typora is now deactivated&quot;), Dict.getPanelString(e)), onUnfillLicense()}const firstValidateLicense = e =&gt; { console.log(&quot;[License] firstValidateLicense&quot;), licenseInitialed = !0; const n = readLicenseInfo(), { license: t, email: i } = n || {}; t &amp;&amp; i ? (fillLicense(i, t), renewLicense(n, e), console.log(&quot;[License] pass validateLicenseInfoStr&quot;)) : unfillLicense() }, showDialog = (e, n) =&gt; electron.dialog.showMessageBox(null, { type: &quot;error&quot;, buttons: [&quot;OK&quot;], defaultId: 0, cancelId: 0, title: e, message: n }), endDevTest = function() { app.expired = !0, showDialog(Dict.getPanelString(&quot;Error&quot;), Dict.getPanelString(&quot;This beta version of Typora is expired, please download and install a newer version.&quot;)).then(() =&gt; { shell.openExternal(&quot;https://typora.io/#download&quot;), setTimeout(() =&gt; { process.exit(1) }, 1e3) }) }, validateDevTest = function() { if (!hasLicense &amp;&amp; !isLinux &amp;&amp; global.devVersion &amp;&amp; global.PRODUCTION_MODE) { var e = getInstallDate(), n = new Date; console.log(&quot;buildTime is 1641734774922&quot;), (isNaN(1641734774922) || n - 1641734774922 &gt; 20736e6) &amp;&amp; endDevTest(), e -= 0, console.log(&quot;verInitTime is &quot; + e), !isNaN(e) &amp;&amp; n - e &gt; 1728e7 &amp;&amp; endDevTest() } }, showLicensePanelIfNeeded = function() { shouldShowNoLicenseHint(!0) &amp;&amp; !app.setting.inFirstShow &amp;&amp; (isLinux &amp;&amp; Math.random() &lt; .95 || (!lastShown || new Date - lastShown &gt; 36e5 * (isLinux ? 4 : 2) || getTrailRemains(!0, 20) &lt;= 0) &amp;&amp; showLicensePanel()) };var licensePanel = null;const showLicensePanel = async function(e) { if (lastShown = new Date, null == licensePanel) return (licensePanel = WindowController.showPanelWindow({ width: 525, height: 420, path: `page-dist/license.html?dayRemains=${getTrailRemains(!0)}&amp;index=${e?1:0}\\n\\t\\t\\t\\t&amp;hasActivated=${hasLicense||!1}&amp;email=${email}&amp;license=${licenseCode}&amp;lang=${app.setting.getUserLocale()}&amp;needLicense=${shouldShowNoLicenseHint()}`, frame: !1, alwaysOnTop: !errorShown })).on(&quot;closed&quot;, function() { licensePanel = null }), void setTimeout(() =&gt; { licensePanel &amp;&amp; !licensePanel.isDestroyed() &amp;&amp; licensePanel.setAlwaysOnTop(!1) }, 5e3); licensePanel.focus()};var welcomePanel = null;const showWelcomePanel = async function() { if (lastShown = new Date, null == welcomePanel) return (welcomePanel = WindowController.showPanelWindow({ width: 760, height: 460, path: `page-dist/welcome.html?lang=${app.setting.getUserLocale()}`, frame: !1, alwaysOnTop: !errorShown })).on(&quot;closed&quot;, function() { welcomePanel = null }), void setTimeout(() =&gt; { welcomePanel &amp;&amp; !welcomePanel.isDestroyed() &amp;&amp; welcomePanel.setAlwaysOnTop(!1) }, 4e3); welcomePanel.focus() }, quickValidate = e =&gt; { const n = &quot;L23456789ABCDEFGHJKMNPQRSTUVWXYZ&quot;; if (!/^([A-Z0-9]{6}-){3}[A-Z0-9]{6}$/.exec(e)) return !1; var t = e.replace(/-/g, &quot;&quot;), i = t.substr(22); return !t.replace(/[L23456789ABCDEFGHJKMNPQRSTUVWXYZ]/g, &quot;&quot;) &amp;&amp; i == (e =&gt; { for (var t = &quot;&quot;, i = 0; i &lt; 2; i++) { for (var a = 0, s = 0; s &lt; 16; s += 2) a += n.indexOf(e[i + s]); t += n[a %= n.length] } return t })(t) }, getComputerName = async function() { var e = process.env.USER; switch (e || (e = require(&quot;os&quot;).userInfo().username), process.platform) { case &quot;win32&quot;: return process.env.COMPUTERNAME + &quot; | &quot; + e + &quot; | Windows&quot;; case &quot;darwin&quot;: return new Promise(n =&gt; { require(&quot;child_process&quot;).exec(&quot;scutil --get ComputerName&quot;, { timeout: 5e3 }, (t, i) =&gt; { n(!t &amp;&amp; i ? i.toString().trim() + &quot; | &quot; + e + &quot; | darwin&quot; : require(&quot;os&quot;).hostname() + &quot; | &quot; + e + &quot; | darwin&quot;) }) }); default: return require(&quot;os&quot;).hostname() + &quot; | &quot; + e + &quot; | Linux&quot; } }, doActivation = async function(e, n, t) { if (e = (e || &quot;&quot;).replace(/^[\\s\\u200b ]/g, &quot;&quot;).replace(/[\\s\\u200b ]$/g, &quot;&quot;), n = (n || &quot;&quot;).replace(/^[\\s\\u200b ]/g, &quot;&quot;).replace(/[\\s\\u200b ]$/g, &quot;&quot;), ! function(e) { return /^[^\\s@'&quot;/\\\\=?]+@[^\\s@'&quot;/\\\\]+\\.[^\\s@'&quot;/\\\\]+$/.test(e) }(e)) return [!1, &quot;Please input a valid email address&quot;]; //if (!quickValidate(n)) return [!1, &quot;Please input a valid license code&quot;]; const i = { v: getOS() + &quot;|&quot; + app.getVersion(), license: n, email: e, l: await getComputerName(), f: await getFingerPrint(), u: app.setting.generateUUID(), type: global.devVersion ? &quot;dev&quot; : &quot;&quot;, force: t }; JSON.stringify(i); try { const e = { data: { code: 0, msg: Buffer.from(JSON.stringify( { deviceId: i.u, fingerprint: i.f, email: i.email, license: i.license, version: i.v, date: 1 }),&quot;utf8&quot;).toString(&quot;base64&quot;) } } if (JSON.stringify(e.data), console.log(`[License] response code is ${e.data.code}`), e.data.code == ActiveResponseCode.SUCCESS) return await writeActivationInfo(e.data.msg) ? [!0, &quot;&quot;] : [!1, &quot;Please input a valid license code&quot;]; if (e.data.code == ActiveResponseCode.OUT_OF_LIMIT) return t ? await writeActivationInfo(e.data.msg) ? [!0, &quot;Your license has exceeded the max devices numbers.\\nThe oldest device was unregistered automatically.&quot;] : [!1, &quot;Please input a valid license code&quot;] : [&quot;confirm&quot;, 'Your license has exceeded the max devices numbers.\\nIf you click &quot;Continue Activation&quot;, this device will be activated and the oldest device will be unregistered automatically.']; if (e.data.code == ActiveResponseCode.INVALIDATE) return [!1, &quot;Please input a valid license code&quot;]; if (e.data.code == ActiveResponseCode.WRONG_USER) return [!1, &quot;This license code has been used with a different email address.&quot;] } catch (e) { return e.response &amp;&amp; e.response.code ? (console.warn(`[License] error from server ${e.response.code}`), [!1, &quot;Unknown Error. Please contact hi@typora.io&quot;]) : (Raven.captureException(e, { level: &quot;warning&quot; }), console.error(e.stack), [!1, &quot;Failed to access the license server. Please check your network or try again later.&quot;]) } }, writeActivationInfo = async function(e) { const n = decrypt(e) || {}, { deviceId: t, fingerprint: i, email: a, license: s, version: o, date: r } = n; fillLicense(a, s); getLicenseLocalStore().put(&quot;SLicense&quot;, `${e}#0#${(new Date).toLocaleDateString(&quot;en-US&quot;)}`); hasLicense = !0; return 1; //return i == await getFingerPrint() &amp;&amp; a &amp;&amp; s ? (fillLicense(a, s), getLicenseLocalStore().put(&quot;SLicense&quot;, `${e}#0#${(new Date).toLocaleDateString(&quot;en-US&quot;)}`), hasLicense = !0, !0) : (console.log(&quot;[License] validate server return fail&quot;), unfillLicense(), !1) }, doDeactivation = async() =&gt; { hasLicense &amp;&amp; email &amp;&amp; licenseCode || console.error(&quot;doDeactivation on unregistered device&quot;); const { deviceId: e } = readLicenseInfo() || {}; unfillLicense() };ipc.handle(&quot;addLicense&quot;, async(e, { email: n, license: t, force: i}) =&gt; { console.log(&quot;handle addLicense&quot;); try { return await doActivation(n, t, i) } catch (e) { console.error(e.stack) }}), ipc.handle(&quot;license.show&quot;, (e, n) =&gt; { showLicensePanel(n || !1)}), ipc.handle(&quot;license.show.debug&quot;, () =&gt; { licensePanel &amp;&amp; licensePanel.webContents.openDevTools()}), ipc.handle(&quot;removeLicense&quot;, async e =&gt; { console.log(&quot;handle removeLicense&quot;); try { return await doDeactivation() } catch (e) { console.error(e.stack) }}); start = async(e, n) =&gt; { console.log(`start LM in devVersion=${global.devVersion||!1}`); try { await getFingerPrint(), !e &amp;&amp; n || isLinux || (global.devVersion || !n || n.indexOf(&quot;dev&quot;) &gt; -1) &amp;&amp; (console.log(&quot;re-write InstallDate&quot;), await writeInstallDate()), validateDevTest(), watchLicense(e) } catch (e) { Raven.captureException(e) } }, shouldShowNoLicenseHint = e =&gt; !hasLicense &amp;&amp; (e || !isLinux) &amp;&amp; !global.devVersion, getHasLicense = () =&gt; hasLicense, appendLicenseHintIfNeeded = e =&gt; { licenseInitialed &amp;&amp; shouldShowNoLicenseHint() &amp;&amp; onUnfillLicense(e) };function genClassName() { var e = (new Date).getTime(); return &quot;txxxx-xxxx-xxxxy&quot;.replace(/[x]/g, function(n) { var t = (e + 16 * Math.random()) % 16 | 0; return e = Math.floor(e / 16), t.toString(16) })}const className = genClassName(), onFillLicense = () =&gt; { BrowserWindow.getAllWindows().forEach(e =&gt; { e.webContents.executeJavaScript(`try{document.querySelector(&quot;.${className}&quot;).remove();}catch(e){};File.option &amp;&amp; (File.option.hasLicense = true);File.megaMenu &amp;&amp; File.megaMenu.forceReload();0;`) }) }, onUnfillLicense = async e =&gt; { if (isLinux || global.devVersion) return; await Dict.init(); const n = `.typora-sourceview-on .${className}{\\n\\t\\tdisplay:none;\\n\\t}\\n\\t.${className} {\\n\\t\\tposition: fixed;\\n bottom: 2px;\\n z-index: 9999;\\n left: 70px;\\n font-size: 12px;\\n line-height: 24px;\\n background: rgb(120 120 120 / 30%);\\n padding: 0 12px;\\n color: var(--text-color);\\n border-radius: 4px;\\n cursor: pointer;\\n\\t}\\n\\t.pin-outline .${className}{\\n\\t\\tleft:calc(var(--sidebar-width) + 70px);\\n\\t}`, t = `if(window.File.option){\\n\\t\\tFile.option.hasLicense = false; \\n\\t\\tFile.megaMenu &amp;&amp; File.megaMenu.forceReload();\\n\\t\\tif(!document.querySelector(&quot;.${className}&quot;)) {\\n\\t\\t\\tconst pos = Math.round(Math.random() * document.body.children.length);\\n\\t\\t\\tconst dom = document.createElement(&quot;DIV&quot;);\\n\\t\\t\\tdom.innerText = &quot;${Dict.getPanelString(&quot;UNREGISTERED&quot;)} Ã&quot;;\\n\\t\\t\\tdom.classList.add(&quot;${className}&quot;);\\n\\t\\t\\tdom.style = &quot;position: fixed !important;bottom: 2px !important; display: block !important; opacity: 1 !important; height: auto !important; width: auto !important; z-index: 9999 !important;&quot;\\n\\t\\t\\tdom.setAttribute(&quot;role&quot;, &quot;button&quot;);\\n\\t\\t\\tdom.addEventListener(&quot;click&quot;, () =&gt; {\\n\\t\\t\\t\\tdom.remove();\\n\\t\\t\\t\\treqnode(&quot;electron&quot;).ipcRenderer.invoke(&quot;license.show&quot;);\\n\\t\\t\\t});\\n\\t\\t\\tdocument.body.insertBefore(dom, document.body.children[pos]);\\n\\t\\t}\\n\\t};1;`; function i(e) { e.webContents.insertCSS(n), e.webContents.executeJavaScript(t) } e ? i(e) : BrowserWindow.getAllWindows().forEach(i) };exports.shouldShowNoLicenseHint = shouldShowNoLicenseHint, exports.start = start, exports.showLicensePanel = showLicensePanel, exports.showWelcomePanel = showWelcomePanel, exports.appendLicenseHintIfNeeded = appendLicenseHintIfNeeded, exports.getHasLicense = getHasLicense, exports.showLicensePanelIfNeeded = showLicensePanelIfNeeded; patch掉网络验证，对doActivation的验证直接改成永恒真，使得邮箱和序列号随便填即可激活，再改写hasLicense的值，使得下次登录时访问许可证信息时得到软件已被激活的信息，再打包生成app.asar，打开软件随便输入序列号和邮箱即可 5. 破解成功","link":"/2023/09/18/Typora%E7%A0%B4%E8%A7%A3%E8%AE%B0%E5%BD%95/"},{"title":"扫雷辅助制作","text":"最近对游戏安全比较感兴趣,想往这方面深造,于是便开始看战队里在腾讯游戏安全工作的大佬的博客,以便熟悉一下大佬的学习思路,发现他会从扫雷这种简单的游戏外挂开始着手学习,我也感兴趣的进行了一次扫雷辅助的实现 寻找地图首地址容易想到的是,扫雷游戏在代码中肯定是要有对雷和非雷的数字型描述,所以用CE不断翻开雷块应该可以轻松找到地图地址,但是为了脱离对CE的依赖并且提高自己的游戏代码的审计能力,还是决定麻烦点用IDA找到地图首地址 打开IDA,发现iDa没有识别出winmain入口 于是开始从导入表中找是否有关键函数调用,找到了一个rand(),联想到rand函数可以随机化雷的x,y坐标,应该有点用,两轮交叉引用找到关键播种函数 这里看到利用byte_1005340数组和宽高进行寻址赋值,貌似是地图首地址,下断点IDA动调一手,找到0x1005340处内存地址 点两个雷块确认这个是地图首地址,并且确认了整型数对应的雷块类型 123450xF: 没有雷0x8F: 雷0x8a: 是地雷且格子被翻开0x40: 格子被翻开且周围都没有雷0x4X: 格子被翻开且周围有X个地雷 既然确认了雷块地址和整型数含义,我们就可以画出对应的地图实现透视 扫雷透视辅助代码实现这里用MFC写了一个窗口,利用按钮的槽函数实现透视 具体实现过程描述:spy++ 查看窗口类名,标题-&gt;GetWindowHandle获取窗口句柄-&gt;GetWindowThreadProcessId获取进程id-&gt;OpenProcess打开进程-&gt;ReadProcessMemory访问并读取内存-&gt;SetWindowText对edit control控件进行地图描绘 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void CwinMine2Dlg::OnBnClickedgetmap(){ //spy++ 查看窗口类名,标题 HWND hwnd = GetWindowHandle(&quot;扫雷&quot;, &quot;扫雷&quot;); if (hwnd) { DWORD pid; GetWindowThreadProcessId(hwnd, &amp;pid); HANDLE handle = OpenProcess(PROCESS_ALL_ACCESS, false, pid); LPCVOID mapBaseAddr = (LPCVOID)0x1005340; LPCVOID xAddr = (LPCVOID)0x1005334; LPCVOID yAddr = (LPCVOID)0x1005338; ReadProcessMemory(handle, mapBaseAddr, (LPVOID)mapBuffer, sizeof(mapBuffer), NULL); ReadProcessMemory(handle, xAddr, &amp;X, sizeof(X), NULL); ReadProcessMemory(handle, yAddr, &amp;Y, sizeof(Y), NULL); m_data.Empty(); PrintMap(mapBuffer, X, Y, m_data); mmap.SetWindowText(m_data); } else { MessageBox(TEXT(&quot;can't find window&quot;)); }}//这里对FindWindowA进行了简单的封装HWND GetWindowHandle(std::string className, std::string windowName){ HWND hwnd = FindWindowA(className.c_str(), windowName.c_str()); return hwnd;}void PrintMap(byte* mapBuffer, int X, int Y,CString&amp; m_data){ CString tmp = TEXT(&quot;&quot;); for (int i = 1; i &lt;= Y; i++) { for (int j = 1; j &lt;= X; j++) { if ((*(mapBuffer + i * 32 + j) &amp; 0x80) != 0) { tmp.Format(TEXT(&quot;1&quot;));//1代表雷 } else tmp.Format(TEXT(&quot;0&quot;));//0代表非雷 m_data += tmp; } m_data += TEXT(&quot;\\r\\n&quot;);//一定要/r/n才能换行 printf(&quot;\\n&quot;); }} 实现效果图: 光有透视可不行,进一步通过模拟鼠标点击实现一键扫雷才是关键 一键扫雷辅助代码实现具体实现过程描述:spy++ 查看窗口类名,标题-&gt;GetWindowHandle获取窗口句柄-&gt;MAKELPARAM对鼠标坐标x,y进行封装-&gt;PostMessage向窗口传入WM_LBUTTONDOWN和WM_LBUTTONUP的消息 坐标x,y可以用spy++来过滤日志消息对WM_LBUTTONDOWN和WM_LBUTTONUP落点进行粗略观察也可以进行ida代码分析得出 这里应该是通过地图的宽高确定窗口的右边缘坐标和下边缘坐标,所以16应该是雷块间的间隔,24,67应该是第一个雷块的右边缘坐标和下边缘坐标 这里对PostMessage以及MAKELPARAM函数做个简单的记录 PostMessage 是 MFC 中的一个函数，用于向指定的窗口发送消息。让我详细介绍一下这个函数： 功能： PostMessage 函数将一个消息放入与创建窗口的线程相关联的消息队列中，并立即返回，不会阻塞当前线程。这使得它适用于异步消息传递。 参数： hwnd: 目标窗口的句柄。这是要接收消息的窗口。 msg: 要发送的消息类型，例如 WM_USER 或自定义消息。 wParam 和 lParam: 32 位的参数，用于传递额外的消息数据。这些参数的具体含义取决于消息类型。 第四个参数是 lParam，它是一个 32 位的整数值，用于传递额外的消息参数。在 PostMessage 函数中，我们通常使用它来传递鼠标点击的坐标。 具体来说，对于鼠标消息，lParam 的高 16 位表示鼠标的 Y 坐标，低 16 位表示鼠标的 X 坐标。这样，我们可以将 X 和 Y 坐标合并到一个 32 位整数中，以便在消息处理函数中解析。 123456789101112131415161718192021222324252627void CwinMine2Dlg::OnBnClickedsaolei(){ HWND hwnd = GetWindowHandle(&quot;扫雷&quot;, &quot;扫雷&quot;); if (hwnd) { for (int i = 1; i &lt;= Y; i++) { for (int j = 1; j &lt;= X; j++) { int x = Firstx + Xgap * (j - 1); int y = Firsty + Ygap * (i - 1); LPARAM lparam = MAKELPARAM(x, y); if ((*(mapBuffer + i * 32 + j) &amp; 0x80) == 0) { ::PostMessage(hwnd, WM_LBUTTONDOWN, 0 , lparam); ::PostMessage(hwnd, WM_LBUTTONUP, 0, lparam); } } printf(&quot;\\n&quot;); } } else { MessageBox(TEXT(&quot;can't find window&quot;)); }} 实现效果图: dll注入调用call实现一键扫雷通过简单的猜想可以知道,代码里肯定是会有一个函数去处理鼠标点击坐标进行判断结果的,所以可以去追溯查找一下鼠标点击坐标的引用,之前通过rand函数交叉引用到的函数继续溯源找到主要程序入口点位置 继续通过交叉引用直出现到MFC程序轮廓代码,如下图 通过lpfnWndProc名字我们大概可以分析出sub_1001BC9函数应该是处理while(1)循环的函数,进去一探究竟 在这块区域我们可以看到v4的高16位和低16位进行一些处理得到v12,v13,并且if循环里dword_1005334和dword_1005338我们之前分析得到这是宽和高,所以v12,v13应该就是处理过的x,y坐标,v4是原来鼠标点击的xy坐标 通过调试验证猜想成功 对这两个变量下读写断点,动调找到可能的call指令 动调发现分别是在sub_1002646和sub_1003512处发生雷块按下和抬起的动画,交叉引用找到调用他们的母函数,分别是在0x10031D4,0x10037E1处,利用汇编注入工具测试验证猜测 验证猜测成功后开始写注入代码 MFC辅助程序中添加控件和槽函数以及注入函数模版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//槽函数void CwinMine2Dlg::OnBnClickedZhuru(){ DWORD ProcessID = ProcessFind(_T(&quot;saolei.exe&quot;)); WCHAR WorkPath[MAX_PATH]; //用于存放获取路径的信息 GetModuleFileName(NULL, WorkPath, MAX_PATH); CString DllPath = WorkPath; int pos = DllPath.ReverseFind('\\\\'); // 查找倒数最后一个‘\\\\’符号 DllPath = DllPath.Left(pos + 1); DllPath += _T(&quot;first.dll&quot;); bool IsInjected = InjectDll(ProcessID, DllPath); if (IsInjected) { MessageBox(_T(&quot;注入成功!&quot;)); } else { MessageBox(_T(&quot;注入失败!&quot;)); } // TODO: 在此添加控件通知处理程序代码}//solve.hBOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath){ HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; // #1. 使用dwPID获取目标进程（notepad.exe）的HANDLE if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) { _tprintf(L&quot;OpenProcess(%d) failed!!! [%d]\\n&quot;, dwPID, GetLastError()); return FALSE; } // #2. 将szDllName大小的内存分配给目标进程（notepad.exe）内存。 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); // #3. 在分配的内存中写入myhack.dll路径（&quot;c:\\\\myhack.dll&quot;）。 WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL); // #4. 获取LoadLibraryA() API地址。 hMod = GetModuleHandle(L&quot;kernel32.dll&quot;); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &quot;LoadLibraryW&quot;); // #5. 在notepad.exe进程中运行线程 hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;}DWORD ProcessFind(LPCTSTR Exename){ HANDLE hProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (!hProcess) { return FALSE; } PROCESSENTRY32 info; info.dwSize = sizeof(PROCESSENTRY32); if (!Process32First(hProcess, &amp;info)) { return FALSE; } while (true) { if (_tcscmp(info.szExeFile, Exename) == 0) { return info.th32ProcessID; } if (!Process32Next(hProcess, &amp;info)) { return FALSE; } } return FALSE;} dll代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//dllmain.cpp// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &quot;windows.h&quot;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &quot;solve.h&quot;using namespace std;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { Saolei(); } } return TRUE;}//Saolei.cpp#include &quot;solve.h&quot;#include &quot;pch.h&quot;void Saolei(){ LPCVOID mapBaseAddr = (LPCVOID)0x1005340; LPCVOID xAddr = (LPCVOID)0x1005334; LPCVOID yAddr = (LPCVOID)0x1005338; int tempx = 0, tempy = 0; int x = *(int*)xAddr; int y = *(int*)yAddr; for (int i = 1; i &lt;= y; i++) { for (int j = 1; j &lt;= x; j++) { if ((*((BYTE*)mapBaseAddr + i * 32 + j) &amp; 0x80) == 0) { tempx = i; tempy = j; __asm { push tempx push tempy mov eax, 0x10031D4 call eax mov eax, 0x10037E1 call eax } if (3 == *(int*)0x1005160) { // 判断当前游戏状态 0为正在游戏 2为扫雷失败 3为扫雷成功 return; } } } }} 效果图:","link":"/2024/01/27/%E6%89%AB%E9%9B%B7%E8%BE%85%E5%8A%A9/"},{"title":"逆向笔记","text":"逆向的开始！从这开始记录我在做逆向题目时遇到的问题以及总结一些逆向的知识点 BFS脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;char map[15][13]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,0,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,0,0,1,1,1,1,0,4,1,1,1,1,1,1,1,1,1,1,1,1,1};struct Point{ int x; int y; string path; char mp[15][13]={0};//标记路线};char w1[4] = {0,1,0,-1};char w2[4] = {1,0,-1,0};char pa[5] = &quot;sdwa&quot;;queue&lt;Point&gt;q;int main(){ Point first = {1,1,&quot;&quot;}; first.mp[first.y][first.x]=1; q.push(first); while(!q.empty()) { Point now = q.front(); q.pop(); for(int i=0;i&lt;4;i++) { Point temp = now; temp.x+=w1[i]; temp.y+=w2[i]; temp.path+=pa[i]; if(map[temp.y][temp.x]==4) { cout&lt;&lt;temp.path&lt;&lt;endl; } if(map[temp.y][temp.x]==0&amp;&amp;temp.x&gt;=0&amp;&amp;temp.x&lt;13&amp;&amp;temp.y&gt;=0&amp;&amp;temp.y&lt;15&amp;&amp;temp.mp[temp.y][temp.x]==0) { temp.mp[temp.y][temp.x]=1; q.push(temp); } } } } Frida环境搭建与测试：进入开发者模式，与手机进行连接adb connect 127.0.0.1:62001（PC端命令行） 查看是否连接成功 adb devices frida-server处理器类型与Android处理器对齐 查询虚拟机处理器架构: adb shell getprop ro.product.cpu.abi 进入frida移动端目录 adb shell cd /data/local/tmp 运行 ./frida-server 执行 frida -U -f MyApplication 进行连接\\ 显示找不到MyApplication,查询app名称的id frida-ps -U -a 结果: 再次执行 frida -U -f com.example.myapplication 连接成功,脚本测试 12345678910111213141516171819202122232425import fridaimport sys def on_message(message, data): if message['type'] == 'send': print(&quot;*****[frida hook]***** : {0}&quot;.format(message['payload'])) else: print(&quot;*****[frida hook]***** : &quot; + str(message)) #js脚本jscode = &quot;&quot;&quot;Java.perform(function () { var MainActivity = Java.use('com.example.myapplication.MainActivity'); MainActivity.print.implementation = function(){ send(&quot;Hook Start&quot;); }; });&quot;&quot;&quot; process = frida.get_usb_device().attach('MyApplication')#应用程序名称,和包名不一样script = process.create_script(jscode)script.on('message', on_message)print('[*] Running CTF')script.load()sys.stdin.read() RC4解密脚本：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import base64from Crypto.Util.number import long_to_bytesdef rc4_setup(key): if isinstance(key, str): key = key.encode() S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] return Sdef rc4_crypt(data, key):#文本解密 if isinstance(data, str): data = data.encode() S = rc4_setup(key) i, j = 0, 0 res = [] for byte in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] res.append(byte ^ S[(S[i] + S[j]) % 256]) return bytes(res)def rc4_decrypt(key_hex, data_hex):#十六进制解密 key = bytes.fromhex(key_hex) data = bytes.fromhex(data_hex) res = rc4_crypt(data, key) return res.hex() if __name__ == '__main__': enc = b'FUZAza8WP5FERi17FvdHowYFSNs6cOk1h0tQLSqk' key = b'BirkenwaldCTF{This_is_f4ke_f1ag}' enc = base64.b64decode(enc) enc = rc4_decrypt(key.hex(),enc.hex()) enc = long_to_bytes(int(enc,16)).decode() print(enc) &amp;0xff在python中可以表示取无符号整数，0xff表示八个比特1，也就是数byte数进行无符号运算,&amp;0x7f表示取有符号字节类型 RC4的c语言加密脚本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#pragma warning(disable:4996)unsigned char data[26] = { 0x4e,0xd5,0xc,0xed,0x4d,0xbf,0x9e,0xe8,0x43,0x50,0x8,0xd0,0xa0,0xe2,0x4b,0x62,0xbe,0xab,0x0,0x22,0xb3,0xd8,0x68,0x3f,0x80,0xa4 };// 初始化 S 表，根据密钥打乱 S 表void init(unsigned char* S, const unsigned char* key, int keylen) { for (int i = 0; i &lt; 256; i++) { S[i] = i; } int j = 0; for (int i = 0; i &lt; 256; i++) { j = (j + S[i] + key[i % keylen]) % 256; // 交换 S[i] 和 S[j] unsigned char temp = S[i]; S[i] = S[j]; S[j] = temp; }}// 生成一个字节的密钥流unsigned char generate(unsigned char* S, int* i, int* j) { *i = (*i + 1) % 256; *j = (*j + S[*i]) % 256; // 交换 S[i] 和 S[j] unsigned char temp = S[*i]; S[*i] = S[*j]; S[*j] = temp; // 返回 S[S[i] + S[j]] return S[(S[*i] + S[*j]) % 256];}// 对数据进行加密或解密void encrypt(unsigned char* data, int datalen, const unsigned char* key, int keylen) { unsigned char S[256]; // 256 字节的数据表 int i = 0, j = 0; // 两个索引变量 // 初始化 S 表 init(S, key, keylen); for (int k = 0; k &lt; datalen; k++) { // 数据和密钥流进行异或运算 data[k] ^= generate(S, &amp;i, &amp;j); }}// 测试函数int main() { // 假设这是要加密或解密的数据 unsigned char input[26]; printf(&quot;Do you know flag?\\n&quot;); printf(&quot;Please tell me:\\n&quot;); scanf(&quot;%s&quot;, input); //unsigned char data[] = &quot;CynopsCTF{RC4_1s_4w3s0m3!}&quot;; int datalen = 26; // 假设这是加密或解密的密钥 unsigned char key[] = &quot;CynopsCTF{This_is_f4ke_f1ag}&quot;; int keylen = strlen((char*)key); // 对数据进行加密 encrypt(input, datalen, key, keylen); for (int i = 0; i &lt; 26; i++) { if (input[i] != data[i]) goto label; } printf(&quot;You're so smart. This's what I want!!!\\n&quot;); system(&quot;pause&quot;); exit(0);label: printf(&quot;Oh,You don't seem to know what I want\\n&quot;); printf(&quot;Please leave here\\n&quot;); system(&quot;pause&quot;); exit(0); return 0;} AES加解密C脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;aes.h&quot;/** * S盒 */static const int S[16][16] = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };/** * 逆S盒 */static const int S2[16][16] = { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };/** * 获取整形数据的低8位的左4个位 */static int getLeft4Bit(int num) { int left = num &amp; 0x000000f0; return left &gt;&gt; 4;}/** * 获取整形数据的低8位的右4个位 */static int getRight4Bit(int num) { return num &amp; 0x0000000f;}/** * 根据索引，从S盒中获得元素 */static int getNumFromSBox(int index) { int row = getLeft4Bit(index); int col = getRight4Bit(index); return S[row][col];}/** * 把一个字符转变成整型 */static int getIntFromChar(char c) { int result = (int)c; return result &amp; 0x000000ff;}/** * 把16个字符转变成4X4的数组， * 该矩阵中字节的排列顺序为从上到下， * 从左到右依次排列。 */static void convertToIntArray(char* str, int pa[4][4]) { int k = 0, i = 0, j = 0; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) { pa[j][i] = getIntFromChar(str[k]); k++; }}/** * 打印4X4的数组 */static void printArray(int a[4][4]) { int i, j; for (i = 0; i &lt; 4; i++) { for (j = 0; j &lt; 4; j++) printf(&quot;a[%d][%d] = 0x%x &quot;, i, j, a[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;);}/** * 打印字符串的ASSCI， * 以十六进制显示。 */static void printASSCI(char* str, int len) { int i; for (i = 0; i &lt; len; i++) printf(&quot;0x%x &quot;, getIntFromChar(str[i])); printf(&quot;\\n&quot;);}/** * 把连续的4个字符合并成一个4字节的整型 */static int getWordFromStr(char* str){ int one = getIntFromChar(str[0]); one = one &lt;&lt; 24; int two = getIntFromChar(str[1]); two = two &lt;&lt; 16; int three = getIntFromChar(str[2]); three = three &lt;&lt; 8; int four = getIntFromChar(str[3]); return one | two | three | four;}/** * 把一个4字节的数的第一、二、三、四个字节取出， * 入进一个4个元素的整型数组里面。 */static void splitIntToArray(int num, int array[4]) { int one = num &gt;&gt; 24; array[0] = one &amp; 0x000000ff; int two = num &gt;&gt; 16; array[1] = two &amp; 0x000000ff; int three = num &gt;&gt; 8; array[2] = three &amp; 0x000000ff; array[3] = num &amp; 0x000000ff;}/** * 将数组中的元素循环左移step位 */static void leftLoop4int(int array[4], int step) { int temp[4]; int i; for (i = 0; i &lt; 4; i++) temp[i] = array[i]; int index = step % 4 == 0 ? 0 : step % 4; for (i = 0; i &lt; 4; i++) { array[i] = temp[index]; index++; index = index % 4; }}/** * 把数组中的第一、二、三和四元素分别作为 * 4字节整型的第一、二、三和四字节，合并成一个4字节整型 */static int mergeArrayToInt(int array[4]) { int one = array[0] &lt;&lt; 24; int two = array[1] &lt;&lt; 16; int three = array[2] &lt;&lt; 8; int four = array[3]; return one | two | three | four;}/** * 常量轮值表 */static const int Rcon[10] = { 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000 };/** * 密钥扩展中的T函数 */static int T(int num, int round) { int numArray[4]; splitIntToArray(num, numArray); leftLoop4int(numArray, 1);//字循环 int i; //字节代换 for (i = 0; i &lt; 4; i++) numArray[i] = getNumFromSBox(numArray[i]); int result = mergeArrayToInt(numArray); return result ^ Rcon[round];}//密钥对应的扩展数组static int w[44];/** * 扩展密钥，结果是把w[44]中的每个元素初始化 */static void extendKey(char* key){ int i, j; for (i = 0; i &lt; 4; i++) w[i] = getWordFromStr(key + i * 4); for (i = 4, j = 0; i &lt; 44; i++) { if (i % 4 == 0) { w[i] = w[i - 4] ^ T(w[i - 1], j); j++;//下一轮 } else w[i] = w[i - 4] ^ w[i - 1]; }}/** * 轮密钥加 */static void addRoundKey(int array[4][4], int round) { int warray[4]; int i, j; for (i = 0; i &lt; 4; i++) { splitIntToArray(w[round * 4 + i], warray); for (j = 0; j &lt; 4; j++) { array[j][i] = array[j][i] ^ warray[j]; } }}/** * 字节代换 */static void subBytes(int array[4][4]) { int i, j; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) array[i][j] = getNumFromSBox(array[i][j]);}/** * 行移位 */static void shiftRows(int array[4][4]) { int rowTwo[4], rowThree[4], rowFour[4]; //复制状态矩阵的第2,3,4行 int i; for (i = 0; i &lt; 4; i++) { rowTwo[i] = array[1][i]; rowThree[i] = array[2][i]; rowFour[i] = array[3][i]; } //循环左移相应的位数 leftLoop4int(rowTwo, 1); leftLoop4int(rowThree, 2); leftLoop4int(rowFour, 3); //把左移后的行复制回状态矩阵中 for (i = 0; i &lt; 4; i++) { array[1][i] = rowTwo[i]; array[2][i] = rowThree[i]; array[3][i] = rowFour[i]; }}/** * 列混合要用到的矩阵 */static const int colM[4][4] = { 2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2 };static int GFMul2(int s) { int result = s &lt;&lt; 1; int a7 = result &amp; 0x00000100; if (a7 != 0) { result = result &amp; 0x000000ff; result = result ^ 0x1b; } return result;}static int GFMul3(int s) { return GFMul2(s) ^ s;}static int GFMul4(int s) { return GFMul2(GFMul2(s));}static int GFMul8(int s) { return GFMul2(GFMul4(s));}static int GFMul9(int s) { return GFMul8(s) ^ s;}static int GFMul11(int s) { return GFMul9(s) ^ GFMul2(s);}static int GFMul12(int s) { return GFMul8(s) ^ GFMul4(s);}static int GFMul13(int s) { return GFMul12(s) ^ s;}static int GFMul14(int s) { return GFMul12(s) ^ GFMul2(s);}/** * GF上的二元运算 */static int GFMul(int n, int s) { int result; if (n == 1) result = s; else if (n == 2) result = GFMul2(s); else if (n == 3) result = GFMul3(s); else if (n == 0x9) result = GFMul9(s); else if (n == 0xb)//11 result = GFMul11(s); else if (n == 0xd)//13 result = GFMul13(s); else if (n == 0xe)//14 result = GFMul14(s); return result;}/** * 列混合 */static void mixColumns(int array[4][4]) { int tempArray[4][4]; int i, j; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) tempArray[i][j] = array[i][j]; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) { array[i][j] = GFMul(colM[i][0], tempArray[0][j]) ^ GFMul(colM[i][1], tempArray[1][j]) ^ GFMul(colM[i][2], tempArray[2][j]) ^ GFMul(colM[i][3], tempArray[3][j]); }}/** * 把4X4数组转回字符串 */static void convertArrayToStr(int array[4][4], char* str) { int i, j; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) *str++ = (char)array[j][i];}/** * 检查密钥长度 */static int checkKeyLen(int len) { if (len == 16) return 1; else return 0;}/** * 参数 p: 明文的字符串数组。 * 参数 plen: 明文的长度。 * 参数 key: 密钥的字符串数组。 */void aes(char* p, int plen, char* key) { int keylen = strlen(key); if (!checkKeyLen(keylen)) { printf(&quot;keylen erro;keylen=%d\\n&quot;, keylen); exit(0); } extendKey(key);//扩展密钥 int pArray[4][4]; int i, k; for (k = 0; k &lt; plen; k += 16) { convertToIntArray(p + k, pArray); addRoundKey(pArray, 0);//一开始的轮密钥加 for (i = 1; i &lt; 10; i++) {//前9轮 subBytes(pArray);//字节代换 shiftRows(pArray);//行移位 mixColumns(pArray);//列混合 addRoundKey(pArray, i); } //第10轮 subBytes(pArray);//字节代换 shiftRows(pArray);//行移位 addRoundKey(pArray, 10); convertArrayToStr(pArray, p + k); }}/** * 根据索引从逆S盒中获取值 */static int getNumFromS1Box(int index) { int row = getLeft4Bit(index); int col = getRight4Bit(index); return S2[row][col];}/** * 逆字节变换 */static void deSubBytes(int array[4][4]) { int i, j; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) array[i][j] = getNumFromS1Box(array[i][j]);}/** * 把4个元素的数组循环右移step位 */static void rightLoop4int(int array[4], int step) { int temp[4]; int i; for (i = 0; i &lt; 4; i++) temp[i] = array[i]; int index = step % 4 == 0 ? 0 : step % 4; index = 3 - index; for (i = 3; i &gt;= 0; i--) { array[i] = temp[index]; index--; index = index == -1 ? 3 : index; }}/** * 逆行移位 */static void deShiftRows(int array[4][4]) { int rowTwo[4], rowThree[4], rowFour[4]; int i; for (i = 0; i &lt; 4; i++) { rowTwo[i] = array[1][i]; rowThree[i] = array[2][i]; rowFour[i] = array[3][i]; } rightLoop4int(rowTwo, 1); rightLoop4int(rowThree, 2); rightLoop4int(rowFour, 3); for (i = 0; i &lt; 4; i++) { array[1][i] = rowTwo[i]; array[2][i] = rowThree[i]; array[3][i] = rowFour[i]; }}/** * 逆列混合用到的矩阵 */static const int deColM[4][4] = { 0xe, 0xb, 0xd, 0x9, 0x9, 0xe, 0xb, 0xd, 0xd, 0x9, 0xe, 0xb, 0xb, 0xd, 0x9, 0xe };/** * 逆列混合 */static void deMixColumns(int array[4][4]) { int tempArray[4][4]; int i, j; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) tempArray[i][j] = array[i][j]; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) { array[i][j] = GFMul(deColM[i][0], tempArray[0][j]) ^ GFMul(deColM[i][1], tempArray[1][j]) ^ GFMul(deColM[i][2], tempArray[2][j]) ^ GFMul(deColM[i][3], tempArray[3][j]); }}/** * 把两个4X4数组进行异或 */static void addRoundTowArray(int aArray[4][4], int bArray[4][4]) { int i, j; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) aArray[i][j] = aArray[i][j] ^ bArray[i][j];}/** * 从4个32位的密钥字中获得4X4数组， * 用于进行逆列混合 */static void getArrayFrom4W(int i, int array[4][4]) { int index = i * 4; int colOne[4], colTwo[4], colThree[4], colFour[4]; splitIntToArray(w[index], colOne); splitIntToArray(w[index + 1], colTwo); splitIntToArray(w[index + 2], colThree); splitIntToArray(w[index + 3], colFour); for (i = 0; i &lt; 4; i++) { array[i][0] = colOne[i]; array[i][1] = colTwo[i]; array[i][2] = colThree[i]; array[i][3] = colFour[i]; }}/** * 参数 c: 密文的字符串数组。 * 参数 clen: 密文的长度。 * 参数 key: 密钥的字符串数组。 */void deAes(char* c, int clen, char* key) { int keylen = strlen(key); if (clen == 0 || clen % 16 != 0) { printf(&quot;Ciphertext characters must be a multiple of 16! Now the length is zero:%d\\n&quot;, clen); exit(0); } if (!checkKeyLen(keylen)) { printf(&quot;Key character length error! The lengths must be 16, 24, and 32. The current length is:%d\\n&quot;, keylen); exit(0); } extendKey(key);//扩展密钥 int cArray[4][4]; int i, k; for (k = 0; k &lt; clen; k += 16) { convertToIntArray(c + k, cArray); addRoundKey(cArray, 10); int wArray[4][4]; for (i = 9; i &gt;= 1; i--) { deSubBytes(cArray); deShiftRows(cArray); deMixColumns(cArray); getArrayFrom4W(i, wArray); deMixColumns(wArray); addRoundTowArray(cArray, wArray); } deSubBytes(cArray); deShiftRows(cArray); addRoundKey(cArray, 0); convertArrayToStr(cArray, c + k); }} .rodata段是用来存放只读数据的一块内存区域，例如常量数据。ro代表read only，即只读的意思。.rodata段也叫常量区，它属于静态内存分配。使用const修饰符，例如const int a = 10;，这样的变量会被放在.rodata段中 Ida Python脚本:1234567start = 0x00401500end = start + 0xBAxor = 0x41for i in range(start,end): data = get_wide_byte(i) patch_byte(i,data^xor) print(&quot;{} patched&quot;.format(i)) attribute实现main函数之前执行相应函数：1234567891011121314151617181920#include &lt;stdio.h&gt;void before() __attribute__((constructor));void after() __attribute__((destructor));void before() { printf(&quot;this is function %s\\n&quot;,__func__); return;}void after(){ printf(&quot;this is function %s\\n&quot;,__func__); return;}int main(){ printf(&quot;this is function %s\\n&quot;,__func__); return 0;} 函数调用默认传参的几种方式$$cdecl：这是C语言默认的调用约定，它要求参数从右向左依次压入栈中，由调用者负责清理栈空间。这种方式适用于可变数量的参数，如printf函数。在Windows和Linux系统中，cdecl通常用于32位x86架构的编译器。$$ $$stdcall：这是Windows API默认的调用约定，它要求参数从右向左依次压入栈中，由被调用者负责清理栈空间。这种方式适用于固定数量的参数，如MessageBox函数。在Windows系统中，stdcall通常用于32位x86架构的编译器。$$ $$fastcall：这是一种优化的调用约定，它要求将部分参数通过寄存器传递，而不是全部压入栈中，以提高函数调用的效率。不同的编译器可能会有不同的fastcall实现，例如Microsoft Visual C++和Borland C++ Builder分别使用ECX和EDX两个寄存器传递前两个参数，而GCC则使用EAX、EDX和ECX三个寄存器传递前三个参数。在Windows和Linux系统中，fastcall通常用于32位x86架构的编译器。$$ $$thiscall：这是C++类成员函数默认的调用约定，它要求将对象指针（this指针）通过ECX寄存器传递给函数，而其他参数则从右向左依次压入栈中。由于thiscall只适用于类成员函数，因此它通常不需要显式指定。在Windows和Linux系统中，thiscall通常用于32位x86架构的编译器。$$ $$syscall：这是Linux内核默认的调用约定，它要求将系统调用号通过EAX寄存器传递给内核，而其他参数则通过EBX、ECX、EDX、ESI、EDI和EBP六个寄存器按顺序传递给内核。如果参数超过六个，则需要通过栈传递。在Linux系统中，syscall通常用于32位x86架构的编译器$$ $$在64位x86架构（x86_64或AMD64）的编译器中，通常会有更多的寄存器可供使用，因此参数传递方式也会有所不同。例如，在Windows系统中，x64调用约定要求将前四个整数或指针类型的参数通过RCX、RDX、R8和R9四个寄存器传递，而前四个浮点类型的参数通过XMM0、XMM1、XMM2和XMM3四个寄存器传递；在Linux系统中，System V AMD64 ABI要求将前六个整数或指针类型的参数通过RDI、RSI、RDX、RCX、R8和R9六个寄存器传递，而前八个浮点类型的参数通过XMM0到XMM7八个寄存器传递。$$ gbk解码转中文，先ida64 convert to string，再用b修饰，解码即可12str = b&quot;\\xD7\\xA2\\xB2\\xE1\\xB3\\xC9\\xB9\\xA6\\xA3\\xA1&quot;print(str.decode('gbk')) 异常处理和反调试反调试的几种方式记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;iostream&gt;#include&lt;Windows.h&gt;char flag[5] = &quot;1234&quot;;void change(){ strcpy_s(flag, size_t(5), &quot;9999&quot;);}EXCEPTION_DISPOSITION WINAPI myExceptHandler( struct _EXCEPTION_RECORD* ExceptionRecord, PVOID EstablisherFrame, PCONTEXT pcontext, PVOID DisapatcherContext ){ // 第五种方式，类似第四种方式 if (pcontext-&gt;Dr0 != 0 || pcontext-&gt;Dr1 != 0 || pcontext-&gt;Dr2 != 0 || pcontext-&gt;Dr3 != 0) { printf(&quot;myExceptHandler检测到硬件断点\\n&quot;); } else { printf(&quot;myExceptHandlerm没有检测到硬件断点\\n&quot;); } pcontext-&gt;Eip += 2;//跳过程序异常处，要不然程序一直在异常处不继续运行 change(); return ExceptionContinueExecution;}int main(){#if 1 //第一种，会被x32dbg,OD反反调试器杀掉 BOOL flag = IsDebuggerPresent(); if (flag) { printf(&quot;IsDebuggerPresent检测到调试器\\n&quot;); } else { printf(&quot;IsDebuggerPresent没有检测到调试器\\n&quot;); } //第二种，不会被x32,OD反反调试器杀掉 BOOL IsDebug = 0; //第一个参数是进程句柄，可以检测远程进程是否被调试 CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;IsDebug); if (IsDebug) { printf(&quot;CheckRemoteDebuggerPresent检测到调试器\\n&quot;); } else { printf(&quot;CheckRemoteDebuggerPresent没有检测到调试器\\n&quot;); } // //第三种，不会被x32,OD反反调试器杀掉 //CloseHandle函数会试图关闭指定句柄的进程，#if 1 __try { CloseHandle((HANDLE)0x1234);//指定一个不存在的进程句柄 printf(&quot;CloseHandle没有检测到调试器\\n&quot;); } __except(1) { printf(&quot;CloseHandle检测到调试器\\n&quot;); }#endif //第四种,硬件断点反调试，只要在动调时设置硬件断点就会被发现 CONTEXT context{ 0 }; context.ContextFlags = CONTEXT_DEBUG_REGISTERS; GetThreadContext(GetCurrentThread(),&amp;context); //查找寄存器的值，如果有硬件断点，该寄存器的值会改变 if (context.Dr0 != 0 || context.Dr1 != 0 || context.Dr2 != 0 || context.Dr3 != 0) { printf(&quot;GetThreadContext检测到硬件断点\\n&quot;); } else { printf(&quot;GetThreadContext没有检测到硬件断点\\n&quot;); }#endif //第五种 DWORD sehHandler = (DWORD)myExceptHandler; //上面可能是添加一个异常处理函数，然后下面让异常处理链表SEH增加一个节点，把这个异常处理函数插进去 _asm { push myExceptHandler//fs: [0] 指向的是TIB[Thread information Block]结构中的EXCEPTION_REGISTRATION 结构 mov eax,fs:[0] push eax mov fs:[0],esp//让fs:[0]指向一个新的EXCEPTION_REGISTRATION 结构(就像链表插入一个新节点) } //设置程序异常处 int a = 1; a = a / 0; std::cout &lt;&lt; flag; system(&quot;pause&quot;);} dll的编译和使用先编译dll文件，新建生成dll项目，创建一个新的Mydll.cpp和Mydll.h Mydll.cpp 12345678910111213141516171819202122232425262728#include &quot;pch.h&quot;#include &quot;Mydll.h&quot;int add(int a, int b){ return a + b;}int sub(int a, int b){ return a-b;}int multi(int a, int b){ return a*b;}int Div(int a, int b){ return a/b;}int XXOR(int a,int b){ return a ^ b;} 导出的两种方式的其中第一种方式，头文件导出 123456789101112131415161718192021#pragma once#ifdef MYDLL_EXPORTS#define MYDLL_API __declspec(dllexport)#else#define MYDLL_API __declspec(dllimport)#endif//第一种导出方式extern &quot;C&quot; MYDLL_API int add(int a, int b);// Produce the next value in the sequence.// Returns true on success and updates current value and index;// false on overflow, leaves current value and index unchanged.extern &quot;C&quot; MYDLL_API int sub(int a,int b);// Get the current value in the sequence.extern &quot;C&quot; MYDLL_API int multi(int a,int b);// Get the position of the current value in the sequence.extern &quot;C&quot; MYDLL_API int Div(int a,int b); 导出的第二种方式，源文件新建一个export.def文件 123LIBRARY &quot;Mydll&quot;EXPORTSXXOR @ 1 新建一个项目导入生成的dll文件 导入的第一种方式，隐式链接的方式调用dll导出寒素 #pragma comment(lib,&quot;Mydll.lib&quot;)//lib地址 头文件main.h 123456#pragma once#include&lt;iostream&gt;#include&lt;Windows.h&gt;#pragma comment(lib,&quot;Mydll.lib&quot;)//lib地址extern &quot;C&quot; int add(int a, int b); 源文件main.cpp 12345678#include&quot;main.h&quot;int main(){ int sum = add(1, 2); printf(&quot;%d&quot;, sum); system(&quot;pause&quot;); return 0;} 第二种显示链接方式调用导出函数 不需要头文件和lib，源文件main.cpp如下 123456789101112#include&lt;iostream&gt;#include&lt;Windows.h&gt;typedef int (*XXOR)(int a, int b);int main(){ HMODULE hModule = LoadLibraryW(L&quot;Mydll.dll&quot;); XXOR Xorr = (XXOR)GetProcAddress(hModule, &quot;XXOR&quot;); printf(&quot;%d&quot;, Xorr(100, 200)); FreeLibrary(hModule); system(&quot;pause&quot;); return 0;} c语言RC4，base64加解密代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136void init(unsigned char* S, const unsigned char* key, int keylen) { for (int i = 0; i &lt; 256; i++) { S[i] = i; } int j = 0; for (int i = 0; i &lt; 256; i++) { j = (j + S[i] + key[i % keylen]) % 256; // 交换 S[i] 和 S[j] unsigned char temp = S[i]; S[i] = S[j]; S[j] = temp; }}// 生成一个字节的密钥流unsigned char generate(unsigned char* S, int* i, int* j) { *i = (*i + 1) % 256; *j = (*j + S[*i]) % 256; // 交换 S[i] 和 S[j] unsigned char temp = S[*i]; S[*i] = S[*j]; S[*j] = temp; // 返回 S[S[i] + S[j]] return S[(S[*i] + S[*j]) % 256];}// 对数据进行加密或解密void encrypt(unsigned char* data, int datalen, const unsigned char* key, int keylen) { unsigned char S[256]; // 256 字节的数据表 int i = 0, j = 0; // 两个索引变量 // 初始化 S 表 init(S, key, keylen); for (int k = 0; k &lt; datalen; k++) { // 数据和密钥流进行异或运算 data[k] ^= generate(S, &amp;i, &amp;j); }}const char* const base64char = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;int base64_decode(const char* base64, unsigned char* bindata){ int i, j; unsigned char k; unsigned char temp[4]; for (i = 0, j = 0; base64[i] != '\\0'; i += 4) { memset(temp, 0xFF, sizeof(temp)); for (k = 0; k &lt; 64; k++) { if (base64char[k] == base64[i]) temp[0] = k; } for (k = 0; k &lt; 64; k++) { if (base64char[k] == base64[i + 1]) temp[1] = k; } for (k = 0; k &lt; 64; k++) { if (base64char[k] == base64[i + 2]) temp[2] = k; } for (k = 0; k &lt; 64; k++) { if (base64char[k] == base64[i + 3]) temp[3] = k; } bindata[j++] = ((unsigned char)(((unsigned char)(temp[0] &lt;&lt; 2)) &amp; 0xFC)) | ((unsigned char)((unsigned char)(temp[1] &gt;&gt; 4) &amp; 0x03)); if (base64[i + 2] == '=') break; bindata[j++] = ((unsigned char)(((unsigned char)(temp[1] &lt;&lt; 4)) &amp; 0xF0)) | ((unsigned char)((unsigned char)(temp[2] &gt;&gt; 2) &amp; 0x0F)); if (base64[i + 3] == '=') break; bindata[j++] = ((unsigned char)(((unsigned char)(temp[2] &lt;&lt; 6)) &amp; 0xF0)) | ((unsigned char)(temp[3] &amp; 0x3F)); } return j;}char* base64_encode(const unsigned char* bindata, char* base64, int binlength)//输入，输出，输入长度{ int i, j; unsigned char current; for (i = 0, j = 0; i &lt; binlength; i += 3) { current = (bindata[i] &gt;&gt; 2); current &amp;= (unsigned char)0x3F; base64[j++] = base64char[(int)current]; current = ((unsigned char)(bindata[i] &lt;&lt; 4)) &amp; ((unsigned char)0x30); if (i + 1 &gt;= binlength) { base64[j++] = base64char[(int)current]; base64[j++] = '='; base64[j++] = '='; break; } current |= ((unsigned char)(bindata[i + 1] &gt;&gt; 4)) &amp; ((unsigned char)0x0F); base64[j++] = base64char[(int)current]; current = ((unsigned char)(bindata[i + 1] &lt;&lt; 2)) &amp; ((unsigned char)0x3C); if (i + 2 &gt;= binlength) { base64[j++] = base64char[(int)current]; base64[j++] = '='; break; } current |= ((unsigned char)(bindata[i + 2] &gt;&gt; 6)) &amp; ((unsigned char)0x03); base64[j++] = base64char[(int)current]; current = ((unsigned char)bindata[i + 2]) &amp; ((unsigned char)0x3F); base64[j++] = base64char[(int)current]; } base64[j] = '\\0'; return base64;}int main() { unsigned char Buffer[31]; char enc[41]; unsigned char key[] = &quot;BirkenwaldCTF{This_is_f4ke_f1ag}&quot;;//RC5密钥 int keylen = (int)strlen((char*)key); printf(&quot;Do you know flag?\\n&quot;); printf(&quot;Please tell me:\\n&quot;); scanf(&quot;%s&quot;, Buffer); int datelen = (int)strlen((char*)Buffer); encrypt(Buffer, datelen, key, keylen);//RC4加密 encrypt2(Buffer, enc, 30);//base64加密 return 0;} lea指令使用，防止遗忘lea，官方解释Load Effective Address，即装入有效地址的意思，它的操作数就是地址； 常见的几种用法： 1、lea eax，[addr] 就是将表达式addr的值放入eax寄存器，示例如下： lea eax,[401000h]; 将值401000h写入eax寄存器中 lea指令右边的操作数表示一个精指针，上述指令和mov eax，401000h是等价的 2、lea eax，dword ptr [ebx];将ebx的值赋值给eax 3、lea eax，c；其中c为一个int型的变量，该条语句的意思是把c的地址赋值给eax； 内联汇编实现部分常用函数功能练习在全局内定义字符串后的print hello world，因为编译器会编译的时候会自动寻址，最简单的一种方法 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char format[] = &quot;%s %s\\n&quot;;char hello[] = &quot;hello&quot;;char world[] = &quot;world!&quot;;//_declspec(naked)裸函数标识，没有基本函数框架的函数void _declspec(naked)print()//打印hello world{ _asm { push ebp mov ebp,esp sub esp,0x20 mov eax,offset world push eax mov eax,offset hello push eax mov eax,offset format push eax call printf pop ebx pop ebx pop ebx mov esp,ebp pop ebp retn }}int main(void){ _asm { call print }} 利用局部变量字符串，将字符串push进栈中，通过栈寻址，push传参来实现功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include &lt;string.h&gt;//char format[] = &quot;%s %s&quot;;//25,73,20,25,73//char hello[] = &quot;hello&quot;;//68,65,6c,6c,6f//char world[] = &quot;world!&quot;;//77,6f,72,6c,64,21void _declspec(naked)print(){ _asm { push ebp mov ebp,esp push eax push 0x2164//push 后高位自动补零结束字符串 push 0x6c726f77//注意push顺序和十六进制顺序 push 0x6f push 0x6c6c6568 push 0x73 push 0x25207325 lea eax,dword ptr ss:[esp+0x10]//ss堆栈段，ds数据段 push eax lea eax,dword ptr ss:[esp+0xc]//注意偏移量计算 push eax lea eax,dword ptr ss:[esp+0x08]//用lea将字符串地址传入寄存器 push eax call printf add esp,0x24 pop eax mov esp,ebp pop ebp ret }}int main(void){ //char format[] = &quot;%s %s&quot;;//25,73,20,25,73,0a //char hello[] = &quot;hello&quot;;//68,65,6c,6c,6f //char world[] = &quot;world!&quot;;//77,6f,72,6c,64,21 //printf(format, hello, world); _asm { call print ret }} 利用kernel32.dll或者kernelbase.dll模块寻找loadlibrary和getprocaddr函数地址，以此加载想要的模块和获得想要的函数地址，从而调用想要的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281#include&lt;stdio.h&gt;#include &lt;Windows.h&gt;char Load[] = &quot;LoadLibraryA&quot;;//4c,6f,61,64,4c,69,62,72,61,72,79,41 00 len = 0xcchar Get[] = &quot;GetProcAddress&quot;;//47,65,74,50,72,6f,63,41,64,64,72,65,73,73 00 len = 0xechar hello[] = &quot;hello world!&quot;;//68,65,6c,6c,6f,20,77,6f,72,6c,64,21 00 len = 0xcchar Msvc[] = &quot;msvcrt.dll&quot;;//6d,73,76,63,72,74,2e,64,6c,6c 00 len = 0xachar Print[] = &quot;printf&quot;;//70,72,69,6e,74,66 00 len = 0x6void _declspec(naked)MyShell(){ _asm { pushad mov ebp,esp push 0 push 0x21646c72// push 0x6f77206f// push 0x6c6c6568//hello world push 0x7373// push 0x65726464// push 0x41636f72// push 0x50746547//GetProcAddress push 0 push 0x41797261// push 0x7262694c// push 0x64616f4c//LoadLibraryA mov ecx,esp push ecx//esp传参过去 call Func_print mov esp,ebp popad nop nop nop nop nop//填充五个字节留给jmp指令，因为call指令有一个相对地址 //可以在OD，xdbg中计算jmp的相对地址 ret Func_GetModule: push ebp mov ebp, esp sub esp, 0x20 push esi mov esi,dword ptr fs:[0x30]//PEB结构体地址 mov esi,[esi+0xc]//LDR结构体地址 mov esi,[esi+0x1c]//list mov esi,[esi]//list 第二项kernel32或者kernelbase mov esi,[esi+0x8]//dllbase mov eax,esi pop esi mov esp, ebp pop ebp ret Func_GetAddr: push ebp mov ebp, esp sub esp, 0x20 mov edx, [ebp + 0x8]//dllbase mov esi, [edx + 0x3c]//if_anew lea esi, [esi + edx]//NT header mov esi, [esi + 0x78]//导出表RVA lea esi, [edx + esi]//导出表VA mov edi, [esi + 0x1c]//EAT RVA lea edi, [edi + edx]//EAT VA mov [ebp - 0x4], edi//保存 mov edi, [esi + 0x20]//ENT RVA lea edi, [edi + edx]//ENT VA mov [ebp - 0x8], edi//保存 mov edi, [esi + 0x24]//EOT RVA lea edi, [edi+edx]//EOT VA mov [ebp-0xc],edi//保存 xor eax,eax jmp tag_cmpfirst tag_cmpLoop: inc eax tag_cmpfirst: mov esi,[ebp-0x8]//ENT mov esi,[esi+eax*4]//RVA lea esi,[esi+edx]//函数名称字符串地址 mov edi,[ebp+0xc]// mov ecx,[ebp+0x10]//循环次数，ebp+0x10是传来的参数 repe cmpsb mov esi,[ebp-0xc] jne tag_cmpLoop mov esi,[ebp-0xc]//EOT xor edi,edi//为了不影响结果清空edi mov di,[esi+eax*2]//word类型,EAT表索引 mov edx,[ebp-0x4]//EAT mov esi,[edx+edi*4]//函数地址RVA mov edx,[ebp+0x8]//dllbase lea eax,[esi+edx]//最终函数地址 mov esp, ebp pop ebp retn 0xc//在栈中弹出三个参数 Func_print: push ebp mov ebp,esp sub esp,0x10 call Func_GetModule//获取kernel模块基址 mov [ebp-0x4],eax//[ebp-0x4]保存模块基址 lea ecx,[ebp + 0xc]//load地址 push 0xc push ecx push eax call Func_GetAddr//三个参数，第一个模块基址，第二个字符串地址，第三个字符串长度 loadlibrarya mov [ebp-0x8],eax//load地址 push 0xe lea ecx, [ebp + 0x1c]//Get字符串 push ecx push [ebp-0x4]//模块基址 call Func_GetAddr//三个参数，第一个模块基址，第二个字符串地址，第三个字符串长度 GetProcAddress mov [ebp-0xc],eax//get地址 push 0x6c6c push 0x642e7472 push 0x6376736d lea ecx,dword ptr ss:[ebp-0x1c] push ecx call [ebp-0x8]//调用load函数load Msvc.dll，一个参数，字符串地址 push 0x6674 push 0x6e697270 lea ecx,[ebp-0x24]//printf字符串 push ecx push eax//msvc.dll基址 call [ebp-0xc]//调用GetProcAddress函数，两个参数，一个msvc.dll基址，一个字符串名称 lea ecx,[ebp+0x2c]//hello world地址 push ecx call eax//printf地址 mov esp,ebp pop ebp ret }}int main(void){ /*GetProcAddress(); LoadLibraryA()*/ //6d, 73, 76, 63, 72, 74, 2e, 64, 6c, 6c 00 len = 0xa // //70,72,69,6e,74,66 MyShell(); system(&quot;pause&quot;); /* for (int i = 0; i &lt; strlen(Print); i++) { printf(&quot;%x,&quot;, Print[i]); }*/ }/*AT&amp;T写法asm( &quot;pusha\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;push $0\\n&quot; &quot;push $0x21646c72\\n&quot; &quot;push $0x6f77206f\\n&quot; &quot;push $0x6c6c6568\\n&quot; // hello world &quot;push $0x7373\\n&quot; &quot;push $0x65726464\\n&quot; &quot;push $0x41636f72\\n&quot; &quot;push $0x50746547\\n&quot; // GetProcAddress &quot;push $0\\n&quot; &quot;push $0x41797261\\n&quot; &quot;push $0x7262694c\\n&quot; &quot;push $0x64616f4c\\n&quot; // LoadLibraryA &quot;mov %esp, %ecx\\n&quot; &quot;push %ecx\\n&quot; // esp传参过去 &quot;call Func_print\\n&quot; &quot;mov %ebp, %esp\\n&quot; &quot;popa\\n&quot; &quot;nop\\n&quot; &quot;nop\\n&quot; &quot;nop\\n&quot; &quot;nop\\n&quot; &quot;nop\\n&quot; // 填充五个字节留给jmp指令，因为call指令有一个相对地址 // 可以在OD，xdbg中计算jmp的相对地址 &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret\\n&quot;&quot;Func_GetModule:&quot; &quot;push %ebp\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;sub $0x20, %esp\\n&quot; &quot;push %esi\\n&quot; &quot;mov %fs:0x30, %esi\\n&quot; // PEB结构体地址 &quot;mov 0xc(%esi), %esi\\n&quot; // LDR结构体地址 &quot;mov 0x1c(%esi), %esi\\n&quot; // list &quot;mov (%esi), %esi\\n&quot; // list 第二项kernel32或者kernelbase &quot;mov 0x8(%esi), %esi\\n&quot; // dllbase &quot;mov %esi, %eax\\n&quot; &quot;pop %esi\\n&quot; &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret\\n&quot;&quot;Func_GetAddr:&quot; &quot;push %ebp\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;sub $0x20, %esp\\n&quot; &quot;mov 0x8(%ebp), %edx\\n&quot; // dllbase &quot;mov 0x3c(%edx), %esi\\n&quot; // if_anew &quot;lea (%edx, %esi), %esi\\n&quot; // NT header &quot;mov 0x78(%esi), %esi\\n&quot; // 导出表RVA &quot;lea (%edx, %esi), %esi\\n&quot; // 导出表VA &quot;mov 0x1c(%esi), %edi\\n&quot; // EAT RVA &quot;lea (%edx, %edi), %edi\\n&quot; // EAT VA &quot;mov %edi, -0x4(%ebp)\\n&quot; // 保存 &quot;mov 0x20(%esi), %edi\\n&quot; // ENT RVA &quot;lea (%edx, %edi), %edi\\n&quot; // ENT VA &quot;mov %edi, -0x8(%ebp)\\n&quot; // 保存 &quot;mov 0x24(%esi), %edi\\n&quot; // EOT RVA &quot;lea (%edx, %edi), %edi\\n&quot; // EOT VA &quot;mov %edi, -0xc(%ebp)\\n&quot; // 保存 &quot;xor %eax, %eax\\n&quot; &quot;jmp tag_cmpfirst\\n&quot; &quot;tag_cmpLoop:&quot; &quot;inc %eax\\n&quot; &quot;tag_cmpfirst:&quot; &quot;mov -0x8(%ebp), %esi\\n&quot; // ENT &quot;mov (%esi, %eax, 4), %esi\\n&quot; // RVA &quot;lea (%edx, %esi), %esi\\n&quot; // 函数名称字符串地址 &quot;mov 0xc(%ebp), %edi\\n&quot; &quot;mov 0x10(%ebp), %ecx\\n&quot; // 循环次数，ebp+0x10是传来的参数 &quot;repe cmpsb\\n&quot; &quot;mov -0xc(%ebp), %esi\\n&quot; &quot;jne tag_cmpLoop\\n&quot; &quot;mov -0xc(%ebp), %esi\\n&quot; // EOT &quot;xor %edi, %edi\\n&quot; // 为了不影响结果清空edi &quot;mov (%esi, %eax, 2), %di\\n&quot; // word类型,EAT表索引 &quot;mov -0x4(%ebp), %edx\\n&quot; // EAT &quot;mov (%edx, %edi, 4), %esi\\n&quot; // 函数地址RVA &quot;mov 0x8(%ebp), %edx\\n&quot; // dllbase &quot;lea (%edx, %esi), %eax\\n&quot; // 最终函数地址 &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret $0xc\\n&quot; // 在栈中弹出三个参数&quot;Func_print:&quot; &quot;push %ebp\\n&quot; &quot;mov %esp, %ebp\\n&quot; &quot;sub $0x10, %esp\\n&quot; &quot;call Func_GetModule\\n&quot; // 获取kernel模块基址 &quot;mov %eax, -0x4(%ebp)\\n&quot; // 保存模块基址 &quot;lea 0xc(%ebp), %ecx\\n&quot; // load地址 &quot;push $0xc\\n&quot; &quot;push %ecx\\n&quot; &quot;push %eax\\n&quot; &quot;call Func_GetAddr\\n&quot; // 三个参数，第一个模块基址，第二个字符串地址，第三个字符串长度 loadlibrarya &quot;mov %eax, -0x8(%ebp)\\n&quot; // load地址 &quot;push $0xe\\n&quot; &quot;lea 0x1c(%ebp), %ecx\\n&quot; // Get字符串 &quot;push %ecx\\n&quot; &quot;push -0x4(%ebp)\\n&quot; // 模块基址 &quot;call Func_GetAddr\\n&quot; // 三个参数，第一个模块基址，第二个字符串地址，第三个字符串长度 GetProcAddress &quot;mov %eax, -0xc(%ebp)\\n&quot; // get地址 &quot;push $0x6c6c\\n&quot; &quot;push $0x642e7472\\n&quot; &quot;push $0x6376736d\\n&quot; &quot;lea -0x1c(%ebp), %ecx\\n&quot; &quot;push %ecx\\n&quot; &quot;call -0x8(%ebp)\\n&quot; // 调用load函数load Msvc.dll，一个参数，字符串地址 &quot;push $0x6674\\n&quot; &quot;push $0x6e697270\\n&quot; &quot;lea -0x24(%ebp), %ecx\\n&quot; // printf字符串 &quot;push %ecx\\n&quot; &quot;push %eax\\n&quot; // msvc.dll基址 &quot;call -0xc(%ebp)\\n&quot; // 调用GetProcAddress函数，两个参数，一个msvc.dll基址，一个字符串名称 &quot;lea 0x2c(%ebp), %ecx\\n&quot; // hello world地址 &quot;push %ecx\\n&quot; &quot;call %eax\\n&quot; // printf地址 &quot;mov %ebp, %esp\\n&quot; &quot;pop %ebp\\n&quot; &quot;ret\\n&quot; );*/ 准备了一个表格存储栈信息,ebp2对应的是print函数的栈底，pushadd到ebp2是Myshell函数形成的栈帧 msvc printf 28 6e printf 24 66 20 msvc 1c msvc 63 18 64 14 6c esp 0x10 0xc get_adr 0x8 load_adr 0x4 kernel ebp2 ebp1 4 eip 8 ecx=esp1 load c 64 10 72 14 41 18 0 get1c 50 20 41 24 65 28 73 hello 2c 6c 30 6f 34 21 38 0 pushadd ad 重温栈结构 今天在准备写一个壳的时候需要手写汇编，把汇编十六进制插入PE文件中，一时对栈结构有点遗忘，在xdbg中调了会温故了一下，在这里记一下，防止下一次遗忘 比方说我们有一个main函数时，在函数开始时经常有如下汇编代码 12345push ebpmov esp,ebpsub esp,0x20 为什么会出现以上代码？在主函数调用的子函数中能不能不出现这些代码？ push ebp 做的是一个保存ebp的操作，mov esp,ebp为下一个栈帧形成打下基础，在新栈帧中利用栈来保存数据，并且不会破坏原来栈帧中的数据 sub esp,0x20则是开辟了一个新的栈空间，这段空间可被函数直接利用，比如说做一些局部变量的初始化操作，也可以省略这部操作，直接通过push提高栈顶（地址下降）然后再通过mov在栈中储存数据（初始化局部变量） 主函数下的子函数结构和main函数类似，其实也可以说main函数时其他函数的子函数，没有什么较大的区别 在call的时候其实把下一条要执行汇编代码地址push进了栈中，然后在函数内部在push ebp这些操作，使得每次函数调用结束时，会出现以下代码 12pop ebpret ret返回的正是下一条汇编代码执行处 在函数调用时，有时通过push来传递参数，这个时候栈顶提高，但是参数传递之后对主函数没有任何作用，所以函数调用结束时主函数有时候会通过add esp来调整栈空间。 push指令在x86架构下是推入四个字节数据或地址，推入常量高位用0填充，可以通过mov指令实现对栈中数据进行字节位的调整 ret 和 retn的区别 ret和retn都是返回指令，用于从子程序中返回到调用处，同时从栈中弹出返回地址 ret和retn的区别在于是否有操作数。ret没有操作数，只是从栈中弹出返回地址；retn有一个操作数，表示要从栈中弹出的字节数 例如add esp,0x4; ret;，等价于retn 0x4 repe cmpsb字符串比较汇编指令 是一个汇编语言指令，它的意思是重复比较两个字符串的字节，直到不相等或者计数器为零为止。它涉及到三个寄存器：ECX，EDI和ESI。ECX是计数器，表示要比较的字节数；EDI和ESI是两个字符串的起始地址。每次比较后，EDI和ESI会根据方向标志DF的值自动增加或减少。如果DF为0，表示正向比较，EDI和ESI都加一；如果DF为1，表示反向比较，EDI和ESI都减一。比较的结果会影响标志寄存器中的零标志ZF。如果ZF为1，表示两个字节相等；如果ZF为0，表示两个字节不等。repe cmpsb通常用来检测两个字符串是否完全相同 jmp指令偏移地址计算在使用jmp汇编指令时，关于算偏移地址的时候机器码十六进制的计算 往下运行时，0x2 = 0x44A04D-0x44A049-0x2，也就是jmp到的地址-原来jmp前的地址-jmp这条指令的字节数，本质就是算中间有多少字节 往上运行时，0xFFF870F7 = 0x401140 - 0x44A044 - 5 最后一个五是jmp指令的字节数，0xFFF870F7转化成机器码就是F770FBFF IDAPatch保存后动调Keypatcher进行patch，ctrl+w保存patch结果，但是动调有影响 Apply patches to后动调即可 ，在edit-patch program里 Ollvm控制流平坦化技术ghidra自动化去混淆工具: https://github.com/PAGalaxyLab/ghidra_scripts IDA自动化去混淆工具d810: https://github.com/joydo/d810 HookHook的多种方式 HOOK和Callback的区别钩子技术（Hook）和回调函数（Callback）在编程中都是用于实现程序的扩展和灵活性，但它们有着不同的作用和实现方式。 相同点 事件响应： 钩子技术和回调函数都用于实现对特定事件的响应和处理。 灵活性： 两者都可以增强程序的灵活性和扩展性，使得程序能够更好地处理不同的情况和需求。 差异性 作用： 钩子技术主要用于拦截、监视和修改系统级别或应用程序级别的事件，比如键盘输入、鼠标操作、窗口消息等。 回调函数主要用于在特定事件发生时被调用，通常用于异步编程或事件驱动编程中，比如网络请求完成后的回调函数、定时器触发后的回调函数等。 实现方式： 钩子技术通常是通过操作系统提供的接口或库函数来实现的，可以在系统级别或应用程序级别进行钩子的安装和管理。 回调函数是一种编程模式，通过将函数指针或函数引用传递给其他函数，以便在特定事件发生时被调用。 应用场景： 钩子技术适用于需要拦截、监视和修改事件流的情况，比如实现键盘记录器、窗口管理工具等。 回调函数适用于需要异步处理或事件驱动的情况，比如处理异步任务完成后的结果、处理定时器事件等。 综上所述，钩子技术和回调函数虽然都与事件响应相关，但它们的作用、实现方式和应用场景有着明显的区别。钩子技术更专注于事件的拦截和修改，而回调函数更专注于事件的响应和异步处理。 从代码实现角度来看,Hook主要分成两种,Inline Hook 和 非 Inline Hook Inline Hook指的是: 在call的调用的函数内里添加 jmp 想执行代码地址 非Inline Hook指的是: 事实上就是改变了Call操作的目标地址,实际上就是IAT Hook C++虚表的Hook一个类的内存布局: 通过对象的地址来获得虚表的首地址,从而获得所有虚函数的地址 C++调用fish类的虚函数代码: 12fish Myfish;Myfish.sleep(); 汇编调用fish类的虚函数代码: 123mov eax,ecx //eca是MyFish对象的地址mov eax,[eax] //获取MyFish对象的虚表地址call [eax+0x04]//调用sleep()函数 Detours Hook框架学习 123456789101112 //1.保存detour的事务DetourRestoreAfterWith();//2.开始处理detour的事务DetourTransactionBegin();//3.更新线程信息-执行事务的线程DetourUpdateThread(GetCurrentThread());//4.设置需要拦截的代理函数//第一个参数二级函数指针-原函数地址//第二个参数函数地址-代理函数的地址DetourAttach((PVOID*)&amp;RealMessageBox, MyMessageBox);//msg//5.提交事务DetourTransactionCommit(); Hook MessageBox函数使得弹窗显示永远是 “你已经被Hook了！” mfc程序 mfc.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&quot;mfc.h&quot;Myapp app;//全局应用程序对象//MyFrame* m_pMainwnd = new MyFrame;BOOL Myapp::InitInstance(){ MyFrame* frame = new MyFrame; frame-&gt;ShowWindow(SW_SHOWNORMAL); frame-&gt;UpdateWindow(); //保存程序指针,否则窗口一闪而过, m_pMainWnd = frame;//m_pMainWnd线程类的一个成员 return 1;}BEGIN_MESSAGE_MAP(MyFrame, CFrameWnd) ON_WM_LBUTTONDOWN()END_MESSAGE_MAP()MyFrame::MyFrame(){ Create(NULL, TEXT(&quot;Crackk&quot;));}VOID MyFrame::OnLButtonDown(UINT, CPoint point){ //获取Dll1.dll文件路径 WCHAR WorkPath[MAX_PATH]; //用于存放获取路径的信息 GetModuleFileName(NULL, WorkPath, MAX_PATH); CString DllPath = WorkPath; int pos = DllPath.ReverseFind('\\\\'); DllPath = DllPath.Left(pos + 1); DllPath += _T(&quot;Dll1.dll&quot;); //一般情况利用辅助程序实现dll注入,这里为了便捷直接loadlibrary HMODULE hmodule = LoadLibrary(DllPath); if (hmodule == NULL) { MessageBox(NULL, (LPCTSTR)&quot;加载dll失败&quot;, NULL); } else { MessageBox(NULL, (LPCTSTR)&quot;弹窗&quot;, NULL); }} dll程序 solve.cpp 12345678910111213141516171819202122232425262728293031323334// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &quot;windows.h&quot;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &quot;solve.h&quot;using namespace std;BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { Start_Hook(); break; } case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: { Exit_Hook(); break; } } return TRUE;} Dll1main.cpp 12345678910111213141516171819202122232425262728293031#pragma once#include &quot;solve.h&quot;#include &quot;pch.h&quot;#include &lt;detours.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)int(WINAPI* RealMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT) = MessageBox;int WINAPI MyMessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType){ return RealMessageBox(hWnd, L&quot;你已经被Hook了！&quot;, L&quot;Hooked&quot;, uType);}void Start_Hook(){ DetourRestoreAfterWith(); DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourAttach((PVOID*)&amp;RealMessageBox, MyMessageBox);//msg DetourTransactionCommit();}void Exit_Hook(){ //1.开始处理detour的事务 DetourTransactionBegin(); //2.更新线程信息-执行事务的线程 DetourUpdateThread(GetCurrentThread()); //3.撤销hook //第一个参数二级函数指针-原函数地址 //第二个参数函数地址-代理函数的地址 DetourDetach((PVOID*)&amp;RealMessageBox, MyMessageBox); //4.提交事务 DetourTransactionCommit();} Windows的S.E.HS.E.H全称是Struct Exception Handler即结构化异常处理机制 S.E.H是操作系统提供给线程来感知和处理异常的一种回调机制,S.E.H在线程栈上以单链表的形式存在 在win32中由于FS寄存器总是指向当前的TIB(线程信息块),因此在FS:[0]处能找到最近的一个EXCEPTION_REGISTERATION结构 当我们通过try/catch或__try/except等操作来注册S.E.H的时候,FS:[0]会指向新的S.E.H,且新的S.E.H的Prev字段会指向之前FS:[0]指向的S.E.H,整个操作类似于单链表的表头插入操作 Windows的V.E.HS.E.H是基于线程的异常处理,V.E.H是基于进程的异常处理 V.E.H处理异常的优先级低于调试器,高于S.E.H,即KiUserExceptionDispatcher()函数首先检查进程是否处于被调试状态,然后检查V.E.H链表,最后才是检查S.E.H链表 Windows提供了注册V.E.H的回调函数的API 12345PVOID AddVectoredExceptionHandler//注册回调函数{ ULONG FirstHandler,//如果大于0则从头部插入,否则从尾部插入 PVECTORED_EXCEPTION_HANDLE VectoredHandler//异常处理函数地址}; 可以通过该函数进行虚假注册,通过函数返回值后去链表的头指针或者尾指针,从而遍历整个V.E.H链表 硬件断点调试器寄存器IA-32处理器定义了8个调试寄存器,DR0-DR7其中DR0-DR3用来指定断点的内存地址或IO地址;DR4和DR5是保留的,DR6的作用是当调试事件发生时向调试器报告事件的详细信息,以供调试器啊判断发生的是何种事件;DR7用来进一步定义中断条件 硬件断点的优势硬件断点HOOK是结合DR0-DR3调试寄存器和Windows S.E.H 或V.E.H机制所引入的一种HOOK机制.如果HOOK采用的方式是修改代码,那么很容易被检测到,然而硬件断点HOOK并不涉及修改代码,所以他的优点主要体现在隐蔽性上 线程上下文环境以及Windows下线程与CPU之间的关系线程执行环境CONTEXT的结构体: 123456789101112131415161718192021222324252627typedef struct_CONTEXT{ DwORD contextFlags; DWORD Dr0; DWORD Dr1; DWORD Dr2; DWORD Dr3; DWORD Dr6; DWORD Dr7; FLOATING_SAVE_AREA FloatSave; DWORD segGs; DWORD segFs; DWORD segEs; DWORD SegDs; DWORD Edi; DWORD Esi; DWORD Ebx; DWORD Edx; DWORD Ecx; DWORD Eax; DWORD Ebp; DWORD Eip; DWORD segCs; DWORD EFlags; DWORD Esp; DWORD segSs;} CONTEXT; Windows是基于线程调用的多任务抢占式操作系统,如果CPU目前运行的线程1,这时优先级更高的线程2将抢占执行,那么操作系统会把线程1的执行环境取出放到线程1的CONTEXT结构中,接着把线程2的CONTEXT信息放入CPU中,继续运行线程2 S.E.H Hook未成功代码,显示有没经处理的异常 应该是MyExceptionFilter函数没起作用 dll中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &quot;SEHHook.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: SetHardBreakPoint(); break; case DLL_THREAD_ATTACH: SetHardBreakPoint(); break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE;}//SEH.cpp #include &quot;pch.h&quot;#include &quot;SEHHook.h&quot; #include &lt;climits&gt;DWORD HookAddr = (DWORD)GetProcAddress(GetModuleHandleA(&quot;USER32.dll&quot;),&quot;MessageBoxW&quot;);LONG WINAPI MyExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo){ if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress == (LPVOID)HookAddr) { //获取当前线程上下文 PCONTEXT pcontext = ExceptionInfo-&gt;ContextRecord; MessageBoxW(NULL,TEXT(&quot;你被hook了诶&quot;), TEXT(&quot;gogogo&quot;),0); pcontext-&gt;Eip += 5; return EXCEPTION_CONTINUE_EXECUTION; } return EXCEPTION_CONTINUE_SEARCH;}void SetHardBreakPoint(){ //遍历线程 通过openthread获取到线程环境后设置硬件断点 HANDLE hTool32 = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (hTool32 != INVALID_HANDLE_VALUE) { THREADENTRY32 threadEntry32;//线程环境结构体 threadEntry32.dwSize = sizeof(THREADENTRY32); HANDLE hMainThread = NULL; FILETIME exit_time, kernel_time, user_time; FILETIME creation_time; FILETIME prev_creation_time; prev_creation_time.dwLowDateTime = 0xFFFFFFFF; prev_creation_time.dwHighDateTime = INT_MAX; DWORD dwThreadEntryOffset = FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(threadEntry32.th32OwnerProcessID); if (Thread32First(hTool32, &amp;threadEntry32)) { do { if (threadEntry32.dwSize &gt;= dwThreadEntryOffset &amp;&amp;threadEntry32.th32OwnerProcessID == GetCurrentProcessId()) { HANDLE hHookThread = OpenThread(THREAD_ALL_ACCESS, false, threadEntry32.th32ThreadID); GetThreadTimes(hHookThread, &amp;creation_time, &amp;exit_time, &amp;kernel_time, &amp;user_time); if (CompareFileTime(&amp;creation_time, &amp;prev_creation_time) == -1) { memcpy(&amp;prev_creation_time, &amp;creation_time, sizeof(FILETIME)); if (hMainThread != NULL) CloseHandle(hMainThread); hMainThread = hHookThread; } else { CloseHandle(hHookThread); } } threadEntry32.dwSize = sizeof(THREADENTRY32); } while (Thread32Next(hTool32,&amp;threadEntry32)); SetUnhandledExceptionFilter(MyExceptionFilter); CONTEXT thread_context = { CONTEXT_DEBUG_REGISTERS }; thread_context.Dr0 = (DWORD)HookAddr; thread_context.Dr7 = 0x1;//设置断点类型(访问断点) SetThreadContext(hMainThread, &amp;thread_context); CloseHandle(hMainThread); } } CloseHandle(hTool32);} V.E.H Hook试验成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//dllmain.cpp#include &quot;pch.h&quot;#include &quot;VEHHook.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: AddVectoredExceptionHandler(1, (PVECTORED_EXCEPTION_HANDLER)MyExceptionFilter); SetHardBreakPoint(); break; case DLL_THREAD_ATTACH: SetHardBreakPoint(); break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE;}//VEHHOOK.cpp#include &quot;pch.h&quot;#include &quot;VEHHook.h&quot; #include &lt;climits&gt;DWORD HookAddr = (DWORD)GetProcAddress(GetModuleHandleA(&quot;USER32.dll&quot;),&quot;MessageBoxW&quot;);LONG WINAPI MyExceptionFilter(PEXCEPTION_POINTERS ExceptionInfo){ if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress == (LPVOID)HookAddr) { //获取当前线程上下文 PCONTEXT pcontext = ExceptionInfo-&gt;ContextRecord; MessageBoxA(NULL,&quot;HOOK&quot;, &quot;HOOK&quot;,1); //需要加一段调整eip的代码使得跳出死循环 return EXCEPTION_CONTINUE_EXECUTION; } return EXCEPTION_CONTINUE_SEARCH;}BOOL SetHardBreakPoint(){ //遍历线程 通过openthread获取到线程环境后设置硬件断点 HANDLE hTool32 = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (hTool32 != INVALID_HANDLE_VALUE) { THREADENTRY32 threadEntry32;//线程环境结构体 threadEntry32.dwSize = sizeof(THREADENTRY32); HANDLE hMainThread = NULL; FILETIME exit_time, kernel_time, user_time; FILETIME creation_time; FILETIME prev_creation_time; prev_creation_time.dwLowDateTime = 0xFFFFFFFF; prev_creation_time.dwHighDateTime = INT_MAX; DWORD dwThreadEntryOffset = FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(threadEntry32.th32OwnerProcessID); if (Thread32First(hTool32, &amp;threadEntry32)) { do { if (threadEntry32.dwSize &gt;= dwThreadEntryOffset &amp;&amp;threadEntry32.th32OwnerProcessID == GetCurrentProcessId()) { HANDLE hHookThread = OpenThread(THREAD_ALL_ACCESS, false, threadEntry32.th32ThreadID); GetThreadTimes(hHookThread, &amp;creation_time, &amp;exit_time, &amp;kernel_time, &amp;user_time); if (CompareFileTime(&amp;creation_time, &amp;prev_creation_time) == -1) { memcpy(&amp;prev_creation_time, &amp;creation_time, sizeof(FILETIME)); if (hMainThread != NULL) CloseHandle(hMainThread); hMainThread = hHookThread; } else { CloseHandle(hHookThread); } } threadEntry32.dwSize = sizeof(THREADENTRY32); } while (Thread32Next(hTool32,&amp;threadEntry32)); CONTEXT thread_context = { CONTEXT_DEBUG_REGISTERS }; thread_context.Dr0 = (DWORD)HookAddr; thread_context.Dr7 = 0x1;//设置断点类型(访问断点) SetThreadContext(hMainThread, &amp;thread_context); CloseHandle(hMainThread); } } CloseHandle(hTool32); return true;}","link":"/2023/04/09/re/"},{"title":"植物大战僵尸杂交版辅助制作","text":"外挂思路很简单，就是在CE里找有关数据和代码地址，通过修改进程数据和代码实现相关功能，这里简单记录一下我的外挂实现方法 效果图： 小富一手（阳光加1000）在CE中找到阳光的地址，进行读取和写入操作即可 12345678910111213141516171819BOOL GetRich(HANDLE hProcess){ static int count = 0; uint32_t addr = getAddr(hProcess, SunBaseAddr, OFFSET_NUM1, sunOffset); if (addr) { int NowSun = 0; if (ReadProcessMemory(hProcess, (LPVOID)addr, &amp;NowSun, 4, NULL)) { int Buffer = AddSun + NowSun;//读取后进行加1000操作后写入 if (WriteProcessMemory(hProcess, (LPVOID)addr, &amp;Buffer, 4, NULL)) { return true; } } } return false;} 免费种植根据阳光地址，在CE中找到改写该地址的代码，分析汇编代码找到扣除阳光的逻辑，nop掉即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*免费终止代码实现过程* [edi+5560]处是当前阳光值,cmp ebx,eax中ebx是要种植植物所需的阳光,eax是当前阳光值* 0041BA60 | 56 | push esi |0041BA61 | 8BB7 60550000 | mov esi,dword ptr ds:[edi+5560] | edi+5560:L&quot;ē&quot;0041BA67 | 8BD7 | mov edx,edi | edx:&quot;╨e&quot;, edi:&quot;╨e&quot;0041BA69 | E8 12FFFFFF | call plantsvszombies.41B980 |0041BA6E | 03C6 | add eax,esi |0041BA70 | 3BD8 | cmp ebx,eax |0041BA72 | 7F 0C | jg plantsvszombies.41BA80 |0041BA74 | 2BF3 | sub esi,ebx |0041BA76 | E9 253C4300 | jmp plantsvszombies.84F6A0 |0x0041BA74{0x2B, 0xF3};替换成{0x90, 0x90};0041BA60 | 56 | push esi |0041BA61 | 8BB7 60550000 | mov esi,dword ptr ds:[edi+5560] |0041BA67 | 8BD7 | mov edx,edi |0041BA69 | E8 12FFFFFF | call plantsvszombies.41B980 |0041BA6E | 03C6 | add eax,esi |0041BA70 | 3BD8 | cmp ebx,eax |0041BA72 | 7F 0C | jg plantsvszombies.41BA80 |0041BA74 | 90 | nop |0041BA75 | 90 | nop |0041BA76 | E9 253C4300 | jmp plantsvszombies.84F6A0 |*/BOOL Unlimited_SunShine(HANDLE hProcess){ uint8_t shellcode[] = {0x90, 0x90 };//nop指令填充扣除阳光的逻辑代码 size_t size = sizeof(shellcode) / sizeof(shellcode[0]); VirtualProtectEx(hProcess, (LPVOID)TextSubSun, size, PAGE_EXECUTE_READWRITE, NULL); if (WriteProcessMemory(hProcess, (LPVOID)TextSubSun, (LPCVOID)shellcode, size, NULL)) { return true; } return false;} 零冷却同理，找到CD的内存地址，在CE中寻找改写该地址的汇编代码，里面含有CD是否冷却完成的条件跳转，转成绝对跳转即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*零CD代码实现过程* 植物种下后[ebp+24]地址的双浮点数作为计数器逐渐增加00488E71 | 33C0 | xor eax,eax |00488E73 | C645 48 00 | mov byte ptr ss:[ebp+48],0 |00488E77 | 8945 24 | mov dword ptr ss:[ebp+24],eax |00488E7A | 8945 28 | mov dword ptr ss:[ebp+28],eax | [ebp+28]:L&quot;2&quot;00488E7D | 8845 49 | mov byte ptr ss:[ebp+49],al |*//** [edi+24]处为计数器,值增加,[edi+28]为植物属性CD0048728C | 8347 24 01 | add dword ptr ds:[edi+24],1 |00487290 | 8B47 24 | mov eax,dword ptr ds:[edi+24] |00487293 | 3B47 28 | cmp eax,dword ptr ds:[edi+28] |00487296 | 7E 14 | jle plantsvszombies.4872AC |0x0048728C{0x83, 0x47, 0x24, 0x01, 0x8B, 0x47, 0x24};替换成{0x8B, 0x47, 0x28, 0x90, 0x83, 0xC0, 0x01, 0x3B, 0x47, 0x28};修改目的:计数器始终比CD大1,实现绝对跳转0 CD0048728C | 8B47 28 | mov eax,dword ptr ds:[edi+28] |0048728F | 90 | nop |00487290 | 83C0 01 | add eax,1 |00487293 | 3B47 28 | cmp eax,dword ptr ds:[edi+28] |*/BOOL zeroCD(HANDLE hProcess){ uint8_t shellcode[] = {0x8B, 0x47, 0x28, 0x90, 0x83, 0xC0, 0x01, 0x3B, 0x47, 0x28 }; size_t size = sizeof(shellcode) / sizeof(shellcode[0]); VirtualProtectEx(hProcess, (LPVOID)TextZeroCD, size, PAGE_EXECUTE_READWRITE, NULL); if (WriteProcessMemory(hProcess, (LPVOID)TextZeroCD, (LPCVOID)shellcode, size, NULL)) { return true; } return false;}","link":"/2024/03/12/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%E6%9D%82%E4%BA%A4%E7%89%88/"},{"title":"c++笔记","text":"记载一些学习C/C++语法，库函数，开发框架等 1. 好用的方法：1. PixmapToRound函数将QPixmap的图像转换为圆形，美化界面用，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#ifndef ROUNDIMG_H#define ROUNDIMG_H#include &lt;QPixmap&gt;#include &lt;QPainter&gt;#include &lt;QPainterPath&gt;//此处radius是半径QPixmap PixmapToRound(const QPixmap &amp;src, int radius){ if (src.isNull()) { return QPixmap(); } //按比例缩放 QPixmap pixmapa; if(src.width() != radius || src.height() != radius) { pixmapa = src.scaled(radius, radius, Qt::IgnoreAspectRatio, Qt::SmoothTransformation); } else { pixmapa = src; } QPixmap pixmap(radius,radius); pixmap.fill(Qt::transparent); QPainter painter(&amp;pixmap); painter.setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform); QPainterPath path; path.addEllipse(0, 0, radius, radius); painter.setClipPath(path); painter.drawPixmap(0, 0, radius, radius, pixmapa); return pixmap;}#endif // ROUNDIMG_H//示例：QPixmap img;//上端圆形图片，用自己头像嘿嘿 img.load(&quot;://res/login.jpg&quot;);//图片加载 QPixmap pixMap= img.scaled(100,100, Qt::IgnoreAspectRatio, Qt::SmoothTransformation); //50为圆形的半径 pixMap = PixmapToRound(pixMap, 50); ui-&gt;label_img-&gt;setPixmap(pixMap); 2. 使用正则表达式规定输入规范12ui-&gt;lineEdit_1-&gt;setValidator(new QRegularExpressionValidator(QRegularExpression(&quot;[0-9]+$&quot;)));//只能输入数字，个数不限ui-&gt;lineEdit_1-&gt;setValidator(new QRegularExpressionValidator(QRegularExpression(&quot;[A-Fa-f0-9]{1,12}&quot;)));//能输入数字和a-f大小写，控制个数不多于12个 3. 使用花指令增加逆向破解难度：123456__asm__(&quot;test $0,%eax\\n&quot; &quot;jz label\\n&quot; &quot;add $0xff,%esp\\n&quot; &quot;.byte 0xe8,0x80,0x80,0x80\\n&quot; &quot;label:\\n&quot; );//破坏了堆栈平衡，以及插入了一些junkcode 4. 与数据库互通的一些操作：CMakeList.txt文件里写入：find_package(Qt6 COMPONENTS Sql REQUIRED) target_link_libraries(TeamProject PRIVATE Qt6::Sql) 连接数据库，代码段里写入： 123456789101112131415void MainWindow::linkDatabase()//连接数据库{ database=QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);//QMYSQL对应数据库类型，此处为mysql database.setHostName(&quot;192.168.76.1&quot;);//对应ip地址 database.setPort(3306);//对应开放的端口号 database.setUserName(&quot;root&quot;);//对应用户名，此处为root用户 database.setPassword(&quot;123456&quot;);//对应密码 database.setDatabaseName(&quot;test&quot;);//使用的数据库名称 database.open();//连接数据库 if(!database.isOpen())//判断是否连接成功 { setWindowTitle(&quot;数据库没有连接成功呐！&quot;); //exit(0); }} 5. 给Qt生成的可执行文件设置图标，以及窗口左上角图标：给可执行文件设置图标，先在cpp同级目录下创建一个ico.rc文件（后缀一定要是.rc），然后再CMake.txt文件下写入文件编译区，然后再Source Files下找到该文件并写入 IDI_ICON_LOGO ICON DISCARDABLE &quot;res/logo.ico&quot;，双引号里面是图标的相对路径，.ico文件可在 D:\\Pixillion软件中进行图片格式转换。 窗口左上角图标设置：setWindowIcon(QIcon(&quot;:/res/R-C2.jpg&quot;));。 在Qt中调用其他系统命令或执行文件时，可用QProcess函数： 1234QProcess process(this);QString str = QApplication::applicationDirPath();str += &quot;/firmware_upgrade_v1.0.0.exe&quot;;//子程序exe对应主程序exe的相对路径process.startDetached(str);//startDetached使执行文件与主程序分离，主程序关闭并不影响子程序的运行，start与之相反。 6. 数据库查询和写入操作12345678910QSqlQuery query;QString s = QString(&quot;select * from users where id='%1'&quot;).arg(id);//查询语句QString s2 = QString(&quot;INSERT INTO users (id,passwordMD5,`password`,name)VALUES ('%1','%2','%3','%4')&quot;).arg(user).arg(pwdMD5).arg(pwd).arg(name);//插入语句，此处按表中字段顺序插入对应值query.exec(s);if(!query.first())//如果查询不到{}else//查询到了{}//用query.value()函数等来访问查到的值//注意一定要在query.first操作后访问query.value()的值，该操作的目的是让查询指针移动 7. QThreadPool线程池的使用先创建一个继承QRunable和QObject的线程类，在类中定义一个public的void run()函数，然后在主线程创建类对象，用QThreadPool::globalInstance()调用类对象实现多线程,示例代码： 1234567891011121314151617181920212223242526272829thread1 *thread = new thread1;QThreadPool::globalInstance()-&gt;start(thread);//.h#include &lt;QObject&gt;#include &lt;QRunnable&gt;class thread1 : public QObject,public QRunnable{ Q_OBJECTpublic: explicit thread1(QObject *parent = nullptr); void run();signals:};//.cpp#include &quot;m_thread.h&quot;#include &quot;gamehall.h&quot;thread1::thread1(QObject *parent) : QObject{parent},QRunnable(){}void thread1::run(){ GameHall* gamehall = new GameHall(); gamehall-&gt;show();// connect(gamehall,&amp;GameHall::m_show,this,&amp;MainWindow::Show);} 2. Qt中一些好用的部件属性对应的qss代码：1. LineEdit部件：设置形成的是一个浅绿色圆角编辑框。 12345ui-&gt;lineEdit_1-&gt;setStyleSheet(&quot;font: 25 14pt '微软雅黑 Light';&quot; //字体 &quot;color: rgb(31,31,31);&quot; //字体颜色 &quot;padding-left:20px;&quot; //内边距-字体缩进 &quot;background-color: rgb(255, 255, 255);&quot; //背景颜色 &quot;border:2px solid rgb(20,196,188);border-radius:15px;&quot;);//边框粗细-颜色-圆角 2. PushButton部件：设置形成的是一个浅绿色按钮，鼠标悬浮或摁下有不同颜色 1234ui-&gt;signup-&gt;setStyleSheet(&quot;QPushButton{font: 25 14pt '微软雅黑 Light';color: rgb(255,255,255);background-color: rgb(20,196,188);&quot; &quot;border: none;border-radius:5px;}&quot; &quot;QPushButton:hover{background-color: rgb(22,218,208);}&quot;//hover &quot;QPushButton:pressed{background-color: rgb(17,171,164);}&quot;);//pressed 设置的是一个蓝白渐变色的按钮，鼠标悬浮有不同的颜色 1234567ui-&gt;signUp-&gt;setStyleSheet(&quot;QPushButton{background-color: qlineargradient(spread:pad, x1:0.52, y1:1, x2:0.54, y2:0,&quot; &quot;stop:0.0112994 rgba(64, 145, 252, 255),stop:1 rgba(255, 255, 255, 255));&quot; &quot;color: rgb(255, 255, 255);&quot; &quot;border:0px groove gray;border-radius:7px;padding:2px 4px;&quot; &quot;font: 10pt 'Candara';}&quot; &quot;QPushButton:hover{background-color: qlineargradient(spread:pad, x1:0.52, y1:1, x2:0.54, y2:0,&quot; &quot;stop:0.0112994 rgba(66, 175, 255, 255),stop:1 rgba(255, 255, 255, 255))};&quot;); 设置是一个蔚蓝色的按钮，按动悬浮有不同颜色 1234567ui-&gt;pushButton-&gt;setStyleSheet(&quot;QPushButton{background:qlineargradient(spread:pad, x1:0.460227, y1:0, x2:0.465818, y2:0.875, stop:&quot;&quot;0 rgba(170, 255, 255, 255), stop:1 rgba(255, 255, 255, 255));&quot; &quot;border-radius:8px;&quot; &quot;border:2px solid rgb(0, 170, 255);&quot; &quot;color:rgb(17,17,17);}&quot;&quot;QPushButton:hover{background:qlineargradient(spread:pad, x1:0.460227, y1:0, x2:0.443091, y2:0.898, stop:0 rgba(0, 255, 255, 255), stop:1 rgba(255, 255, 255, 255))}&quot;&quot;QPushButton:hover:pressed{background:qlineargradient(spread:pad, x1:0.460227, y1:0, x2:0.465818, y2:0.875, stop:0 rgba(170, 255, 255, 255), stop:1 rgba(255, 255, 255, 255));}&quot;); 3. 遇到的一些问题： 2023/5/23-&gt;在Qt的两个窗口头文件中都调用了相同的一个头文件，然后报了multiple definition of ~的错，分析是因为两个函数重复定义了。 解决办法是：新建了一个.cpp文件，然后将.h文件中全部内容转到cpp文件中，然后.h文件只包含函数的定义. 2023/5/24-&gt;在注册成功窗口想要直接将注册窗口和本窗口同时关闭并且转到登录窗口时遇到了问题——如何在子窗口中通过按钮将父窗口也关闭。 解决办法是：在父窗口调用子窗口前增加一个信号槽连接，信号由子窗口.h文件中定义并在按按钮之后发出，槽函数在父窗口中声明并实现，从而实现信号通过子窗口发出并在父窗口中做出关闭操作。 核心代码： 1234 SignSucess *signsucess = new SignSucess(); connect(signsucess,&amp;SignSucess::Close,this,&amp;LoginWindow::Close); signsucess-&gt;exec();//Close()函数分别为子窗口和父窗口中自定义的信号和槽函数 2023/5/24-&gt;在写记住密码功能时，用到QSetting库，然后通过该库与本地ini文件交互，但是把ini文件放在源代码目录下则无法保存修改，查了网上的有关说法，利用sync()函数或者重构closeEvent函数(该函数在右上角关闭窗口时自动起作用)，或者在该窗口的析构函数中servalue，最终都没很好的解决我的问题。 解决办法是：将init.ini文件放在exe程序目录下(撒花！) 绝对路径可以这样在父类头文件窗口直接定义： 1QString inipath= QCoreApplication::applicationDirPath() + &quot;/init.ini&quot; 2023/5/24-&gt;Qt6编译生成的exe程序无法打开，显示缺少一些dll文件。 解决办法是：打开编译器对应的命令行，这里对应的是MinGW64（已加入环境变量），先新建一个文件夹，将exe程序单独放进去，然后”cd [exe程序所在文件夹的路径]”，输入windeployqt exe文件名，例如windeployqt TeamProject.exe。 2023/5/24-&gt;Qt6打包生成exe文件后，打开exe程序不能连接数据库的问题。 解决办法是：在编译器(这里对应的是MinGW64)对应的bin目录下找到libmysql.dll文件，复制到exe程序的同级目录下即可。 2023/5/25-&gt;Qt6打包生成的exe文件在远端虚拟机上无法连接数据库成功的问题。 解决办法是：在Mysql文件夹的MysqlServer文件bin中所有文件转移到exe文件同级目录下 2023/5/25-&gt;Qt6打包生成的exe文件在远端虚拟机上连接上了数据库，但是远端正常机上连不上 解决办法是：把代码中 database.setHostName(&quot;192.168.123.120&quot;);ip地址设置为无线局域网适配器 WLAN的IPv4地址（本机ip地址）。 2023/6/10-&gt;QMovie播放gif时，想要使得同一个label通过按钮切换gif时出现gif暂停不切换的情况 解决办法是：在gif切换时movie-&gt;start()，前加入movie-&gt;stop()。 2023/6/11-&gt;在提升控件类时，运行出现无法找到头文件的情况 解决办法是：在cmake.txt文件中加入 INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR})运行报错点击“忽略错误”。 2023/6/11-&gt;QToolButton重写鼠标进入事件 void HallBtn::enterEvent(QEnterEvent *event) 2023/6/14-&gt;连接阿里云数据库后，查询表时navicate报“lost connection …during query”错误 解决办法是：换校园网。。 2023/6/24-&gt;实现邮箱辅助账号注册时，引用QTcpSocket时报错 QTcpSocket file not found 解决办法是：CMakeList.txt中添加 1234find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Core Network)find_package(Qt${QT_VERSION_MAJOR} REQUIRED Network COMPONENTS Core)target_link_libraries(TeamProject PRIVATE Qt${QT_VERSION_MAJOR}::Core)target_link_libraries(TeamProject PRIVATE Qt6::Network) 4. Windows编程： LPCVOID是一个Windows API数据类型，它是一个指向常量（只读）void的指针。在Windows API中，LPCVOID通常用于指向要读取的数据的缓冲区 LPVOID是一个Windows API数据类型，它是一个指向void的指针。在Windows API中，LPVOID通常用于指向要读取或写入的数据的缓冲区 ReadProcessMemory函数是Windows API的一部分，它允许一个进程读取另一个进程的内存区域。该函数的语法如下： 1234567BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead); 其中，hProcess参数是要读取内存的进程的句柄，lpBaseAddress参数是要读取的内存地址（读取目标地址），lpBuffer参数是用于存储读取数据的缓冲区（保存读取结果），nSize参数是要读取的字节数，lpNumberOfBytesRead参数是指向变量的指针（没有用到则填NULL），该变量将接收实际读取的字节数。 WriteProcessMemory函数是Windows API的一部分，它允许一个进程向另一个进程的内存区域写入数据。该函数的语法如下： 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); 其中，hProcess参数是要读取内存的进程的句柄，lpBaseAddress参数是要读取的内存地址（读取目标地址），lpBuffer参数是用于存储读取数据的缓冲区（保存读取结果），nSize参数是要读取的字节数，lpNumberOfBytesWritten参数是指向变量的指针（没有用到则填NULL），该变量将接收实际读取的字节数。 获得指定进程PID的方法： 12345678910111213141516171819DWORD MainWindow::getProcessId(const QString&amp; processName)//获取进程PID{ PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (Process32First(snapshot, &amp;entry)) { do { if (QString::fromWCharArray(entry.szExeFile) == processName) { CloseHandle(snapshot); return entry.th32ProcessID; } } while (Process32Next(snapshot, &amp;entry)); } CloseHandle(snapshot); return 0;} 用法：DWORD pid=getProcessId(processname); 获取进程的总基地址的方法： 12345678910111213141516171819202122232425PVOID MainWindow::GetProcessBase(DWORD dwProcessId){ PVOID pProcessImageBase = NULL; //打开进程, 获取进程句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (NULL == hProcess) { return pProcessImageBase; } // 遍历进程模块, HMODULE hModule[100] = { 0 }; DWORD dwRet = 0; BOOL bRet; bRet = EnumProcessModulesEx(hProcess, (HMODULE*)(hModule), sizeof(hModule), &amp;dwRet, NULL); if (FALSE == bRet) { CloseHandle(hProcess); return pProcessImageBase; } // 获取第一个模块加载基址 pProcessImageBase = hModule[0]; // 关闭句柄 CloseHandle(hProcess); return pProcessImageBase;} 用法：long long baseAddress = (long long)GetProcessBase(Pid)//进程对应PID 获取进程句柄：HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); 5. C++语法：1. 虚继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;//虚继承：对类的继承内存存储方式进行了改变//从原先的拷贝复制的方式变成了在子类内部空间增加了一个地址，// 该地址指向了一些偏移量，通过指针去访问地址+偏移量//从而锁定子类从父类那继承来的对象地址，解决了多重继承导致的父类对象重复引起子类访问时目标对象不明确的问题class A{public: int flagA; int test; A() { test = 0x666666; flagA = 0x111111; }};class B :virtual public A{public: int flagB; B() { flagB = 0X222222; }};class C :virtual public A{public: int flagC; C() { flagC = 0x3333333; }};class D :virtual public B,virtual public C{public: int flagD; D() { flagD = 0x444444; }};int main(){ B b; C c; D d; d.flagA = 0x5555555; //d.C::value = 1; printf(&quot;%d\\n&quot;, sizeof(d)); system(&quot;pause&quot;);} 2. 友元函数在类内声明友元函数，关键词 friend ，从而使类外定义的非成员函数可以访问该类的私有成员 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;//友元函数class Student{public: Student(const char* name); ~Student();private: char name[20]; friend void printName(Student &amp;stu);};Student::Student(const char* name){ strcpy_s(this-&gt;name, 20, name);}Student::~Student(){}void printName(Student &amp;stu){ std::cout &lt;&lt; stu.name &lt;&lt; std::endl;}int main(){ Student stu(&quot;I am Kvancy&quot;); printName(stu); system(&quot;pause&quot;);} 3. 重载运算符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;//重载运算符using std::ostream;class A{public: A(const char* name); ~A(); void printName(); char* get_name(); friend A operator+(A&amp; a1, A&amp; a2); friend ostream&amp; operator&lt;&lt;(ostream&amp; os, A&amp; a1);private: char* name;};A::A(const char* name){ if (this-&gt;name = (char*)malloc(strlen(name) + 1)) { strcpy_s(this-&gt;name, strlen(name) + 1, name); }}A::~A(){ free(this-&gt;name);}void A::printName(){ std::cout &lt;&lt; this-&gt;name &lt;&lt; std::endl;}char* A::get_name(){ return this-&gt;name;}A operator+(A &amp;a1, A &amp;a2){ A a3(&quot;&quot;); char* buff = nullptr; int len = strlen(a1.name) + strlen(a2.name); if (buff = (char*)malloc(len + 1)) { strcpy_s(buff, len + 1, a1.name); strcat_s(buff, len + 1, a2.name); } a3.name = buff; return a3;}ostream&amp; operator&lt;&lt;(ostream&amp; os, A &amp;a1){ os &lt;&lt; a1.name; return os;}int main(){ A a1(&quot;我是A1&quot;); A a2(&quot;我是A2&quot;); A a3 = a1 + a2; std::cout &lt;&lt; a3 &lt;&lt; std::endl; system(&quot;pause&quot;); return 0;} 4. 虚函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;//子类重写函数之后，如果定义的父类对象想调用子类重写的函数//这个时候如果直接用父类对象的指针指向子类对象，然后调用子类重写的函数//这个时候成功调用//如果我们把该父类成员函数定义成虚函数，我们可以通过改变指针指向调用子类重写的函数//编译从静态联编-&gt;动态联编//内存中创造了虚函数表，我们可以通过父类的指针指向正确调用函数地址，从而实现调用//virtual 关键词父类定义了子类就无需定义//override 关键词可以避免因函数签名不一致而导致的错误，提前帮你报错显示提醒你class Animal{public: Animal(); ~Animal(); virtual void make_sound () const { printf(&quot;Animal:make\\n&quot;); }};Animal::Animal(){}Animal::~Animal(){}class Bird:public Animal{public: Bird(); ~Bird(); void make_sound() const override //如果不加override,忘写了const关键字 //编译器正常编译,父类没有成功调用子类函数，打印出&quot;Animal:make&quot; { printf(&quot;Bird:make\\n&quot;); }};Bird::Bird(){}Bird::~Bird(){}int main(){ Animal* animal = new Animal(); Bird bird; animal = &amp;bird; animal-&gt;make_sound(); system(&quot;pause&quot;); delete animal; return 0;} 5. 模版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;//模版函数{函数模版，类模版}关键词typename或者class随意，在底层中无影响，编译器在编译的时候替换//第一种template&lt;typename T&gt;T sum(T a, T b){ return a + b;}//第二种,参数类型不相同template&lt;typename T,typename T2&gt;void swap(T &amp;a,T2 &amp;b){ T c; c = b; b = a; a = c;} //第三种，类模版template&lt;typename T&gt;class A{public: T getValue() { return value; } void setValue(T va); A(T value); ~A();private: T value;};//模板类是带参数的类，要求在接口实现中的类名称后面加入模板类参数，函数返回值亦如此//格式举例如下template&lt;typename T&gt;A&lt;T&gt;::A(T value){ this-&gt;value = value;}template&lt;typename T&gt;A&lt;T&gt;::~A(){}template&lt;typename T&gt;void A&lt;T&gt;::setValue(T va){ value = va;}int main(){ char a = 1; char b = 2; printf(&quot;第一种:%d\\n&quot;,sum(a, b)); swap(a, b); printf(&quot;第二种：a:%d,b:%d\\n&quot;, a, b); A&lt;int&gt; c(1); c.setValue(2); printf(&quot;第三种：%d\\n&quot;, c.getValue()); system(&quot;pause&quot;); return 0;} 6. 异常处理123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;//C++异常处理机制//throw，try,catch//在汇编代码中没有try catch，throw函数，正常运行异常代码，然后再一个jmp指令到某一个地址（实际上catch函数）里执行相应功能double fun(double a, int b){ if (b == 0) { throw 2;//这里throw什么类型，就是catch里面参数类型 } return a/b;}int main(){ try { fun(2, 0); } /*catch (int judge) { if(judge==1) printf(&quot;异常\\n&quot;); if(judge==2) printf(&quot;异常2\\n&quot;); }*/ catch (...) { printf(&quot;我是万能的！\\n&quot;); } system(&quot;pause&quot;); return 0; } perror(char*) 显示报错信息,例如 perror(&quot;wrong!:&quot;) 打印出 “wrong!:+为什么报错” 6. C++算法1. 数组 or 容器的遍历算法 auto,for_each,transform123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt;ve;void visit(int out){ cout &lt;&lt; out &lt;&lt; &quot; &quot;;}//仿函数class print2{public: void operator()(int out) { cout &lt;&lt; out &lt;&lt; &quot; &quot;; }};class trans{public: int operator()(int out) { return ++out; }};int main(){ //遍历输出的几种方式 ve = { 0,1,2,3,4,5 }; int in[6] = { 0,1,2,3,4,5 }; //正常容器 for (auto it : in)cout &lt;&lt; it &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; for_each(in, in + 6, visit); cout &lt;&lt; endl; //stl容器 for (auto it : ve){cout &lt;&lt; it&lt;&lt;&quot; &quot;;} cout &lt;&lt; endl; for_each(ve.begin(), ve.end(), visit); cout &lt;&lt; endl; for_each(ve.begin(), ve.end(), print2());//仿函数输出结果 //transform搬运容器 cout &lt;&lt; endl; vector&lt;int&gt;ve2; //提前分配内衬 ve2.resize(ve.size()); transform(ve.begin(), ve.end(), ve2.begin(), trans());//把ve内的值可运算性的搬运到ve2中 for (auto it : ve2)cout &lt;&lt; it &lt;&lt; &quot; &quot; ; cout &lt;&lt; endl;} 2. 查找算法 find,find_if,count,count_if,binary_serach123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt;ve;class Person{public: string name; int age; bool operator==(const Person&amp; person1) { return person1.name == this-&gt;name &amp;&amp; person1.age == this-&gt;age;//注意利用this指针，不能传两个参数 }};class equal1{public: bool operator()(const Person &amp;person1) { return person1.name == &quot;p2&quot; &amp;&amp; person1.age == 5; }};class equal2{public: bool operator()(int out) { return out &gt; 5; }};class count_cmp{public: bool operator()(int out) { return out &gt; 5; }};int main(){ //常用查找算法 //find函数，在algorithm头文件中，find重心在相等 ve = { 2,3,4,5,6,7 }; auto it = find(ve.begin(), ve.end(),5); cout &lt;&lt; *it &lt;&lt; endl;//返回找到的位置 Person person1 = { &quot;p1&quot;,5 }; Person person2 = { &quot;p2&quot;,5 }; Person person3 = { &quot;p1&quot;,5 }; vector&lt;Person&gt;ve2; ve2.push_back(person1); ve2.push_back(person2); ve2.push_back(person3); auto it2 = find(ve2.begin(), ve2.end(),person2 );//要重载==运算符 cout &lt;&lt;it2-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; it2-&gt;age &lt;&lt; endl; /**********************************************/ //find_if语法，find_if重心在比较 auto it3 = find_if(ve.begin(), ve.end(), equal2());//找到大于5的第一个数 cout &lt;&lt; *it3 &lt;&lt; endl; auto it4 = find_if(ve2.begin(), ve2.end(), equal1());//自定义类需定义仿函数声明返回标准 cout &lt;&lt; it4-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; it4-&gt;age &lt;&lt; endl; /**********************************************/ //binary_search语法,重心在存在与否,使用条件是查找容器已排序，该查找效率为指数级 auto it5 = binary_search(ve.begin(), ve.end(), 7);//返回值其实是bool类型 cout &lt;&lt; it5 &lt;&lt; endl; auto it6 = binary_search(ve.begin(), ve.end(), 8); cout &lt;&lt; it6 &lt;&lt; endl; /***********************************************/ //count语法，用于统计数据，返回某个元素在容器内的个数 int cnt = count(ve.begin(), ve.end(), 2); cout &lt;&lt; cnt &lt;&lt; endl; //统计类的数据时，要重载==运算符 //count_if语法，返回容器内数据条件判断后的个数 cnt = count_if(ve.begin(), ve.end(), count_cmp()); cout &lt;&lt; cnt &lt;&lt; endl; //统计类的数据，要用bool型仿函数去定义比较条件} 3. 排序算法 sort,rand_shuffle,merge,reverse1234567891011121314151617181920int main(){ sort(ve.begin(), ve.end());//默认升序排列 sort(ve.begin(), ve.end(), greater&lt;int&gt;());//降序排列 sort(ve.begin(), ve.end(), cmpl);//自定义降序排列 random_shuffle(ve.begin(), ve.end()); //到此每次运行实际上结果一致，使用srand生成随机数 srand((unsigned int)time(NULL)); random_shuffle(ve.begin(), ve.end()); //结果每次运行都不同了 /**********************************/ //merge函数，使两个有序的容器合并成一个容器，并且新的容器也是有序的 merge(ve.begin(), ve.end(), ve1.begin(), ve1.end(), ve2.begin()); //ve2为新的容器 /**************************************/ //reverse函数，翻转函数 reverse(ve2.begin(), ve2.end()); /**************************************/} 4. 拷贝替换算法 copy replace replace_if 1234copy(ve.begin(), ve.end(), ve2.begin());//把ve的值copy到ve2中，要提前开辟空间replace(ve.begin(), ve.end(), 0, 5);//把ve中0替换成5replace_if(ve.begin(), ve.end(), cmp, 5);//把ve中小于5的替换成5swap(ve, ve2);//把ve，ve2容器中数据继续互换 5. 常用集合算法 set_intersection set_union set_difference 123auto it2 = set_intersection(ve.begin(), ve.end(), ve2.begin(), ve2.end(), ve3.begin());//求v1,v2的交集，保存到v3，返回值为交集结束的迭代器auto it3 = set_union(ve.begin(), ve.end(), ve2.begin(), ve2.end(), ve3.begin());//求v1,v2的并集，保存到v3，返回值为并集结束的迭代器auto it4 = set_difference(ve.begin(), ve.end(), ve2.begin(), ve2.end(), ve3.begin());//求v1,v2的差集---属于v1，不属于v2的集合 7. 运算符优先顺序： 运算符由高到低： 第一级：圆括号 ()、下标运算符 []、结构体成员运算符 . 和 -&gt; 第二级：逻辑非 !、按位取反 ~、自增自减 ++ 和 –、负号 -、类型转换 (类型)、指针运算符 * 和 &amp;、长度运算符 sizeof 第三级：乘法运算符 *、/ 和 % 第四级：加法运算符 + 和 - 第五级：移位运算符 &lt;&lt; 和 &gt;&gt; 第六级：关系运算符 &lt;、&lt;=、&gt; 和 &gt;= 第七级：相等运算符 == 和 != 第八级：按位与 &amp; 第九级：按位异或 ^ 第十级：按位或 第十二级：逻辑或 第十四级：赋值运算符 =、+=、-=、*=、/=、%=、&amp;=、^=、 第十五级：逗号运算符 , 8. MFC通过空项目创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//mfc.h#include&lt;afxwin.h&gt;//设置 链接器-系统-窗口//设置 在高级里 在共享 DLL 中使用 MFCclass Myapp:public CWinApp{public: virtual BOOL InitInstance();//mfc程序入口private:};class MyFrame:public CFrameWnd{public: MyFrame(); //~MyFrame(); afx_msg void OnLButtonDown(UINT, CPoint point);private: DECLARE_MESSAGE_MAP()};//mfc.cpp#include&quot;mfc.h&quot;Myapp app;//全局应用程序对象//MyFrame* m_pMainwnd = new MyFrame;BOOL Myapp::InitInstance(){ MyFrame* frame = new MyFrame; frame-&gt;ShowWindow(SW_SHOWNORMAL); frame-&gt;UpdateWindow(); //保存程序指针,否则窗口一闪而过, m_pMainWnd = frame;//m_pMainWnd线程类的一个成员 return 1;}BEGIN_MESSAGE_MAP(MyFrame, CFrameWnd) ON_WM_LBUTTONDOWN()END_MESSAGE_MAP()MyFrame::MyFrame(){ Create(NULL, TEXT(&quot;Crackk&quot;));}VOID MyFrame::OnLButtonDown(UINT, CPoint point){ TCHAR buf[1024]; wsprintf(buf, TEXT(&quot;X = %d,Y = %d&quot;), point.x, point.y); MessageBoxW(buf);} 通过MFC应用程序模版创建–基于对话框 在app的子类里有首界面的创建 123456CMFC2Dlg dlg;m_pMainWnd = &amp;dlg;//第一个显示的界面//First dlg;//m_pMainWnd = &amp;dlg;//第一个显示的界面INT_PTR nResponse = dlg.DoModal();if (nResponse == IDOK) 如果要修改首界面可以添加界面类(先创建资源,再创建类) 但是新界面没有最小化和最大化和拖拽功能 如果想要在界面类里访问其他控件,例如staticText类,需要在ui界面添加变量,然后就可以通过名称来访问该控件 12345678910void CMFC2Dlg::OnBnClickedClick(){ // TODO: 在此添加控件通知处理程序代码 static int count = 0; count++; if (count &gt;= 5) { //hint为staticText的名称 hint.SetWindowTextW(TEXT(&quot;flag{1111}&quot;)); }} 这里代码块实际做的操作有两处 第一处:在父界面类的头文件中包含该控件 1CStatic hint; 第二处:在父界面类的源文件中DoDataExchange函数里添加控件关联 1DDX_Control(pDX, IDC_HINT, hint);//p_DX是传来的参数,后者是相关联控件id和名称 给按钮添加事件处理程序时,代码层实际修改了三处代码 所属界面类的头文件中包含该事件处理函数 12afx_msg void OnBnClickedClick();afx_msg void OnBnClickedDClick(); 在源文件消息队列声明(BEGIN_MESSAGE_MAP)后添加消息声明 12ON_BN_CLICKED(IDC_Click, &amp;CMFC2Dlg::OnBnClickedClick)//id和处理函数指针ON_BN_CLICKED(IDC_DClick, &amp;CMFC2Dlg::OnBnClickedDClick) 在源文件中添加处理函数的实现 123456789101112131415161718void CMFC2Dlg::OnBnClickedClick(){ // TODO: 在此添加控件通知处理程序代码 static int count = 0; count++; if (count &gt;= 5) { hint.SetWindowTextW(TEXT(&quot;flag{1111}&quot;)); }}void CMFC2Dlg::OnBnClickedDClick(){ // TODO: 在此添加控件通知处理程序代码 hint.SetWindowTextW(TEXT(&quot;you are so smart!!&quot;));} 如何格式化SetwindowTextW的参数TEXT,参数为CSting形式,等于LPCTSTR(),TEXT(),_T(),可以用Format来格式化text 123CString text;text.Format(_T(&quot;gogogogo!%d&quot;), count);hint.SetWindowTextW(text); 9. QML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316import QtQuick 2.15import QtQuick.Window 2.15import QtQuick.ControlsWindow { width: 640 height: 480 visible: true title: qsTr(&quot;Hello World&quot;) property int myvalue: 0 minimumHeight: 400 maximumHeight: 540 minimumWidth: 540 maximumWidth: 720 onWidthChanged: { console.log(&quot;width:&quot;,width); } onMyvalueChanged: { console.log(&quot;myvalue:&quot;,myvalue); } Button{ id: btn1 objectName: &quot;btn1&quot; x: 100 width: 50 height: 50 background: Rectangle{ border.color: btn1.focus?&quot;blue&quot;:&quot;black&quot;//按钮按下获得焦点 } Keys.onLeftPressed: {//方向键左按下 btn1.focus = false } } Button{ id: btn2 objectName: &quot;btn2&quot; x: 100 y: 100 width: 50 height: 50 background: Rectangle{ border.color: btn2.focus?&quot;blue&quot;:&quot;black&quot; } Keys.onLeftPressed: {//方向键左按下 btn2.focus = true } } onActiveFocusItemChanged: { //焦点发生改变时 console.log(&quot;active focus item changed:&quot;,activeFocusItem)//objectName } Rectangle{ x: 100 y: 100 z: 2//可以在2d中进行覆盖或者隐藏 width: 100 height: 100 color: &quot;blue&quot; focus: true MouseArea { anchors.fill: parent onClicked: { console.log(&quot;on clicked&quot;) } } Keys.onReturnPressed: {//控件获取键盘信号前需要获取焦点 console.log(&quot;on return pressed&quot;) } } Rectangle { id: rect1 width: 100 height: 50 color: &quot;black&quot;// anchors.centerIn: parent//水平垂直居中 anchors.horizontalCenter: parent.horizontalCenter//水平居中 anchors.verticalCenter: parent.verticalCenter//垂直居中 rotation: 60 //旋转角度 scale: 2 //放缩,放大两倍 antialiasing: false //抗锯齿 border.width: 2 //边框 border.color: &quot;red&quot; radius: 30 //弧度 gradient: Gradient {//渐变色 覆盖原有颜色 边框颜色不覆盖 GradientStop { position: 0.0; color: &quot;lights teelblue&quot; } GradientStop { position: 1.0; color: &quot;blue&quot;} } } Rectangle { id: rect2 width: 100 height: 50 anchors.left: rect1.right//类似弹簧,rect1左边与rect1右边重合 anchors.leftMargin: 20//与rect1左侧相距20 anchors.top: rect1.top//y轴距离相同 color: &quot;blue&quot; } Rectangle { id: root width: 100; height: 100 state: &quot;red_color&quot; //控制状态 states: [ State { name: &quot;red_color&quot; PropertyChanges { root.color: &quot;red&quot; } }, State { name: &quot;blue_color&quot; PropertyChanges { root.color: &quot;blue&quot; } } ] MouseArea { anchors.fill: parent onPressed: { root.state = &quot;blue_color&quot; } onReleased: { root.state = &quot;red_color&quot; } } transitions: [//状态改变时进行动画,而不是瞬间完成状态改变 Transition { from: &quot;red_color&quot;//状态 to: &quot;blue_color&quot; ColorAnimation { target: root duration: 1000 } }, Transition { from: &quot;blue_color&quot; to: &quot;red_color&quot; ColorAnimation { target: root duration: 1000 } } ] } Rectangle { id: flashingblob width: 100 height: 100 color: &quot;blue&quot; opacity: 1.0 SequentialAnimation on color {//多段式动画 ColorAnimation {// from: &quot;white&quot; to: &quot;red&quot; duration: 200 } ColorAnimation {// from: &quot;white&quot; to: &quot;blue&quot; duration: 200 } } MouseArea { anchors.fill: parent onClicked: { animateColor.start() animateOpacity.start() } } PropertyAnimation { //属性为字符串的动画 id: animateColor; target: flashingblob properties: &quot;color&quot; to: &quot;green&quot; duration: 1000 } NumberAnimation {//属性为数字的动画 id: animateOpacity target: flashingblob property: &quot;opacity&quot; duration: 1000 from: 1.0 to: 0.5 } PropertyAnimation on x {//立即触发的动画 to: 100 duration: 1000 } } Component { //不会立即出现的组件,需要load id: com Rectangle { width: 100 height: 100 color: &quot;blue&quot; Component.onCompleted: {//构造函数 console.log(&quot;Completed&quot;) } Component.onDestruction: {//析构函数 console.log(&quot;Destruction&quot;) } } } Component { //不会立即出现的组件,需要load id: com2 Image {//img id: img source: &quot;/login2.jpg&quot; } } Component { //不会立即出现的组件,需要load id: com3 AnimatedImage {//gif id: gif source: &quot;/GIF-1.gif&quot; speed: 10 } } Loader {//加载组件或文件 id: load sourceComponent: com3 onStateChanged: { console.log(&quot;status:&quot;,status) } } Button { id: button width: 50 height: 50 x: 200 onClicked: { load.item.paused = !load.item.paused//播放键 } } MouseArea { id: mousearea width: 100 height: 100 enabled: true //是否使能,默认为true acceptedButtons: Qt.LeftButton | Qt.RightButton //默认只接受左键 cursorShape: Qt.CrossCursor //鼠标样式 hoverEnabled: true //默认关闭,打开可以接受悬浮信号 Rectangle { anchors.fill: parent color: &quot;blue&quot; } onClicked: { console.log(&quot;clicked&quot;) } onHoveredChanged: {//是否悬浮 console.log(&quot;Onhoverchanged&quot;) } onPressed: { var ret = pressedButtons &amp; Qt.LeftButton var ret2 = pressedButtons &amp; Qt.RightButton if(ret == Qt.LeftButton)//控制左右键不同回应 console.log(&quot;LEFT&quot;) else console.log(&quot;RIGHT&quot;) console.log(&quot;pressed&quot;) } onReleased: { console.log(&quot;released&quot;) } onPressAndHold://长摁 , 在 Press信号之后 { console.log(&quot;hold&quot;) } } Rectangle { id: rect width: 50 height: 50 color: &quot;red&quot; opacity: (600.0 - rect.x) / 600 MouseArea { anchors.fill: parent drag.target: rect //加载拖动效果 drag.axis: Drag.XAxis /*| Drag.YAxis*/ drag.minimumX: 0 drag.maximumX: container.width - rect.width// drag.filterChildren: true//子控件是否能拖动 } }} Libxl使用引入库123#include &quot;libxl-3.1/libxl-3.1.0/include_cpp/libxl.h&quot;#pragma comment(lib,&quot;libxl-3.1/libxl-3.1.0/lib/libxl.lib&quot;)using namespace libxl; 读取文件123Book* book = xlCreateBook();book-&gt;load(&quot;xxx.xls&quot;);Sheet* sheet = book-&gt;getSheet(0); 读取文件大小 1234int rowfirst = sheet-&gt;firstRow();int rowlast = sheet-&gt;lastRow();int colfirst = sheet-&gt;firstCol();int collast = sheet-&gt;lastCol(); 读取文件内容（表格左上角为（0,0）） 12double date1 = sheet-&gt;readNum(0, 0);const char* date2 = sheet-&gt;readStr(0, 1); 创建新sheet 12Book* book1 = xlCreateBook();Sheet* sheet1 = book1-&gt;addSheet(&quot;sheet1&quot;); 设置行宽列高 12sheetM-&gt;setCol(0, 0, 20);sheetM-&gt;setRow(0 , 20); 合并单元格 1sheet-&gt;setMerge(0,0,1,2); // 合并第0行的1~2列 设置字体 123456789Font *titleFont = bookM-&gt;addFont();titleFont-&gt;setName(&quot;宋体&quot;);titleFont-&gt;setSize(16);titleFont-&gt;setBold(true);Format* titleFormat = bookM-&gt;addFormat();titleFormat-&gt;setAlignH(ALIGNH_CENTER);titleFormat-&gt;setFont(titleFont);titleFormat-&gt;setWrap(true);titleFormat-&gt;setAlignV(ALIGNV_DISTRIBUTED); 向文件写入内容 12sheet-&gt;writeStr(1,0,&quot;xxx&quot;);sheet-&gt;writeNum(1,1, 123); 保存结束 12book-&gt;save(&quot;文件保存路径&quot;);book-&gt;release(); JSONCPP这篇博客概括的很全 https://www.coonote.com/cplusplus-note/jsoncpp.html","link":"/2023/05/10/c++/"},{"title":"Windows内核逆向学习记录","text":"记载一些驱动开发过程中学习到的东西 环境搭建win10虚拟机安装debugView和DriverMonitor, 本机VS安装WDK, 测试代码 12345678910NTSTATUSDriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath){ DbgPrint(&quot;hello driver&quot;); //regCallBack(); return STATUS_SUCCESS;} 在DebugView先connect local连接虚拟机,然后capture kernel 在DriverMonitor加载启动驱动,如果遇到签名验证失败问题,按住shift并点击重启按钮,进入疑难解答-&gt;高级选项-&gt;启动设置-&gt;禁用驱动签名 基本概念MDL是内存描述符列表（Memory Descriptor List）的缩写，它主要用于关联虚拟地址和物理地址，类似于页表，但比页表简单。MDL在内存中的作用很大，它用于驱动的数据传输和缓冲管理，以及页错误等场景。此外，MDL还用于跨进程访问用户空间。 CR3寄存器是一种控制寄存器，用于存储页目录表的物理地址。在x86架构的操作系统中，分页机制被用来将虚拟地址映射到物理地址。为了实现这种映射，需要使用页表和页目录表来管理地址转换。CR3寄存器存储了页目录表的物理地址，通过改变CR3寄存器的值，可以实现不同的虚拟地址空间之间的切换。当处理器执行访问内存的指令时，它会将虚拟地址发送给内存管理单元（MMU）。MMU会根据当前CR3寄存器中存储的页目录表地址进行地址转换，将虚拟地址转换为物理地址，并完成内存的访问 IO通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//DriverMain.cpp#include &lt;ntifs.h&gt;#define _DEVICE_NAME L&quot;\\\\device\\\\pzk&quot;#define _SYM_NAME L&quot;\\\\??\\\\pzk&quot;//设备NTSTATUS DefCreate( _In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp){ DbgPrintEx(77, 0, &quot;DefCreate\\r\\n&quot;); IoCompleteRequest(Irp, 0); return STATUS_SUCCESS;}NTSTATUS DefDelete( _In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp){ DbgPrintEx(77, 0, &quot;DefDelete\\r\\n&quot;); IoCompleteRequest(Irp, 0); return STATUS_SUCCESS;}NTSTATUS DefControl( _In_ struct _DEVICE_OBJECT* DeviceObject, _Inout_ struct _IRP* Irp){ DbgPrintEx(77, 0, &quot;DefControl\\r\\n&quot;); IoCompleteRequest(Irp, 0); return STATUS_SUCCESS;}VOID DriverUnload(PDRIVER_OBJECT pDriver){ if (pDriver-&gt;DeviceObject) { UNICODE_STRING UnSymeName = { 0 }; RtlInitUnicodeString(&amp;UnSymeName, _SYM_NAME); IoDeleteSymbolicLink(&amp;UnSymeName); IoDeleteDevice(pDriver-&gt;DeviceObject); }}NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pReg){ pDriver-&gt;DriverUnload = DriverUnload; DbgPrint(&quot;hello driver&quot;); UNICODE_STRING UnDeviceName = { 0 }; RtlInitUnicodeString(&amp;UnDeviceName, _DEVICE_NAME); UNICODE_STRING UnSymeName = { 0 }; RtlInitUnicodeString(&amp;UnSymeName, _SYM_NAME); PDEVICE_OBJECT pDevice = NULL; //创建设备 NTSTATUS st = IoCreateDevice(pDriver, 0, &amp;UnDeviceName, FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN, FALSE, &amp;pDevice); if(!NT_SUCCESS(st)) { return STATUS_UNSUCCESSFUL; } //创建符号链接 st = IoCreateSymbolicLink(&amp;UnSymeName, &amp;UnDeviceName); if (!NT_SUCCESS(st)) { IoDeleteDevice(pDevice); return STATUS_UNSUCCESSFUL; } //设置设备标志,去除初始化表 pDevice-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING; //使用什么内存 pDevice-&gt;Flags |= DO_BUFFERED_IO; pDriver-&gt;MajorFunction[IRP_MJ_CREATE] = DefCreate; pDriver-&gt;MajorFunction[IRP_MJ_CLOSE] = DefDelete; pDriver-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DefControl; return STATUS_SUCCESS;}//io通信R3.cpp#include &lt;Windows.h&gt;#include &lt;iostream&gt;#define _SYM_NAME &quot;\\\\\\\\.\\\\pzk&quot;int main(){ HANDLE hDevice = CreateFileA(_SYM_NAME,GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,NULL); if (!hDevice) { printf(&quot;打开设备失败%d\\r\\n&quot;, GetLastError()); system(&quot;pause&quot;); } else { printf(&quot;打开设备成功\\r\\n&quot;); ULONG retLen = 0; BOOL isSuccess = DeviceIoControl(hDevice, 0, NULL, 4, NULL, 4, &amp;retLen, 0); if (isSuccess) { printf(&quot;success\\r\\n&quot;); } } system(&quot;pause&quot;);}","link":"/2024/05/01/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"逆向","slug":"逆向","link":"/tags/%E9%80%86%E5%90%91/"},{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"杂记","slug":"杂记","link":"/tags/%E6%9D%82%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"驱动","slug":"驱动","link":"/tags/%E9%A9%B1%E5%8A%A8/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"实践","slug":"实践","link":"/categories/%E5%AE%9E%E8%B7%B5/"}],"pages":[{"title":"2024腾讯游戏安全PC初赛","text":"小Q是一个PC客户端安全爱好者。有一天他得到了一个未知工具，含有一个exe、一个sys和一份使用说明。说明写道:ACE的宝库钥匙由两串 token组成．运行这组程序．它们会将两串 token藏于内存中。宝库有两位守护者会制裁使用违禁工具的冒险家，在寻宝时务必谨慎小心。 题目 （一）解题过程拿到hack.exe，浅分析一下发现加了VM，并且有检测黑客工具的行为，检测到了之后即使关闭黑客程序也会影响程序正常运行，但是xdbg稍微改一下还是可以动调的，在xdbg里下一些可能的函数断点，我这里在这些地方下了断点 运行发现程序会多次在WriteProcessMemory下断下，hook一下观察传参 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//dllmain.cpp#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _KDEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];typedef BOOL(WINAPI* WriteProcessMemory_t)( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten );WriteProcessMemory_t TrueWriteProcessMemory = NULL;BOOLWINAPIHookWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten){ char fileName[12] = { 0 }; sprintf(fileName, &quot;out%d.txt&quot;, (int)hProcess % 1000); HANDLE hFile = CreateFile(fileName, FILE_APPEND_DATA, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { DBGMGEBOX(&quot;CreateFile Fail&quot;); return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten); } SetFilePointer(hFile, 0, NULL, FILE_END); DWORD bytesWritten; BOOL result = WriteFile(hFile, lpBuffer, nSize, &amp;bytesWritten, NULL); CloseHandle(hFile); DBGMGEBOX(&quot;findProcess WriteProcessMemory:%p,size:%d\\n&quot;, hProcess,nSize); return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); TrueWriteProcessMemory = (WriteProcessMemory_t)DetourFindFunction(&quot;kernel32.dll&quot;, &quot;WriteProcessMemory&quot;); DetourAttach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; } return TRUE;} 这里输出了三个txt文件 其中out200.txt文件有明显的PE头 去除前面的字节，把文件丢到DIE里分析一下发现是dll64文件并且貌似没加壳，所以hack.exe通过WriteProcessMemory往某个进程写入了一个dll?怀疑是远程注入，至于做了什么，有可能跟token有关，继续分析。 ida64打开发现程序的dllMain入口还是被加密了 还是继续动调，随便找了个64位的可执行文件，拖到X64dbg里运行，直接用xdbg的注入方式将out200.dll注入进程，在 入口点下断点，并且对一些可疑的WINDOWS API下断观察进程行为 这里我对下面这几个API下了断点 运行，第一次成功在openProcess函数断下 观察传参窗口，找到了一个系统进程名称字符串winlogon.exe，而这里调用的是openProcess，疑似是对系统进程winlogon.exe做了一些操作。继续分析，运行到返回，回溯一层函数，找到一段没有被加密的代码 汇编代码不是很好看，根据偏移在IDA里反汇编看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149__int64 __fastcall sub_1800063D0(_DWORD *Dst, DWORD dwProcessId){ __m128i si128; // xmm0 __m128i v6; // xmm0 __int64 result; // rax __m128i v10; // xmm2 size_t v14; // rbx __int64 v15; // rax int v16; // r14d HANDLE Toolhelp32Snapshot; // rsi HANDLE v18; // rax __int64 v21; // rbx CHAR Caption[16]; // [rsp+40h] [rbp+0h] BYREF _RBP = (unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64; if ( !dwProcessId ) { *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)_RBP = 0xE795A71250E2465Aui64; si128 = _mm_load_si128((const __m128i *)_RBP); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xE795A7603F90341Fui64; v6 = _mm_xor_si128(si128, *(__m128i *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20)); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0x84FAD5301FE45158ui64; *(__m128i *)_RBP = v6; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xBF19D3ADD5D97A59ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A0) = 0xE795A7603F90341Fui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = 0xBD1C9CA3F4C12EC9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = 0xA727C05763438E84ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B0) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B8) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+210h+var_70] vpxor ymm1, ymm0, ymmword ptr [rbp+210h+Text] vmovdqa ymmword ptr [rbp+210h+Text], ymm1 vzeroupper } MessageBoxA(0i64, (LPCSTR)(_RBP + 32), (LPCSTR)((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64), 0);LABEL_3: GetLastError(); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xE795A7603F90341Fui64; *(_QWORD *)_RBP = 0x88D6871250E2465Aui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 8) = 0xC65BF98DB9906C58ui64; *(__m128i *)_RBP = _mm_xor_si128( _mm_load_si128((const __m128i *)_RBP), *(__m128i *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20)); return sub_180006A00((void *)((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64)); } if ( !(unsigned __int8)sub_180006FC0() ) { *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A0) = 0xE795A7603F90341Fui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x48) = 0x44F651D568826090i64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1C0) = 0x52C9FCDC77FF5FC3i64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xDDD2E92971C27548ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xA43EB7C9E8CF4E1Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = 0xA62FD5B4C980079Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = 0xD55585772756849Aui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x40) = 0x52C9FCDC7DDE2DACi64; v10 = _mm_load_si128((const __m128i *)(_RBP + 64)); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1C8) = 0x44F651D568826090i64; _XMM2 = _mm_xor_si128(v10, *(__m128i *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1C0)); *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B0) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B8) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+210h+var_70] vpxor ymm1, ymm0, ymmword ptr [rbp+210h+Text] vmovdqa [rbp+210h+var_1D0], xmm2 vmovdqa ymmword ptr [rbp+210h+Text], ymm1 vzeroupper } sub_180006A00((void *)(_RBP + 32)); } v14 = -1i64; if ( dwProcessId == -1 ) { Dst[34] = GetCurrentProcessId(); *((_QWORD *)Dst + 13) = -1i64; } else { Dst[34] = dwProcessId; v18 = OpenProcess(0x1FFFFFu, 0, dwProcessId); *((_QWORD *)Dst + 13) = v18; if ( !v18 ) { *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x38) = 0xA727C0574231E1F6ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0x84FAD53051F54450ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A0) = 0xE795A7603F90341Fui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xA92981ACBCD97A59ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) = 0xCF59BCC699AA419Bui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1A8) = 0xC65BF3E99CAA093Cui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B0) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x1B8) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+210h+var_70] vpxor ymm1, ymm0, ymmword ptr [rbp+210h+Text] vmovdqa ymmword ptr [rbp+210h+Text], ymm1 vzeroupper } sub_180006A00((void *)(_RBP + 32));//打印报错信息 goto LABEL_3; } } Dst[30] = 0x1FFFFF; v15 = -1i64; do ++v15; while ( *((_BYTE *)Dst + v15) ); if ( !v15 ) { v16 = Dst[34]; Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0); if ( Toolhelp32Snapshot != (HANDLE)-1i64 ) { *(_DWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = 304; memset((void *)(_RBP + 100), 0, 0x12Cui64); if ( Process32First(Toolhelp32Snapshot, (LPPROCESSENTRY32)(_RBP + 96)) ) { while ( *(_DWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x68) != v16 ) { if ( !Process32Next(Toolhelp32Snapshot, (LPPROCESSENTRY32)(_RBP + 96)) ) goto LABEL_20; } do ++v14; while ( *(_BYTE *)(_RBP + 140 + v14) ); memmove(Dst, (const void *)(_RBP + 140), v14); }LABEL_20: CloseHandle(Toolhelp32Snapshot); } } *((_QWORD *)Dst + 18) = sub_1800068D0(Dst, Dst); v21 = 0i64; *(_DWORD *)(((unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64) + 8) = Dst[34]; *(_QWORD *)_RBP = 0i64; EnumWindows(EnumFunc, (unsigned __int64)Caption &amp; 0xFFFFFFFFFFFFFFE0ui64); result = *(_QWORD *)_RBP; if ( *(_QWORD *)_RBP ) v21 = *(_QWORD *)_RBP; *((_QWORD *)Dst + 16) = v21; return result;} 这段代码一次进行了获取进程pid，打开进程，遍历模块等操作，并且在函数失败后做了一些奇奇怪怪的东西，对一些地址赋上了一些64位的值，猜测是隐藏字符串来打印调试信息用的，再通过messagebox和outputDebugString给出调试信息，显示打开进程失败，猜测是因为hack.exe启动是管理员启动，这里失去了管理员权限。 分析完这个函数，继续回溯一层，运行到返回，定位到这个地方 继续根据偏移转到IDA里看反汇编 123456789101112131415161718192021222324252627int sub_180001990(){ size_t v0; // rbx DWORD v1; // eax __m128i Dst; // [rsp+20h] [rbp-48h] BYREF __int64 v4; // [rsp+30h] [rbp-38h] __int64 v5; // [rsp+38h] [rbp-30h] __m128i Src; // [rsp+40h] [rbp-28h] BYREF Dst.m128i_i64[0] = 0xE795A7603F90341Fui64; Dst.m128i_i64[1] = 0xC65BF3E99CAA093Cui64; Src.m128i_i64[0] = 0x89FAC00F53FE5D68ui64; Src.m128i_i64[1] = 0xC65BF3E9F9D26C12ui64; Src = _mm_xor_si128(_mm_load_si128(&amp;Src), Dst); v0 = -1i64; do ++v0; while ( Src.m128i_i8[v0] ); memmove(dword_1800349A0, &amp;Src, v0); Dst.m128i_i64[0] = 0i64; v4 = 0i64; v5 = 15i64; sub_180004770(&amp;Dst, &amp;Src, v0); v1 = sub_1800070A0(&amp;Dst); sub_1800063D0(dword_1800349A0, v1); return atexit(sub_180020C90);} 前面应该是一个加密的字符串操作，用python打印出字符串 123456789101112131415161718192021def hex_xor_to_string(a, b): result = a ^ b hex_str = hex(result)[2:] if len(hex_str) % 2 != 0: hex_str = '0' + hex_str result_str = ''.join(chr(int(hex_str[i:i+2], 16)) for i in range(0, len(hex_str), 2)) return result_strx1 = 0xE795A7603F90341Fx2 = 0xC65BF3E99CAA093Cy1 = 0x89FAC00F53FE5D68y2 = 0xC65BF3E9F9D26C12result1 = hex_xor_to_string(x1, y1)result2 = hex_xor_to_string(x2, y2)print(&quot;Result 1:&quot;, result1)print(&quot;Result 2:&quot;, result2)#Result 1: nogolniw#Result 2: exe. 得到的刚好是winlogon.exe字符串，然后程序将这个字符串转移到了dword_1800349A0全局变量中，目的应该是隐藏字符串，接着sub_180004770函数也是一个类似memmove操作，把这个字符串传到了Dst局部变量中，接着在sub_1800070A0中传入这个字符串，貌似是在根据字符串获取进程PID，接着调用sub_1800063D0函数根据pid打开进程，并将进程句柄存储到了某个地方 12v18 = OpenProcess(0x1FFFFFu, 0, dwProcessId);*((_QWORD *)Dst + 13) = v18; 随后return exit退出。 随后我在退出函数传参的时候看到了一个hProcess 一个全局变量，很有可能在其他地方对句柄进行了读取，交叉引用一下定位到如下函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void sub_180007C10(){ HANDLE v1; // rcx void *v2; // rdx __int128 v3; // xmm0 __int128 v4; // xmm1 HANDLE FileA; // rbx __int64 v8; // rcx _BYTE *v9; // rdx unsigned __int64 v10; // rdx _QWORD *v11; // rcx char Buffer; // [rsp+60h] [rbp+0h] BYREF _RBP = (unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64; while ( byte_180032C00 ) { if ( !byte_180034961 &amp;&amp; !byte_180034960 ) sub_1800041D0(); v1 = hProcess; v2 = (void *)(qword_180034968 + 2766); *(_BYTE *)_RBP = 15; WriteProcessMemory(v1, v2, (LPCVOID)((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64), 1ui64, 0i64); byte_180032C00 = 0; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20) = 0xAA32D3B2B7C50388ui64; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x10) = 0xA0A195500DCC0E5Cui64; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x18) = 0x943E9588CFCF645Dui64; v3 = *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x10); *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x28) = 0xA727C0574231D098ui64; v4 = *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x20); *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x80) = 0xE795A7603F90341Fui64; *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x60) = v3; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x88) = 0xC65BF3E99CAA093Cui64; *(_OWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x70) = v4; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x90) = 0xCF59BCC699A060E9ui64; *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x98) = 0xA727C0574231E1F6ui64; __asm { vmovdqu ymm0, [rbp+0D0h+var_50] vpxor ymm1, ymm0, ymmword ptr [rbp+0D0h+FileName] vmovdqa ymmword ptr [rbp+0D0h+FileName], ymm1 vzeroupper } FileA = CreateFileA((LPCSTR)(_RBP + 96), 0x40000000u, 0, 0i64, 3u, 0x80u, 0i64); if ( FileA != (HANDLE)-1i64 ) { ((void (__fastcall *)(unsigned __int64))loc_180007A20)(_RBP + 48); v8 = -1i64; if ( *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x48) &lt; 0x10ui64 ) { do ++v8; while ( *(_BYTE *)(_RBP + 48 + v8) ); v9 = (_BYTE *)(_RBP + 48); } else { v9 = *(_BYTE **)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30); do ++v8; while ( v9[v8] ); } WriteFile(FileA, v9, v8, (LPDWORD)(_RBP + 8), 0i64); CloseHandle(FileA); v10 = *(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x48); if ( v10 &gt;= 0x10 ) { v11 = *(_QWORD **)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30); if ( v10 + 1 &gt;= 0x1000 ) { v11 = (_QWORD *)*(v11 - 1); if ( (unsigned __int64)(*(_QWORD *)(((unsigned __int64)&amp;Buffer &amp; 0xFFFFFFFFFFFFFFE0ui64) + 0x30) - (_QWORD)v11 - 8i64) &gt; 0x1F ) invalid_parameter_noinfo_noreturn(); } j_j_free(v11); } } }} 看到了有WriteProcessMemory写入hProcess内存操作，CreateFileA，WriteFile，打开和写入文件操作，但是并没有找到hProcess的赋值语句，也就是说这个进程句柄还不知道是谁的，猜测赋值被隐藏了，但是可以猜测可能是winlogon.exe进程句柄。byte_180032C00是一个全局的标志变量，强制函数只能执行一次，对应的是运行程序时仅一次的初始化操作。接着看一下CreateFileA函数，同样的文件名被隐藏了，python解析一下 123456789101112131415161718192021222324252627282930def hex_xor_to_string(a, b): result = a ^ b hex_str = hex(result)[2:] if len(hex_str) % 2 != 0: hex_str = '0' + hex_str result_str = ''.join(chr(int(hex_str[i:i+2], 16)) for i in range(0, len(hex_str), 2)) return result_strx1 = 0xA0A195500DCC0E5Cx2 = 0x943E9588CFCF645Dx3 = 0xAA32D3B2B7C50388x4 = 0xA727C0574231D098y1 = 0xE795A7603F90341Fy2 = 0xC65BF3E99CAA093Cy3 = 0xCF59BCC699A060E9y4 = 0xA727C0574231E1F6result1 = hex_xor_to_string(x1, y1)result2 = hex_xor_to_string(x2, y2)result3 = hex_xor_to_string(x3, y3)result4 = hex_xor_to_string(x4, y4)print(&quot;Result 1:&quot;, result1)print(&quot;Result 2:&quot;, result2)print(&quot;Result 3:&quot;, result3)print(&quot;Result 4:&quot;, result4)res = result1[::-1] + result2[::-1] + result3[::-1] + result4[::-1]print(res) 整个拼起来是字符串C:\\2024GameSafeRace.token1，应该是创建了一个文件，然后向这个文件写入了token1了，接着往下 loc_180007A20这个函数内部被加密了，猜测是对token1的解密过程，然后通过WriteFile写入C:\\2024GameSafeRace.token1中，并不是很像去分析这个函数，直接加载驱动看看能不能直接运行得到2024GameSafeRace.token1文件。 找到下没找到，回头看看CreateFileA函数，核查一下后面几个参数 1FileA = CreateFileA((LPCSTR)(_RBP + 96), 0x40000000u, 0, 0i64, 3u, 0x80u, 0i64); 看来是参数在作怪，CreateFileA函数传入OPEN_EXISTING参数，如果没有指定文件，则函数会返回失败，那也好办，自己创建一个就好了。 C:\\2024GameSafeRace.token1成功被写入 010打开找到token1:757F4749AEBB1891EF5AC2A9B5439CEA token2的寻找就偏简单了，加载驱动后留意一下dbgView的打印信息就可以获取 组合一下就是token2：803f14a24d64f3e697957c252e3a5686 （二）解题过程题目要求： 编写程序，运行时修改尽量少的内存，让两段token输出成功。（满分2分） 根据之前分析的token1，我们可以知道程序会在CreateFileA后解密token1然后写入到C:\\2024GameSafeRace.token1中，但是会因为CreateFileA参数OPEN_EXISTING条件不满足而失败，所以我们只需要修改这个传参，改成OPEN_ALWAYS，即可实现输出token1，那我们只需要hook CreateFileA函数修改传参即可，但是有个问题，因为不是hack.exe本身调用CreateFileA函数，而是hack.exe注入了一个dll到winlogon.exe，然后再winlogon.exe里调用CreateFileA函数，所以我们可以考虑在注入前修改WriteProcessMemory函数参数buffer，从而在注入前patch dll，或者编写代码直接注入winlogon.exe，hook CreateFileA函数修改传参，但是考虑到第二种方式可能不被允许，winlogon.exe毕竟是系统进程，题目应该是要我们通过patch dll的方式解题。 这里我们要patch 传参，通过ida找到传参的汇编代码 在winhex里找到对应所在文件偏移 也就是在0x7171处OPEN_EXISTING:0x3是要patch的地方，把这个参数修改成OPEN_ALWAYS:0x4即可。下面编写代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//dllmain.cpp#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _KDEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];typedef BOOL(WINAPI* WriteProcessMemory_t)( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten );WriteProcessMemory_t TrueWriteProcessMemory = NULL;BOOLWINAPIHookWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten){ if (nSize == 4506624 &amp;&amp; *((PUCHAR)lpBuffer + 0x7171) == 0x3) { *((PUCHAR)lpBuffer + 0x7171) = 0x4; DBGMGEBOX(&quot;Hook Success!\\n&quot;); } return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); TrueWriteProcessMemory = (WriteProcessMemory_t)DetourFindFunction(&quot;kernel32.dll&quot;, &quot;WriteProcessMemory&quot;); DetourAttach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; } return TRUE;} 成功输出token1文件： 然后是token2，既然是内核输出，那只能是在ace.sys里做点手脚，DIE查壳发现ace.sys的大部分代码都被加壳过了，静态代码不好看，只能先猜测token2的输出调用了DbgPrint或者DbgPrintEx，因为之前输出token2的时候开启了Verbose Kernel outPut，猜测之所以正常输出失败是因为DbgPrintEx的level值太低，仅将字符串传递给内核调试器，不执行输出操作。 hook DbgPrintEx函数看一眼传参。 123456789101112131415161718192021222324252627282930313233343536#include &lt;ntifs.h&gt;#include &lt;ntdef.h&gt;#include &lt;ntstatus.h&gt;#include &lt;ntddk.h&gt;#include &lt;stdarg.h&gt;#include &quot;R0Hook.h&quot;#define dbgFilter &quot;Kvancy:&quot;typedef ULONG(*FuncPtr) (ULONG ComponentId, ULONG Level, PCSTR Format, ...);HOOK_MANAGER hookManager;ULONG myDbgPrintEx(ULONG ComponentId, ULONG Level, PCSTR Format, ...) { Unhook(&amp;hookManager); FuncPtr func = (FuncPtr)hookManager.target; kPrint(&quot;%s DbgPrintEx ComponentId:%lu,Level:%lu\\n&quot;,dbgFilter, ComponentId, Level); va_list args; va_start(args, Format); NTSTATUS s = func(ComponentId, Level, Format, args); va_end(args); ApplyHook(&amp;hookManager); return s;}void DriverUnload(PDRIVER_OBJECT pDriver) { kPrint(&quot;%s DriverUnload\\n&quot;, dbgFilter); Unhook(&amp;hookManager);}NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = DriverUnload; PVOID dbgPrintEx = DbgPrintEx; InitializeHookManager(&amp;hookManager, dbgPrintEx, myDbgPrintEx); ApplyHook(&amp;hookManager); DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, &quot;%s DriverEntry\\n&quot;,dbgFilter); return STATUS_SUCCESS;} 发现加载ace驱动后，有大量的level:5的调试信息输出 也就是说，程序通过设置调试信息的重要级别来控制调试信息是否正常输出，于是可以提高level级别来输出token2，那么最简单的方式就是hook之后修改level后传回去，编写代码hook测试下。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;ntifs.h&gt;#include &lt;ntdef.h&gt;#include &lt;ntstatus.h&gt;#include &lt;ntddk.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &quot;R0Hook.h&quot;#define dbgFilter &quot;Kvancy:&quot;typedef ULONG(*FuncPtr) (ULONG ComponentId, ULONG Level, PCSTR Format, ...);HOOK_MANAGER hookManager;char buffer[1024]; ULONG myDbgPrintEx(ULONG ComponentId, ULONG Level, PCSTR Format, ...) { Unhook(&amp;hookManager); FuncPtr func = (FuncPtr)hookManager.target; va_list args; va_start(args, Format); vsprintf(buffer, Format, args); va_end(args); NTSTATUS s = func(ComponentId, 0, &quot;%s&quot;, buffer);//修改level为0 ApplyHook(&amp;hookManager); return s;}void DriverUnload(PDRIVER_OBJECT pDriver) { kPrint(&quot;Kvancy: DriverUnload\\n&quot;); Unhook(&amp;hookManager);}NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = DriverUnload; PVOID dbgPrintEx = DbgPrintEx; InitializeHookManager(&amp;hookManager, dbgPrintEx, myDbgPrintEx); ApplyHook(&amp;hookManager); DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, &quot;Kvancy: DriverEntry\\n&quot;); return STATUS_SUCCESS;} 成功输出token2，但是根据题目要求是不能修改系统模块代码的，也就是说hook内核函数的方法不能过这道题，还是得想想别的方法。现在已知的ace.sys的行为就是驱动会在被加载之后做了某些操作会使得系统持续调用DbgPrintEx来输出token2，但是ace.sys其实做了某种操作后就被卸载掉了，如下图所示。 可以想到就是说驱动启动了一个线程或者进程，让该任务持续输出token2，创建完随后再卸载自己并且不停止这个线程或者进程。先枚举进程看看有没有奇怪的进程出现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586VOID WriteToFile(PUNICODE_STRING FilePath, PCHAR Data){ OBJECT_ATTRIBUTES objAttr; IO_STATUS_BLOCK ioStatusBlock; HANDLE fileHandle; NTSTATUS status; UNICODE_STRING unicodeFilePath; RtlInitUnicodeString(&amp;unicodeFilePath, FilePath-&gt;Buffer); InitializeObjectAttributes(&amp;objAttr, &amp;unicodeFilePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL); status = ZwCreateFile( &amp;fileHandle, FILE_APPEND_DATA | SYNCHRONIZE, &amp;objAttr, &amp;ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0 ); if (NT_SUCCESS(status)) { size_t dataLength = strlen(Data); ZwWriteFile(fileHandle, NULL, NULL, NULL, &amp;ioStatusBlock, Data, (ULONG)dataLength, NULL, NULL); ZwClose(fileHandle); } else { DbgPrint(&quot;Failed to create file: %08X\\n&quot;, status); }}VOID EnumProcesses(){ NTSTATUS status; PVOID buffer; ULONG bufferSize = 0x10000; // Initial buffer size, can grow if needed ULONG returnLength; CHAR logBuffer[1024]; UNICODE_STRING filePath; RtlInitUnicodeString(&amp;filePath, L&quot;\\\\??\\\\C:\\\\Users\\\\15386\\\\Desktop\\\\1.txt&quot;); buffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!buffer) { DbgPrint(&quot;Failed to allocate buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &amp;returnLength); if (status == STATUS_INFO_LENGTH_MISMATCH) { ExFreePool(buffer); bufferSize = returnLength; buffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!buffer) { DbgPrint(&quot;Failed to allocate larger buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &amp;returnLength); } if (NT_SUCCESS(status)) { PSYSTEM_PROCESS_INFORMATION processInfo = (PSYSTEM_PROCESS_INFORMATION)buffer; while (TRUE) { if (processInfo-&gt;ImageName.Buffer) { _snprintf(logBuffer, sizeof(logBuffer), &quot;Process ID: %lu, Name: %wZ\\n&quot;, (ULONG)(ULONG_PTR)processInfo-&gt;ProcessId, &amp;processInfo-&gt;ImageName); } else { _snprintf(logBuffer, sizeof(logBuffer), &quot;Process ID: %lu, Name: [System Process]\\n&quot;, (ULONG)(ULONG_PTR)processInfo-&gt;ProcessId); } WriteToFile(&amp;filePath, logBuffer); if (processInfo-&gt;NextEntryOffset == 0) break; processInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)processInfo + processInfo-&gt;NextEntryOffset); } } ExFreePool(buffer);} 结果发现好像没有奇怪的进程被创建出来，那么有可能是驱动利用PsCreateSystemThread创建了一个内核线程。hookPsCreateSystemThread函数看看驱动加载时是否调用了这个函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;ntifs.h&gt;#include &lt;ntdef.h&gt;#include &lt;ntstatus.h&gt;#include &lt;ntddk.h&gt;#include &lt;stdarg.h&gt;#include &quot;R0Hook.h&quot;#define dbgFilter &quot;Kvancy:&quot;typedef ULONG(*FuncPtr) ( PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);HOOK_MANAGER hookManager;NTSTATUS myPsCreateSystemThread( PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext){ Unhook(&amp;hookManager); FuncPtr func = (FuncPtr)hookManager.target; kPrint(&quot;%s myPsCreateSystemThread StartRoutine:%p\\n&quot;, dbgFilter, StartRoutine); NTSTATUS s = func(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, ClientId, StartRoutine, StartContext); ApplyHook(&amp;hookManager); return s;}void DriverUnload(PDRIVER_OBJECT pDriver) { kPrint(&quot;%s DriverUnload\\n&quot;, dbgFilter); Unhook(&amp;hookManager);}NTSTATUS DriverEntry( _In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = DriverUnload; PVOID dbgPrintEx = PsCreateSystemThread; InitializeHookManager(&amp;hookManager, dbgPrintEx, myPsCreateSystemThread); ApplyHook(&amp;hookManager); DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, &quot;%s DriverEntry\\n&quot;, dbgFilter); return STATUS_SUCCESS;} 发现在token2输出前确实有PsCreateSystemThread函数调用，虽然不确定是不是ace.sys创建的。在windbg里反汇编看看线程函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687880: kd&gt; u FFFFBA0729013DB0 l 100ffffba07`29013db0 488bc4 mov rax,rspffffba07`29013db3 48895808 mov qword ptr [rax+8],rbxffffba07`29013db7 48897818 mov qword ptr [rax+18h],rdiffffba07`29013dbb 4c897020 mov qword ptr [rax+20h],r14ffffba07`29013dbf 55 push rbpffffba07`29013dc0 488d68a1 lea rbp,[rax-5Fh]ffffba07`29013dc4 4881eca0000000 sub rsp,0A0hffffba07`29013dcb 48bf4e93328b546b331e mov rdi,1E336B548B32934Ehffffba07`29013dd5 49bed520794add1d6d4b mov r14,4B6D1DDD4A7920D5hffffba07`29013ddf 0f57c0 xorps xmm0,xmm0ffffba07`29013de2 488d4d37 lea rcx,[rbp+37h]ffffba07`29013de6 0f114537 movups xmmword ptr [rbp+37h],xmm0ffffba07`29013dea e8d1030000 call ffffba07`290141c0ffffba07`29013def 48b8a14f122fb3276d4b mov rax,4B6D27B32F124FA1hffffba07`29013df9 4c8d45e7 lea r8,[rbp-19h]ffffba07`29013dfd 4889456f mov qword ptr [rbp+6Fh],raxffffba07`29013e01 ba05000000 mov edx,5ffffba07`29013e06 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e0a 33c9 xor ecx,ecxffffba07`29013e0c 488945e7 mov qword ptr [rbp-19h],raxffffba07`29013e10 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e14 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e18 488945ef mov qword ptr [rbp-11h],raxffffba07`29013e1c 4c89756f mov qword ptr [rbp+6Fh],r14ffffba07`29013e20 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e24 48894517 mov qword ptr [rbp+17h],raxffffba07`29013e28 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e2c 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e30 660f6f45e7 movdqa xmm0,xmmword ptr [rbp-19h]ffffba07`29013e35 4889451f mov qword ptr [rbp+1Fh],raxffffba07`29013e39 660fef4517 pxor xmm0,xmmword ptr [rbp+17h]ffffba07`29013e3e 488b0543330000 mov rax,qword ptr [ffffba07`29017188]ffffba07`29013e45 660f7f45e7 movdqa xmmword ptr [rbp-19h],xmm0ffffba07`29013e4a ff15c8210000 call qword ptr [ffffba07`29016018]ffffba07`29013e50 33db xor ebx,ebxffffba07`29013e52 48b8f0104b32dd1d6d4b mov rax,4B6D1DDD324B10F0hffffba07`29013e5c 4c8d45f7 lea r8,[rbp-9]ffffba07`29013e60 4889456f mov qword ptr [rbp+6Fh],raxffffba07`29013e64 ba05000000 mov edx,5ffffba07`29013e69 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e6d 33c9 xor ecx,ecxffffba07`29013e6f 488945f7 mov qword ptr [rbp-9],raxffffba07`29013e73 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e77 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e7b 488945ff mov qword ptr [rbp-1],raxffffba07`29013e7f 4c89756f mov qword ptr [rbp+6Fh],r14ffffba07`29013e83 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e87 48894527 mov qword ptr [rbp+27h],raxffffba07`29013e8b 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013e8f 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013e93 660f6f45f7 movdqa xmm0,xmmword ptr [rbp-9]ffffba07`29013e98 440fb64c1d37 movzx r9d,byte ptr [rbp+rbx+37h]ffffba07`29013e9e 4889452f mov qword ptr [rbp+2Fh],raxffffba07`29013ea2 660fef4527 pxor xmm0,xmmword ptr [rbp+27h]ffffba07`29013ea7 488b05da320000 mov rax,qword ptr [ffffba07`29017188]ffffba07`29013eae 660f7f45f7 movdqa xmmword ptr [rbp-9],xmm0ffffba07`29013eb3 ff155f210000 call qword ptr [ffffba07`29016018]ffffba07`29013eb9 48ffc3 inc rbxffffba07`29013ebc 4883fb10 cmp rbx,10hffffba07`29013ec0 7c90 jl ffffba07`29013e52ffffba07`29013ec2 48b8df20794add1d6d4b mov rax,4B6D1DDD4A7920DFhffffba07`29013ecc 4c8d4507 lea r8,[rbp+7]ffffba07`29013ed0 4889456f mov qword ptr [rbp+6Fh],raxffffba07`29013ed4 ba05000000 mov edx,5ffffba07`29013ed9 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013edd 33c9 xor ecx,ecxffffba07`29013edf 48894507 mov qword ptr [rbp+7],raxffffba07`29013ee3 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013ee7 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013eeb 4889450f mov qword ptr [rbp+0Fh],raxffffba07`29013eef 4c89756f mov qword ptr [rbp+6Fh],r14ffffba07`29013ef3 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013ef7 48894547 mov qword ptr [rbp+47h],raxffffba07`29013efb 48897d6f mov qword ptr [rbp+6Fh],rdiffffba07`29013eff 488b456f mov rax,qword ptr [rbp+6Fh]ffffba07`29013f03 660f6f4507 movdqa xmm0,xmmword ptr [rbp+7]ffffba07`29013f08 4889454f mov qword ptr [rbp+4Fh],raxffffba07`29013f0c 660fef4547 pxor xmm0,xmmword ptr [rbp+47h]ffffba07`29013f11 488b0570320000 mov rax,qword ptr [ffffba07`29017188]ffffba07`29013f18 660f7f4507 movdqa xmmword ptr [rbp+7],xmm0ffffba07`29013f1d ff15f5200000 call qword ptr [ffffba07`29016018]ffffba07`29013f23 b9ce0a0000 mov ecx,0ACEhffffba07`29013f28 e833e9ffff call ffffba07`29012860ffffba07`29013f2d e9adfeffff jmp ffffba07`29013ddfffffba07`29013f32 cc int 3ffffba07`29013f33 cc int 3ffffba07`29013f34 4152 push r10 导入到ida里看伪代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __noreturn sub_180005148(){ __m128i v0; // xmm0 __int64 i; // rbx __m128i v2; // xmm0 __int64 v3; // r9 __m128i v4; // xmm0 __m128i v5; // [rsp+30h] [rbp-19h] BYREF __m128i v6; // [rsp+40h] [rbp-9h] BYREF __m128i v7; // [rsp+50h] [rbp+7h] BYREF __m128i v8; // [rsp+60h] [rbp+17h] __m128i v9; // [rsp+70h] [rbp+27h] __int128 v10; // [rsp+80h] [rbp+37h] BYREF __m128i v11; // [rsp+90h] [rbp+47h] while ( 1 ) { v10 = 0i64; ((void (__fastcall *)(__int128 *))((char *)&amp;loc_180005556 + 2))(&amp;v10); v5.m128i_i64[0] = 0x4B6D27B32F124FA1i64; v5.m128i_i64[1] = 0x1E336B548B32934Ei64; v8.m128i_i64[0] = 0x4B6D1DDD4A7920D5i64; v0 = _mm_load_si128(&amp;v5); v8.m128i_i64[1] = 0x1E336B548B32934Ei64; v5 = _mm_xor_si128(v0, v8); MEMORY[0x31305A8047353130](0i64, 5i64, &amp;v5); for ( i = 0i64; i &lt; 16; ++i ) { v6.m128i_i64[0] = 0x4B6D1DDD324B10F0i64; v6.m128i_i64[1] = 0x1E336B548B32934Ei64; v9.m128i_i64[0] = 0x4B6D1DDD4A7920D5i64; v2 = _mm_load_si128(&amp;v6); v3 = *((unsigned __int8 *)&amp;v10 + i); v9.m128i_i64[1] = 0x1E336B548B32934Ei64; v6 = _mm_xor_si128(v2, v9); MEMORY[0x31305A8047353130](0i64, 5i64, &amp;v6, v3); } v7.m128i_i64[0] = 0x4B6D1DDD4A7920DFi64; v7.m128i_i64[1] = 0x1E336B548B32934Ei64; v11.m128i_i64[0] = 0x4B6D1DDD4A7920D5i64; v4 = _mm_load_si128(&amp;v7); v11.m128i_i64[1] = 0x1E336B548B32934Ei64; v7 = _mm_xor_si128(v4, v11); MEMORY[0x31305A8047353130](0i64, 5i64, &amp;v7); sub_180003BF8(2766i64); }} 好像是做了一个字符串解密然后输出的操作，浅浅用python跑一下解析字符串验证猜想。 1234567891011121314151617181920212223242526def hex_xor_to_string(a, b): result = a ^ b hex_str = hex(result)[2:] if len(hex_str) % 2 != 0: hex_str = '0' + hex_str result_str = ''.join(chr(int(hex_str[i:i+2], 16)) for i in range(0, len(hex_str), 2)) return result_strx1 = 0x4B6D27B32F124FA1x2 = 0x1E336B548B32934Ey1 = 0x4B6D1DDD4A7920D5y2 = 0x1E336B548B32934Eresult1 = hex_xor_to_string(x1, y1)result2 = hex_xor_to_string(x2, y2)print(&quot;Result 1:&quot;, result1)print(&quot;Result 2:&quot;, result2)res = result1[::-1] + result2[::-1]print(res) 打印出了token基本上确定了这个线程就是打印token的线程，现在就是要想怎么patch这个线程函数使得token能够输出出来。 这里有个mov edx,5语句，将DbgPrintEx函数的level设置成5，可以考虑patch这个语句，将5改成0，那么只需要patch一个字节，共三处。但是又要怎么patch呢，首先不能通过现在这种方式hook PsCreateSystemThread函数调用来确定StartRoutine地址（题目要求不能修改系统模块代码），也就是说得想另外一个办法确定这个线程的地址，然后通过偏移来确定需要patch的地址。 那么怎么确定这个线程地址呢，如果通过ZwQuerySystemInformation枚举内核模块然后枚举模块下的所有线程的话，已经卸载了的ace.sys模块还能被枚举到么？问了下GPT好像是不能的，还可以考虑用StartRoutine地址的后几位做特征，匹配所有线程的开始地址的后几位，但是这种方式又感觉怕遇到地址特征一模一样的，感觉还是不大行。又问GPT怎么寻找到某个内核线程，得到答复是除了ZwQuerySystemInformation枚举，还有通过PsLookupThreadByThreadId函数从进程id和线程id查找的。 那么线程id和进程id又从哪获取呢？因为之前hook过PsCreateSystemThread函数，翻阅文档找到了一个ClientId参数，这个参数指向接收新线程的客户端标识符的结构，即一个pid，一个tid，但是pid，tid应该都是系统分配的吧，能是一个固定值么？hook一下看看输出 诶，tid貌似是系统分配的，但是pid一直都是4，很奇怪，pid=4代表的是什么进程呢？之前刚好枚举过进程来找有没有新进程创建，现在正好能派上用场。 貌似是一个系统进程，GPT了一下发现原来如果驱动程序通过内核模式创建系统线程（使用PsCreateSystemThread），这些线程通常会在系统进程下运行，PID为4。原来如此，驱动程序和进程是一个级别的，但是驱动程序创建的这个线程是在系统进程之下的，而不是属于驱动模块，只是线程起始地址隶属于模块地址空间的，驱动卸载并不影响线程的运行。 这样的话，我们要找的线程因为模块被卸载了，所以它不在所有模块地址空间内，只要枚举所有系统进程pid=4下的所有线程，然后通过判断线程的起始地址是否在所有模块地址之内，即可判断它是否是我们要找的线程。这下思路就通了，开始编写代码实现patch。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &quot;header.h&quot;PVOID MoudleBaseAddress[1024];ULONG64 MoudleSize[1024];ULONG ModuleCount = 0;ULONG Offset1 = 0x52, Offset2 = 0xB5, Offset3 = 0x125;BOOLEAN IsAddressInKnownModules(PVOID Address, PVOID* ModuleBaseAddresses, ULONG64* ModuleSize, ULONG ModuleCount){ for (size_t i = 0; i &lt; ModuleCount; i++) { if (Address &gt;= ModuleBaseAddresses[i] &amp;&amp; Address &lt; (ULONG64)ModuleBaseAddresses[i] + ModuleSize[i]) { return TRUE; } } return FALSE;}PVOID EnumSystemModulesForProcess(HANDLE TargetProcessId){ NTSTATUS status; ULONG bufferSize = 0x10000; PVOID processBuffer = NULL; PVOID moduleBuffer = NULL; ULONG returnLength; // 查询进程信息 processBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!processBuffer) { DbgPrint(&quot;Failed to allocate buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, processBuffer, bufferSize, &amp;returnLength); if (status == STATUS_INFO_LENGTH_MISMATCH) { ExFreePool(processBuffer); bufferSize = returnLength; processBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'proc'); if (!processBuffer) { DbgPrint(&quot;Failed to allocate larger buffer for process information\\n&quot;); return; } status = ZwQuerySystemInformation(SystemProcessInformation, processBuffer, bufferSize, &amp;returnLength); } // 查询模块信息 moduleBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'modl'); if (!moduleBuffer) { DbgPrint(&quot;Failed to allocate buffer for module information\\n&quot;); ExFreePool(processBuffer); return; } status = ZwQuerySystemInformation(SystemModuleInformation, moduleBuffer, bufferSize, &amp;returnLength); if (status == STATUS_INFO_LENGTH_MISMATCH) { ExFreePool(moduleBuffer); bufferSize = returnLength; moduleBuffer = ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'modl'); if (!moduleBuffer) { DbgPrint(&quot;Failed to allocate larger buffer for module information\\n&quot;); ExFreePool(processBuffer); return; } status = ZwQuerySystemInformation(SystemModuleInformation, moduleBuffer, bufferSize, &amp;returnLength); } // 遍历模块信息 if (NT_SUCCESS(status)) { PSYSTEM_MODULE_INFORMATION moduleInfo = (PSYSTEM_MODULE_INFORMATION)moduleBuffer; ModuleCount = moduleInfo-&gt;ModulesCount; for (ULONG i = 0; i &lt; moduleInfo-&gt;ModulesCount; i++) { PSYSTEM_MODULE_INFORMATION_ENTRY moduleEntry = &amp;moduleInfo-&gt;Modules[i]; MoudleBaseAddress[i] = moduleEntry-&gt;Base; MoudleSize[i] = moduleEntry-&gt;Size; } } // 遍历进程信息 if (NT_SUCCESS(status)) { PSYSTEM_PROCESS_INFORMATION processInfo = (PSYSTEM_PROCESS_INFORMATION)processBuffer; while (TRUE) { if (processInfo-&gt;ProcessId == TargetProcessId) { PSYSTEM_THREAD_INFORMATION threadInfo = (PSYSTEM_THREAD_INFORMATION)(processInfo + 1); for (ULONG i = 0; i &lt; processInfo-&gt;NumberOfThreads; i++) { if (!IsAddressInKnownModules(threadInfo[i].StartAddress, MoudleBaseAddress, MoudleSize, ModuleCount)) { DbgPrint(&quot;Find it:%p\\n&quot;,threadInfo[i].StartAddress); return threadInfo[i].StartAddress; } } break; } if (processInfo-&gt;NextEntryOffset == 0) break; processInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)processInfo + processInfo-&gt;NextEntryOffset); } } // 清理分配的内存 ExFreePool(processBuffer); ExFreePool(moduleBuffer); return 0;}VOID UnloadDriver(PDRIVER_OBJECT DriverObject) { KdPrint((&quot;Driver Unloaded\\n&quot;));}NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { DriverObject-&gt;DriverUnload = UnloadDriver; KdPrint((&quot;Driver Loaded\\n&quot;)); HANDLE targetPid = (HANDLE)4; // 系统进程的 PID PVOID targetAddress = EnumSystemModulesForProcess(targetPid); UCHAR valueToWrite = 0x00; // 要写入的字节值 UCHAR valueToRead = 0x05; // 要写入的字节值 ULONG numHasChanged = 0x00; if (*(PUCHAR)((ULONG64)targetAddress + Offset1) == valueToRead) { *(PUCHAR)((ULONG64)targetAddress + Offset1) = valueToWrite; numHasChanged++; } if (*(PUCHAR)((ULONG64)targetAddress + Offset2) == valueToRead) { *(PUCHAR)((ULONG64)targetAddress + Offset2) = valueToWrite; numHasChanged++; } if (*(PUCHAR)((ULONG64)targetAddress + Offset3) == valueToRead) { *(PUCHAR)((ULONG64)targetAddress + Offset3) = valueToWrite; numHasChanged++; } DbgPrint(&quot;numHasChanged:%d\\n&quot;, numHasChanged); return STATUS_SUCCESS;} 成功输出token2 （三）解题过程题目要求： 编写程序，运行时修改尽量少的内存，让shellcode 往自行指定的位置写入token1成功。（满分3分） 要求任意位置，也就是要修改CreateFileA函数的第一个参数的值，根据之前分析的C:\\2024GameSafeRace.token1字符串是由十六进制异或得到的，也就是下面这些 可以考虑的是patch这些十六进制数据，把异或的key改成0，然后密文改成明文即可，因为明文异或0还是明文，但是考虑到要尽量修改少量的内存，我们最好还是保持key不变，自定义密文解密到我们所要的文件地址。跑个python脚本解出新的密文，得到新的密文，接着找到密文所在文件的偏移然后patch即可，给出解题代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//dllmain.cpp#include &quot;pch.h&quot;#include &lt;windows.h&gt;#include &lt;shellapi.h&gt;#include &lt;detours.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib,&quot;detours.lib&quot;)#define _KDEBUG#define DBGMGEBOX(fmt, ...) \\ do { \\ /* 假设最大长度为1024，根据需要调整大小 */ \\ wsprintfA(out, fmt, __VA_ARGS__); \\ MessageBoxA(NULL, out, &quot;提示&quot;, MB_OK); \\ } while(0)char out[100];typedef BOOL(WINAPI* WriteProcessMemory_t)( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten );WriteProcessMemory_t TrueWriteProcessMemory = NULL;BOOLWINAPIHookWriteProcessMemory( _In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, _In_reads_bytes_(nSize) LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T* lpNumberOfBytesWritten){ if (nSize == 4506624 &amp;&amp; *((PUCHAR)lpBuffer + 0x7171) == 0x3) { *((PUCHAR)lpBuffer + 0x7171) = 0x4; *(PULONG64)((ULONG64)lpBuffer + 0x7082) = 0x94e7c2136acc0e5c;// *(PULONG64)((ULONG64)lpBuffer + 0x7093) = 0x8207c5d1af9f3860; *(PULONG64)((ULONG64)lpBuffer + 0x70F1) = 0xa905cca9edcb138c; *(PULONG64)((ULONG64)lpBuffer + 0x7108) = 0xa753b8236c56809a; //C:\\Users\\15386\\Desktop\\flag.txt DBGMGEBOX(&quot;Hook Success!\\n&quot;); } return TrueWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);}BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); TrueWriteProcessMemory = (WriteProcessMemory_t)DetourFindFunction(&quot;kernel32.dll&quot;, &quot;WriteProcessMemory&quot;); DetourAttach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; case DLL_PROCESS_DETACH: DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&amp;(PVOID&amp;)TrueWriteProcessMemory, HookWriteProcessMemory); DetourTransactionCommit(); break; } return TRUE;} 注入hook成功后，成功在桌面的flag.txt输出token1","link":"/postLater/2024%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8PC%E5%88%9D%E8%B5%9B.html"}]}